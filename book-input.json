[{"root":"/var/home/jr/nix-book","config":{"book":{"title":null,"authors":["saylesss88"],"description":null,"language":"en","text-direction":null},"output":{"html":{"additional-css":["theme/extra.css"],"additional-js":["theme/extra.js"]}},"preprocessor":{"rss":{"command":"./mdbook-rss-wrapper.sh"}}},"renderer":"html","mdbook_version":"0.5.0"},{"items":[{"Chapter":{"name":"Getting Started with the Nix Ecosystem","content":"---\ntitle: My Chapter\ndate: 2025-11-21\nauthor: saylesss88\ndescription: Chapter 1\n---\n\n# Chapter1\n\n<details>\n<summary> ✔️ Click to Expand Table of Contents</summary>\n\n<!-- toc -->\n\n</details>\n\n<!-- ![gruv13](images/gruv13.png) -->\n\n![trees](images/trees1.cleaned.png)\n\n## Intro\n\nWelcome to _nix-book_, an introductory book about Nix. This book leans more\ntowards using Flakes but will contrast traditional Nix where beneficial.\nOriginally, this content started as a blog. I'm refining its flow to make it\nmore cohesive.\n\nIn this chapter, I will touch on the different parts of the Nix ecosystem, give\na quick example of each and explain how they fit together.\n\n<details>\n<summary>\n- ✔️: Will indicate an expandable section, click the little triangle to expand.\n</summary>\n\n- These sections are expandable!\n\n</details>\n\nThe code blocks have an option to hide code, where I find it reasonable I will\nhide the outputs of the expressions. Click the eye in the right corner of the\ncode block next to the copy clipboard.\n\nExample click the eye to see hidden text:\n\n```nix\n{\n  attrset = { a = 2; b = 4; };\n~  hidden_set = { a = hidden; b = set; };\n}\n```\n\n> ❗ If you're new to Nix, think of it as a recipe book for software: you\n> describe what you want (declarative), and Nix ensures it’s built the same way\n> every time (reproducible).\n\n### Why Learn Nix?\n\nThe main reason to learn Nix is that it allows you to write declarative scripts\nfor reproducible software builds. Rather than mutate the global state and\ninstall packages to a global location such as `/usr/bin` Nix stores packages in\nthe Nix store, usually the directory `/nix/store`, where each package has its\nown unique subdirectory. This paradigm gives you some powerful features, such\nas:\n\n- Allowing multiple versions or variants of the same package at the same time.\n  This prevents \"DLL hell\" from different applications having dependencies on\n  different versions of the same package.\n\n- Atomic upgrades: Upgrading or uninstalling an application cannot break other\n  applications and either succeed completely or fail completely preventing\n  partial upgrades breaking your system. The nix store is immutable preventing\n  package management operations from overwriting other packages. They wouldn't\n  overwrite each other anyways because the hashing scheme ensures that new\n  versions or repeat packages end up at different paths.\n\n- Nix is designed to provide hermetic builds that aren't affected by the\n  environment, this helps you make sure that when packaging software that the\n  dependencies are complete because they must be explicitly declared as inputs.\n  With other package managers it is more difficult to be sure that an\n  environment variable or something in your `$PATH` isn't affecting your build.\n\nLet’s dive into the key characteristics of Nix:\n\n| Concept          | Description                                                   |\n| ---------------- | ------------------------------------------------------------- |\n| **Pure**         | Functions don't cause side effects.                           |\n| **Functional**   | Functions can be passed as arguments and returned as results. |\n| **Lazy**         | Not evaluated until needed to complete a computation.         |\n| **Declarative**  | Describing a system outcome.                                  |\n| **Reproducible** | Operations that are performed twice return same results       |\n\n> ❗ Important: In Nix, everything is an expression, there are no statements.\n>\n> ❗ Important: Values in Nix are immutable.\n\n### The Nix Ecosystem\n\nThe **Nix Language** is the foundation of the ecosystem and is used to write\n**Nix Expressions**.\n\nExample of a simple nix expression:\n\n```nix\n{ hello = \"world\"; }\n# or\n\"foo\" + \"bar\"\n```\n\nWhile the Nix language provides the foundation for writing expressions, it is\nonly part of the ecosystem. These expressions become powerful when used within\nthe Nix Package Manager, which evaluates and realizes them into tangible\nsoftware builds and system configurations. This is where Nixpkgs and NixOS come\ninto play.\n\n### The Nix Package Manager, Nixpkgs, and NixOS\n\nAt the heart of the Nix ecosystem is **Nix Package Manager**. This powerful\nengine is responsible for orchestrating the entire process: taking **Nix\nexpressions** (like _package definitions_ and _configuration modules_),\nevaluating them into precise _derivations_, executing their build steps (the\n_realization phase_), and meticulously managing the immutable Nix store.\n\nA cornerstone of the Nix ecosystem is **Nixpkgs**. This vast collection\ncomprises tens of thousands of Nix expressions that describe how to build a wide\narray of software packages from source. Nixpkgs is more than just a package\nrepository—it also contains **NixOS Modules**, declarative configurations that\ndefine system behavior, ensuring a structured and reproducible environment.\nThese modules enable users to declaratively describe a Linux system, with each\nmodule contributing to the desired state of the overall system by leveraging\n_package definitions_ and _derivations_. This is how NixOS emerges: it is quite\nsimply the natural consequence of applying the Nix philosophy to building an\nentire Linux operating system.\n\nWe will further expand our understanding of modules in\n[Chapter 3](https://saylesss88.github.io/NixOS_Modules_Explained_3.html)\n\nThe following is an example of a NixOS module that is part of the `nixpkgs`\ncollection:\n\n```nix\n# nixpkgs/nixos/modules/programs/zmap.nix\n{\n  pkgs,\n  config,\n  lib,\n  ...\n}:\n\nlet\n  cfg = config.programs.zmap;\nin\n{\n  options.programs.zmap = {\n    enable = lib.mkEnableOption \"ZMap, a network scanner designed for Internet-wide network surveys\";\n  };\n\n  config = lib.mkIf cfg.enable {\n    environment.systemPackages = [ pkgs.zmap ];\n\n    environment.etc.\"zmap/blacklist.conf\".source = \"${pkgs.zmap}/etc/zmap/blacklist.conf\";\n    environment.etc.\"zmap/zmap.conf\".source = \"${pkgs.zmap}/etc/zmap.conf\";\n  };\n}\n```\n\n- This module, `programs.zmap.nix`, demonstrates how NixOS configurations work.\n  It defines an enable option for the ZMap network scanner. If enabled by the\n  user in their system configuration, the module ensures the `zmap` package is\n  installed and its default configuration files are placed in `/etc`, allowing\n  ZMap to be managed declaratively as part of the operating system.\n  - When `nixpkgs` is imported (e.g., in a NixOS configuration), the\n    configuration options and settings defined by its modules (like\n    `programs.zmap.nix`) become available for use, typically accessed via dot\n    notation (e.g., `config.programs.zmap.enable`). This ability to make such a\n    huge set of modules and packages readily available without a significant\n    performance penalty is due to Nix's **lazy evaluation**; only the\n    expressions required for a particular build or configuration are actually\n    evaluated.\n\n  - Most of the time you'll simply [search](https://search.nixos.org/packages)\n    to see if the package is already included in `nixpkgs` and follow the\n    instructions there to get it on your system. It is good practice to first\n    search for the [options](https://search.nixos.org/options?) to see what\n    configurable settings are available, and then proceed to search for the\n    package itself if you know it exists or if you need its specific package\n    definition. When you look up the options for Zmap, `programs.zmap.enable` is\n    all that is listed in this example.\n\n  - Home Manager uses the same underlying Nix module system as NixOS, and when\n    you do something like home.packages = with pkgs; you are referring to the\n    same package derivations from nixpkgs as you would with\n    `environment.systemPackages`. However, Home Manager's own configuration\n    modules (e.g., for `programs.zsh` or `git`) are distinct and reside in the\n    Home Manager repository, designed for user-specific configurations.\n\nOne of the main differentiating aspects of Nix, as opposed to traditional\npackage managers, is this concept that package builds are treated as pure\nfunctions. This functional paradigm ensures consistency and reproducibility,\nwhich are core tenets of the Nix philosophy.\n\n![Nix is not](images/nix_isnot_nixos.png)\n\n**Fig. X:** Conceptual diagram illustrating the distinction between Nix and\nNixOS. Source: xeiaso, from the blog post \"Making NixOS modules for fun and\n(hopefully) profit\", <https://xeiaso.net/talks/asg-2023-nixos/>.\n\nNix expressions permeate the ecosystem—everything in Nix is an expression,\nincluding the next key components: package definitions and derivations.\n\n### Package Definitions & Derivations\n\n**Package Definitions** are specialized expressions that tell Nix how to build\nsoftware.\n\nExample of a package definition:\n\n```nix\n# hello.nix\n{pkgs ? import <nixpkgs> {}}:\npkgs.stdenv.mkDerivation {\n  pname = \"hello\";\n  version = \"2.12.1\";\n\n  src = pkgs.fetchurl {\n    url = \"https://ftp.gnu.org/gnu/hello/hello-2.12.1.tar.gz\";\n    sha256 = \"086vqwk2wl8zfs47sq2xpjc9k066ilmb8z6dn0q6ymwjzlm196cd\";\n  };\n\n  nativeBuildInputs = [pkgs.autoconf pkgs.automake pkgs.gcc];\n\n  configurePhase = ''\n    ./configure --prefix=$out\n  '';\n\n  buildPhase = ''\n    make\n  '';\n\n  installPhase = ''\n    make install\n  '';\n}\n```\n\n1. **Evaluation Phase**:\n\nNow when you run something like:\n\n```bash\nnix-instantiate hello.nix\nwarning: you did not specify '--add-root'; the result might be removed by the garbage collector\n/nix/store/p2hbg16a9kpqgx2nzcsq39wmnyxyq4jy-hello-2.12.1.drv\n```\n\n- Nix evaluates the expression and produces a `.drv` file (the **derivation**),\n  a precise JSON-like blueprint describing how the package will be built. It\n  does not contain the built software itself.\n\n2. **Realization Phase**:\n\nWhen you run:\n\n```bash\nnix-build hello.nix\n#...snip...\nshrinking RPATHs of ELF executables and libraries in /nix/store/53hqyw72dijq3wb5kc0ln04g681gk6cp-hello-2.12.1\nshrinking /nix/store/53hqyw72dijq3wb5kc0ln04g681gk6cp-hello-2.12.1/bin/hello\nchecking for references to /build/ in /nix/store/53hqyw72dijq3wb5kc0ln04g681gk6cp-hello-2.12.1...\ngzipping man pages under /nix/store/53hqyw72dijq3wb5kc0ln04g681gk6cp-hello-2.12.1/share/man/\npatching script interpreter paths in /nix/store/53hqyw72dijq3wb5kc0ln04g681gk6cp-hello-2.12.1\nstripping (with command strip and flags -S -p) in  /nix/store/53hqyw72dijq3wb5kc0ln04g681gk6cp-hello-2.12.1/bin\n/nix/store/53hqyw72dijq3wb5kc0ln04g681gk6cp-hello-2.12.1\n```\n\n- Nix realizes the derivation by actually executing the build steps, fetching\n  sources, compiling (if needed), and producing the final result (typically\n  stored in e.g. `/nix/store/53hqyw72dijq3wb5kc0ln04g681gk6cp-hello-2.12.1`)\n\n- `nix-build` also creates a symlink named `result` in your current directory,\n  pointing to the final build output in the Nix store.\n\n3. Execute the program:\n\n```bash\n./result/bin/hello\nHello, world!\n```\n\n`result/bin/hello` points to the executable inside the output of the\nderivation.The derivation describes how the package is built, but does not\ninclude the final binaries.\n\nTo say that another way, the derivation is not the executable. The executable is\none of the derivations `outputs`. When Nix \"realizes\" a derivation, it executes\nthose build instructions, and the result is the actual built software, which\ngets placed into its own unique path in the Nix store.\n\nA single derivation can produce multiple outputs. The executable is typically\npart of the `out` output, specifically in its `bin` directory.\n\nHere is a small snippet of what a `.drv` file could look like, I got this from\nbuilding the hello derivation and running the following on the store path:\n\n```bash\nnix show-derivation /nix/store/9na8mwp5zaprikqaqw78v6cdn1rxac7i-hello-2.12.1\n```\n\n```nix\n{\n  \"/nix/store/871398c9cbskmzy6bvfnynr8yrlh7nk0-hello-2.12.1.drv\": {\n    \"args\": [\n      \"-e\",\n      \"/nix/store/v6x3cs394jgqfbi0a42pam708flxaphh-default-builder.sh\"\n    ],\n    \"builder\": \"/nix/store/1jzhbwq5rjjaqa75z88ws2b424vh7m53-bash-5.2p32/bin/bash\",\n    \"env\": {\n      \"__structuredAttrs\": \"\",\n      \"buildInputs\": \"\",\n      \"builder\": \"/nix/store/1jzhbwq5rjjaqa75z88ws2b424vh7m53-bash-5.2p32/bin/bash\",\n      \"cmakeFlags\": \"\",\n      \"configureFlags\": \"\",\n      \"depsBuildBuild\": \"\",\n      \"depsBuildBuildPropagated\": \"\",\n      \"depsBuildTarget\": \"\",\n      \"depsBuildTargetPropagated\": \"\",\n      \"depsHostHost\": \"\",\n      \"depsHostHostPropagated\": \"\",\n      \"depsTargetTarget\": \"\",\n      \"depsTargetTargetPropagated\": \"\",\n      \"doCheck\": \"\",\n      \"doInstallCheck\": \"\",\n      \"mesonFlags\": \"\",\n      \"name\": \"hello-2.12.1\",\n      \"nativeBuildInputs\": \"\",\n      \"out\": \"/nix/store/9na8mwp5zaprikqaqw78v6cdn1rxac7i-hello-2.12.1\",\n      \"outputs\": \"out\",\n      \"patches\": \"\",\n      \"pname\": \"hello\",\n      \"propagatedBuildInputs\": \"\",\n      \"propagatedNativeBuildInputs\": \"\",\n      \"src\": \"/nix/store/pa10z4ngm0g83kx9mssrqzz30s84vq7k-hello-2.12.1.tar.gz\",\n      \"stdenv\": \"/nix/store/80wijs24wjp619zmrasrh805bax02xjm-stdenv-linux\",\n      \"strictDeps\": \"\",\n      \"system\": \"x86_64-linux\",\n      \"version\": \"2.12.1\"\n    },\n# ... snip ...\n```\n\n#### Conclusion\n\nIn this introductory chapter, we've laid the groundwork for understanding the\npowerful Nix ecosystem. We explored how the Nix Language forms the declarative\nbedrock, enabling us to define desired system states and software builds as\nexpressions. You saw how the Nix Package Manager orchestrates this process,\ntransforming those expressions into precise derivations during the evaluation\nphase, and then faithfully \"realizing\" them into reproducible, isolated\nartifacts within the immutable `/nix/store`.\n\nWe also introduced the vast Nixpkgs collection, which provides tens of thousands\nof package definitions and forms the foundation for NixOS — a fully declarative\noperating system built on these principles—and even user-level configurations\nlike those managed by Home Manager. This unique functional approach, with its\nemphasis on immutability and lazy evaluation, is what enables Nix's promises of\nconsistency, atomic upgrades, and truly hermetic builds, fundamentally changing\nhow we think about software and system management.\n\n##### Related Sub-Chapters\n\n- The [Nix Language](https://saylesss88.github.io/nix/nix_language.html)\n\n- [Nix Package Manager](https://saylesss88.github.io/nix/nix_package_manager.html)\n\nNow that you have a foundational understanding of the Nix ecosystem and its core\noperational cycle, we are ready to delve deeper into the building blocks of Nix\nexpressions. In the next chapter,\n[Understanding Nix Functions](https://saylesss88.github.io/Understanding_Nix_Functions_2.html),\nwe will peel back the layers and explore the intricacies of function arguments,\nadvanced patterns, scope, and how functions play a crucial role in building more\nsophisticated Nix expressions and derivations.\n\nHere are some resources that are helpful for getting started:\n\n#### Resources\n\n<details>\n<summary> ✔️ Resources (Click to Expand)</summary>\n\n- [NixOS Search](https://search.nixos.org/packages)\n\n- [NixOS Options](https://search.nixos.org/options?)\n\n- [Extranix Home-Manager Option Search](https://home-manager-options.extranix.com/?query=&release=master)\n\n- [awesome-nix](https://github.com/nix-community/awesome-nix)\n\n- [Nix Core Ecosystem](https://wiki.nixos.org/wiki/Nix_ecosystem), Nix, NixOS,\n  Nix Lang, Nixpkgs are all distinctly different; related things which can be\n  confusing for beginners this article explains them.\n\n- [nixpkgs](https://github.com/nixos/nixpkgs): Vast package repository\n\n- [How Nix Works](https://nixos.org/guides/how-nix-works/)\n\n- [Nix Reference Manual Data Types](https://nix.dev/manual/nix/2.26/language/types#type-attrs)\n  The main Data Types you'll come across in the Nix ecosystem\n\n- [NixOS Wiki](https://wiki.nixos.org/wiki/NixOS_Wiki)\n\n- [nix.dev](https://nix.dev/): Has become the top respected source of\n  information in my opinion. There is a lot of great stuff in here, and they\n  actively update the information.\n\n</details>\n","number":[1],"sub_items":[{"Chapter":{"name":"Nix Language","content":"# Nix Language\n\n<details>\n<summary> ✔️ Click to Expand Table of Contents</summary>\n\n<!-- toc -->\n\n</details>\n\n<!-- ![lambda1](../images/lambda1.png) -->\n\n## Nix Expression Language Syntax Overview\n\nThe Nix language is designed for conveniently creating and composing\n_derivations_ precise descriptions of how contents of files are used to derive\nnew files. --[Nix Reference Manual](https://nix.dev/manual/nix/2.28/language/)\n\nNix is often described as “JSON with functions.” It’s a declarative language\nwhere you define outcomes, not step-by-step instructions. Instead of writing\nsequential code, you create expressions that describe data structures,\nfunctions, and dependencies. These expressions are evaluated lazily, meaning Nix\ncomputes values only when needed, making it efficient for managing large\nsystems.\n\nYou can plug most of the following into the `nix repl` I'm showing it in a\nsingle code block here for brevity:\n\n```nix\n# Comments Look Like This!\n\n# Strings\n\"This is a string\"          # String literal\n\n''\none\ntwo                        # multi-line String\nthree\n''\n\n(\"foo\" + \"bar\")           # => \"foobar\"\n\n\"foo\" != \"bar\"   # Inequality test  # => true\n\n!false      # => true\n\n(\"Home dir is ${builtins.getEnv \"HOME\"}\")  # String Interpolation\n# => \"Home dir is /home/jr\"\n\n\"3 6 ${builtins.toString 9}\"\n# => \"3 6 9\"\n\n\"goodbye ${ { d = \"world\";}.d}\"\n# => \"goodbye world\"\n\n# Booleans\n\n(false && true)    # AND         # => false\n\n(true || false)    # OR         # => true\n\n(if 6 < 9 then \"yay\" else \"nay\")  # => \"yay\"\n\nnull      # Null Value\n\n679       # Integer\n\n(6 + 7 + 9) # => 22   # Addition\n\n(9 - 3  - 2) # => 4   # Subtraction\n\n(6 / 3)  # => 2       # Division\n6.79      # Floating Point\n\n/etc/nixos      # Absolute Path\n\n../modules/nixos/boot.nix    # relative\n\n# Let expressions\n\n(let a = \"2\"; in                   # Let expressions are a way to create variables\na + a + builtins.toString \"4\")\n# => \"224\"\n\n(let first = \"firstname\"; in\n\"lastname \" first)\n# => \"lastname firstname\"\n\n# Lists\n\n[ 1 2 \"three\" \"bar\" \"baz\" ]   # lists are whitespace separated\n\nbuiltins.elemAt [ 1 2 3 4 5 ] 3\n# => 4\n\nbuiltins.length [ 1 2 3 4 ]\n# => 4\n\n# Attrsets\n\n{ first = \"Jim\"; last = \"Bo\"; }.last # Attribute selection\n# => \"Bo\"\n\n{ a = 1; b = 3; } // { c = 4; b = 2; }   # Attribute Set merging\n# => { a = 1; b = 2; c = 4; }               # Right Side takes precedence\n\nbuiltins.listToAttrs [ { name = \"Jr\"; value = \"Jr Juniorville\"; } {name = \"$\"; value = \"JR\"; } { name = \"jr\"; value = \"jr\nville\"; }]\n# => { \"$\" = \"JR\"; Jr = \"Jr Juniorville\"; jr = \"jrville\"; }\n\n# Control Flow\n\nif 2 * 2 == 4\nthen \"yes!\"\nelse \"no!\"\n# => \"yes!\"\n\nassert 2 * 2\n== 4; \"yes!\"\n# => \"yes!\"\n\nwith builtins;\nhead [ 5 6 7 ]\n# => 5\n\n# or\n\nbuiltins.head[ 5 6 7 ]\n\ninherit pkgs     # pkgs = pkgs;\nsrc;             # src = src;\n```\n\n### Understanding Laziness\n\nNix expressions are evaluated lazily, meaning Nix computes values only when\nneeded. This is a powerful feature that makes Nix efficient for managing large\nsystems, as it avoids unnecessary computations.\n\nFor example, observe how `a` is never evaluated in the following `nix-repl`\nsession:\n\n```nix\nnix-repl> let a = builtins.div 4 0; b = 6; in b\n6\n```\n\n- Since `a` isn't used in the final result, there's no division by zero error.\n\n### Strings and String Interpolation\n\n**Strings**: Strings are enclosed in double quotes (`\"`) or two single quotes\n(`''`).\n\n```nix\nnix-repl> \"stringDaddy\"\n\"stringDaddy\"\nnix-repl> ''\n  This is a\n  multi-line\n  string\n''\n\"This is a\\nmulti-line\\nstring.\\n\"\n```\n\n[string interpolation](https://nix.dev/manual/nix/2.24/language/string-interpolation).\nis a language feature where a string, path, or attribute name can contain an\nexpressions enclosed in `${ }`. This construct is called an _interpolated\nstring_, and the expression inside is an _interpolated expression_.\n\nRather than writing:\n\n```nix\nlet path = \"/usr/local\"; in \"--prefix=${path}\"\n```\n\nThis evaluates to `\"--prefix=/usr/local\"`. Interpolated expressions must\nevaluate to a string, path, or an attribute set with an `outPath` or\n`__toString` attribute.\n\n### Attribute Sets\n\n**Attribute sets** are all over Nix code and deserve their own section, they are\nname-value pairs wrapped in curly braces, where the names must be unique:\n\n```nix\n{\n  string = \"hello\";\n  int = 8;\n}\n```\n\nAttribute names usually don't need quotes.\n\nYou can access attributes using _dot notation_:\n\n```nix\nlet person = { name = \"Alice\"; age = 30; }; in person.name\n\"Alice\"\n```\n\nYou will sometimes see attribute sets with `rec` prepended. This allows access\nto attributes within the set:\n\n```nix\nrec {\n  x = y;\n  y = 123;\n}.x\n```\n\n**Output**: `123`\n\nor\n\n```nix\nrec {\n  one = 1;\n  two = one + 1;\n  three = two + 1;\n}\n```\n\n**Output**:\n\n```nix\n {\n  one = 1;\n  three = 3;\n  two = 2;\n }\n```\n\n```nix\n# This would fail:\n{\n  one = 1;\n  two = one + 1;  # Error: undefined variable 'one'\n  three = two + 1;\n}\n```\n\nRecursive sets introduce the danger of _infinite recursion_ For example:\n\n```nix\nrec {\n  x = y;\n  y = x;\n}.x\n```\n\nWill crash with an `infinite recursion encountered` error message.\n\nThe\n[attribute set update operator](https://nix.dev/manual/nix/2.24/language/operators.html#update)\nmerges two attribute sets.\n\n**Example**:\n\n```nix\n{ a = 1; b = 2; } // { b = 3; c = 4; }\n```\n\n**Output**:\n\n```nix\n{ a = 1; b = 3; c = 4; }\n```\n\nHowever, names on the right take precedence, and updates are shallow.\n\n**Example**:\n\n```nix\n{ a = { b = 1; }; } // { a = { c = 3; }; }\n```\n\n**Output**:\n\n```nix\n{ a = { c = 3; }; }\n```\n\nAbove, key `b` was completely removed, because the whole `a` value was replaced.\n\n**Inheriting Attributes**\n\n- Click to see Output:\n\n```nix\nlet x = 123; in\n{\n  inherit x;\n  y = 456;\n}\n```\n\nis equivalent to\n\n```nix\nlet x = 123; in\n{\n  x = x;\n  y = 456;\n}\n```\n\nwhich are both equivalent to\n\n```nix\n{\n  x = 123;\n  y = 456;\n}\n```\n\n> ❗: This works because `x` is added to the lexical scope by the `let`\n> construct.\n\nNow that we understand attribute sets lets move on to functions, a powerful\nfeature of the Nix language that gives you the ability to reuse and share\nlogical pieces of code.\n\n### Functions(lambdas):\n\nFunctions in Nix help you build reusable components and are the the building\nblocks of Nix. In the next chapter we'll go even further into Nix functions and\nhow to use them but I will touch on them here.\n\nNix functions have this form:\n\n```nix\npattern: body\n```\n\nThe following is a function that expects an integer and returns it increased by\n1:\n\n```nix\nx: x + 1   # lambda function, not bound to a variable\n```\n\nThe pattern tells us what the argument of the function has to look like, and\nbinds variables in the body to (parts of) the argument.\n\n```nix\n(x: x + 5) 200\n205\n```\n\nThey are all lambdas (i.e. anonymous functions without names) until we assign\nthem to a variable like the following example.\n\nFunctions are defined using this syntax, where `x` and `y` are attributes passed\ninto the function:\n\n```nix\n{\n  my_function = x: y: x + y;\n}\n```\n\nThe code below calls a function called `my_function` with the parameters `2` and\n`3`, and assigns its output to the `my_value` field:\n\n```nix\n{\n  my_value = my_function 2 3;\n}\nmy_value\n5\n```\n\nThe body of the function automatically returns the result of the function.\nFunctions are called by spaces between it and its parameters. No commas are\nneeded to separate parameters.\n\nThe following is a function that expects an attribute set with required\nattributes `a` and `b` and concatenates them:\n\n```nix\n{ a, b }: a + b\n```\n\n**Default Values in Functions**:\n\nFunctions in Nix can define **default values** for their arguments. This allows\nfor more flexible function calls where some arguments are optional.\n\n```nix\n{ x, y ? \"foo\", z ? \"bar\" }: z + y + x\n```\n\n- Specifies a function that only requires an attribute named `x`, but optionally\n  accepts `y` and `z`.\n\n**@-patterns in functions**:\n\nAn `@-pattern` provides a means of referring to the whole value being matched by\nthe function's argument pattern, in addition to destructuring it. This is\nespecially useful when you want to access attributes that are not explicitly\ndestructured in the pattern:\n\n```nix\nargs@{ x, y, z, ... }: z + y + x + args.a\n# or\n{ x, y, z, ... } @ args: z + y + x + args.a\n```\n\n- Here, `args` is bound to the argument as _passed_, which is further matched\n  against the pattern `{ x, y, z, ... }`. The `@-pattern` makes mainly sense\n  with an ellipsis(`...`) as you can access attribute names as `a`, using\n  `args.a`, which was given as an additional attribute to the function.\n\n- We will expand on Functions in\n  [This Chapter](https://saylesss88.github.io/Understanding_Nix_Functions_2.html)\n\n### If, Let, and With Expressions\n\nNix is a pure expression language, meaning every construct evaluates to a value\n— there are no statements. Because of this, **if expressions** in Nix work\ndifferently than in imperative languages, where conditional logic often relies\non statements (`if`, `elsif`, etc.).\n\n**If expressions in Nix**:\n\nSince everything in Nix is an expression, an `if` expression must always produce\na value:\n\n```nix\nnix-repl> a = 6\nnix-repl> b = 10\nnix-repl> if a > b then \"yes\" else \"no\"\n\"no\"\n```\n\nHere, `\"no\"` is the result because `a`(6) is not greater than `b`(10). Notice\nthat there's no separate conditional statement -- the entire construct evaluates\nto a value.\n\nAnother example, integrating built-in functions:\n\n```nix\n{\n  key = if builtins.pathExists ./path then \"YES\" else \"NO!\";\n}\n```\n\nIf `./path` exists it will evaluate to the value `\"YES\"` or else it will\nevaluate to `\"NO!\"`.\n\nThus, the final result of the expression would be:\n\n```nix\n{ key = \"YES\"; }\n# or\n{ key = \"NO!\"; }\n```\n\nSince Nix does not have statements, Nix's `if` statements behave more like\n[ternary operators](https://en.wikipedia.org/wiki/Ternary_conditional_operator)\n(`condition ? value_if_true : value_if_false`) in other languages.\n\n**Let expressions**:\n\nLet expressions in Nix is primarily a mechanism for local variable binding and\nscoping. It allows you to define named values that are only accessible within\nthe `in` block of the `let` expression. This is useful for keeping code clean\nand avoiding repitition.\n\nFor example:\n\n```nix\nlet\n  a = \"foo\";\n  b = \"fighter\";\nin a + b\n\"foofighter\"\n```\n\nHere, `a` and `b` are defined inside the `let` block, and their values are used\nin the `in` expression. Since everything in Nix is an expression, `a + b`\nevaluates to `\"foofighter\"`\n\n**Using Let Expressions Inside Attribute Sets**\n\nLet expressions are commonly used when defining attribute sets (Click for\noutput):\n\n```nix\nlet\n  appName = \"nix-app\";\n  version = \"1.0\";\nin {\n  name = appName;\n  fullName = appName + \"-\" + version;\n}\n~{\n~  name = \"nix-app\";\n~  fullName = \"nix-app-1.0\";\n~}\n```\n\nThis allows you to reuse values within an attribute set, making the code more\nmodular and preventing duplication.\n\n**Let Expressions in Function Arguments**\n\nYou can also use let expressions within function arguments to define\nintermediate values before returning an output:\n\n```nix\n{ pkgs, lib }:\nlet\n  someVar = \"hello\";\n  otherVar = \"world\";\nin\n{ inherit pkgs lib someVar otherVar; }\n```\n\nResult:\n\n```nix\n{\n  pkgs = <value>;\n  lib = <value>;\n  someVar = \"hello\";\n  otherVar = \"world\";\n}\n```\n\nHere, `inherit` brings `pkgs` and `lib` into the resulting attribute set,\nalongside the locally defined variables `someVar` and `otherVar`.\n\n**Key Takeaways**:\n\n- Let expressions allow local variable bindings that are only visible inside the\n  in block. They also help avoid repitition and improve readability.\n\n- Commonly used inside attribute sets or function arguments.\n\n- Their scope is limited to the expression in which they are declared.\n\n**With expressions**:\n\nA `with` expression in Nix is primarily used to simplify access to attributes\nwithin an attribute set. Instead of repeatedly referring to a long attribute\npath, with temporarily brings the attributes into scope, allowing direct access\nwithout prefixing them.\n\n**Basic Example: Reducing Attribute Path Usage**\n\nConsider the following expressions:\n\n```nix\nnix-repl> longName = { a = 3; b = 4; }\nnix-repl> longName.a + longName.b\n7\n```\n\nHere, we must explicitly reference `longName.a` and `longName.b`. Using a `with`\nexpression simplifies this:\n\n```nix\nnix-repl> with longName; a + b\n7\n```\n\nNow, within the scope of the with expression, `a` and `b` are accessible without\nprefixing them with `longName`.\n\n**Practical Use Case: Working with `pkgs`**\n\nOne of the most common uses of `with` that you'll see is when dealing with\npackages from `nixpkgs` is writing the following:\n\n```nix\n{ pkgs }:\nwith pkgs; {\n  myPackages = [ vim git neofetch ];\n}\n```\n\nInstead of writing this:\n\n```nix\n{ pkgs }:\n{\n  myPackages = [ pkgs.vim pkgs.git pkgs.neofetch ];\n}\n```\n\n> Tip: Overusing `with lib;` or `with pkgs;` can reduce clarity, it may be fine\n> for smaller modules where the scope is limited. For larger configurations,\n> explicit references (`pkgs.something`) often make dependencies clearer and\n> prevent ambiguity.\n\n### Nix Language Quirks\n\n1. `with` gets less priority than `let`. This can be confusing, especially if\n   you like to write `with pkgs;`:\n\n```nix\nnix-repl> pkgs = { x = 2; }\n\nnix-repl> with pkgs; x\n2\n\nnix-repl> with pkgs; let x = 4; in x\n4\n```\n\nThis shows us that the `let` binding overrides the `with` binding.\n\n```nix\nlet x = 4; in with pkgs; x\n4\n```\n\nStill returns `4`, but the reasoning is different. The `with` expression doesn't\ndefine new bindings; it simply makes attributes from `pkgs` available as\nunqualified names. However, because `let x = 4` is **outside** the `with`, it\nalready extablished `x = 4`, so when `with pkgs; x` is evaluated inside, `x`\nstill refers to the **outer** `let` binding, not the one from `pkgs`.\n\n2. Default values aren't bound in `@-patterns`\n\nIn the following example, calling a function that binds a default value `\"baz\"`\nto the attribute `b` of an argument using an alias (`@`) pattern, with an empty\nattribute set as argument, results in the alias variable inputs being bound to\nthe original empty attribute set instead of including the default value:\n\n```nix\n(inputs@(b ? \"baz\"): inputs) {}\n```\n\nOutput:\n\n```nix\n{}\n```\n\nThis happens because the alias `inputs@` binds to the argument as passed, before\nthe default value for `b` is applied.\n\nThe syntax requires curly brackets around the attribute set pattern for\ncorrectness, so the fixed syntax would be:\n\n```nix\n(inputs@{b ? \"baz\"}: inputs) {}\n```\n\nHowever, even with this fix, the inputs alias still refers to the original\nargument without defaults applied. So the quirk persists, showing how default\nvalues in `@-patterns` do not propagate into the aliased variable.\n\n3. Destructuring function arguments:\n\n```nix\nnix-repl> f = { x ? 2, y ? 4 }: x + y\n\nnix-repl> f { }\n6\n```\n\nThe function `f` takes an attribute set with default values (`x = 2`, `y = 4`)\n\nWhen called with `{}` (an empty set), it falls back to the default values\n(`2 + 4` -> `6`)\n\nUsing `@args` to capture the entire input set:\n\nThe `@args` syntax allows us to retain access to the full attribute set, even\nafter destructuring:\n\n```nix\nnix-repl> f = { x ? 1, y ? 2, ... }@args: with args; x + y + z\n\nnix-repl> f { z = 3; }\n6\n```\n\nThe `{ x ? 1, y ? 2, ... }` syntax means `x` and `y` have defaults, while `...`\nallows additional attributes.\n\n`@args` binds the entire attribute set (`args`) so that we can access `z`, which\nwouldn't be destructured by default.\n\nWhen calling `f { z = 3; }`, we pass an extra attribute (`z = 3`), making\n`x + y + z` → `1 + 2 + 3 = 6`.\n\n4. Imports and namespaces\n\nThere is a keyword import, but it's equivalent in other languages is eval. It\ncan be used for namespacing too:\n\n```nix\nlet\n  pkgs = import <nixpkgs> {};\n  lib = import <nixpkgs/lib>;\nin\n  pkgs.runCommand (lib.strings.removePrefix \"....\n```\n\nconsider using `import` here as using `qualified import ...` in Haskell or\n`import ...` in Python.\n\nAnother way of importing is with `import ...;`, which corresponds to Python\n`from ... import *`.\n\nBut because of not very great IDE support in Nix, `with import ...;` is\ndiscouraged. Rather use inherit, especially if you are targeting source code for\nNix newcomers:\n\n```nix\nlet\n  lib = import <nixpkgs/lib>;\n  inherit (lib.strings)\n    removePrefix removeSuffix\n  ;\n  inherit (lib.lists)\n    isList init drop\n  ;\nin\n  removePrefix ...\n```\n\n`inherit` has higher priority than `with`, and conflicts with `let`\n\n```nix\nnix-repl> let pkgs = { x = 1; }; x = 2; x = 3; inherit (pkgs) x; in x\nerror: attribute ‘x’ at (string):1:31 already defined at (string):1:24\n```\n\nThis makes it a sane citizen of Nix lanugage... except it has a twin, called\n`{ inherit ...; }`. They DON'T do the same - `let inherit ...` adds\nlet-bindings, and `{ inherit ...; }` adds attributes to a record.\n--<https://nixos.wiki/wiki/Nix_Language_Quirks>\n\n5. Only attribute names can be interpolated, not Nix code:\n\n```nix\nnix-repl> let ${\"y\"} = 4; in y\n4\n\nnix-repl> with { ${\"y\"} = 4; }; y\n4\n\nlet y = 1; x = ${y}; in x\nerror: syntax error, unexpected DOLLAR_CURLY\n```\n\n**Conclusion**\n\n- `let` bindings introduce new local values and override anything from `with`.\n\n- `with` doesn't create bindings - it only makes attributes available within its\n  scope.\n\n- The order matters: If `let x = 4` is outside `with`, then `x = 4` already\n  exists before `with` runs, so `with pkgs; x` resolves to `4`, not the value\n  from `pkgs`.\n\n#### Resources\n\n<details>\n<summary> ✔️ Resources (Click to Expand) </summary>\n\nA few resources to help get you started with the Nix Language, I have actually\ngrown to love the language. I find it fairly simple but powerful!\n\n- [nix.dev nixlang-basics](https://nix.dev/tutorials/nix-language.html)\n\n- [Nix Language Overview](https://nix.dev/manual/nix/2.24/language/)\n\n- [learn nix in y minutes](https://learnxinyminutes.com/nix/)\n\n- [nix onepager](https://github.com/tazjin/nix-1p)\n\n- [zero-to-nix nix lang](https://zero-to-nix.com/concepts/nix-language/)\n\n- [nix-pills basics of nixlang](https://nixos.org/guides/nix-pills/04-basics-of-language.html)\n\n- [Basics of the Language Pill](https://nixos.org/guides/nix-pills/04-basics-of-language)\n\n</details>\n","number":[1,1],"sub_items":[],"path":"nix/nix_language.md","source_path":"nix/nix_language.md","parent_names":["Getting Started with the Nix Ecosystem"]}},{"Chapter":{"name":"Nix Package Manager","content":"# Nix Package Manager\n\n<details>\n<summary> Click to Expand Table of Contents</summary>\n\n<!-- toc -->\n\n</details>\n\n<!-- ![nix99](../images/nix99.png) -->\n\n## Nix Package Manager\n\nNix is a _purely functional package manager_. This means that it treats packages\nlike values in purely functional programming languages -- they are built by\nfunctions that don't have side-effects, and they never change after they have\nbeen built.\n\nNix stores packages in the _Nix store_, usually the directory `/nix/store`,\nwhere each package has its own unique subdirectory such as:\n\n```bash\n/nix/store/y53c0lamag5wpx7vsiv7wmnjdgq97yd6-yazi-25.5.14pre20250526_74a8ea9\n```\n\nYou can use the Nix on most Linux distributions and Mac OS also has good support\nfor Nix. It should work on most platforms that support POSIX threads and have a\nC++11 compiler.\n\nWhen I install Nix on a distro like Arch Linux I usually use the Zero to Nix\ninstaller as it automates several steps, such as enabling flakes by default:\n\n```bash\ncurl --proto '=https' --tlsv1.2 -sSf -L https://install.determinate.systems/nix | sh -s -- install\n```\n\nIf you have concerns about the \"curl to Bash\" approach you could examine the\ninstallation script\n[here](https://raw.githubusercontent.com/DeterminateSystems/nix-installer/main/nix-installer.sh)\nthen download and run it:\n\n```bash\ncurl --proto '=https' --tlsv1.2 -sSf -L https://install.determinate.systems/nix > nix-installer.sh\nchmod +x nix-installer.sh\n./nix-installer.sh install\n```\n\nI got the above commands from\n[zero-to-nix](https://zero-to-nix.com/start/install/)\n\nThe main difference between using the nix package manager on another\ndistribution and NixOS is that NixOS uses Nix not just for package management\nbut also to manage the system configuration (e.g., to build config files in\n`/etc`).\n\n[Home Manager](https://nix-community.github.io/home-manager/) is a Nix-powered\ntool for reproducible management of the contents of the users' home directories.\nThis includes programs, configuration files, environment variables, and\narbitrary files. Home manager uses the same module system as NixOS.\n\nNow that we've discussed some of the basics of the Nix package manager, lets see\nhow it is used to build and manage software in NixOS.\n\n## Channels\n\nNix packages are distributed through Nix channels; mechanisms for distributing\nNix expressions and the associated binary caches for them. Channels are what\ndetermine which versions your packages have. (i.e. _stable_ or _unstable_). A\nchannel is a name for the latest \"verified\" git commits in Nixpkgs. Each channel\nrepresents a different policy for what \"verified\" means. Whenever a new commit\nin `Nixpkgs` passes the verification process, the respective channel is updated\nto point to that new commit.\n\nWhile channels provide a convenient way to get the latest stable or unstable\npackages, they introduce a challenge for strict reproducibility. Because a\nchannel like `nixos-unstable` is constantly updated, fetching packages from it\ntoday might give you a different set of package versions than fetching from it\ntomorrow, even if your configuration remains unchanged. This \"rolling release\"\nnature at a global level can make it harder to share and reproduce exact\ndevelopment environments or system configurations across different machines or\nat different points in time.\n\n## Channels vs. Flakes Enhancing Reproducibility\n\nBefore the introduction of **Nix Flakes**, channels were the primary mechanism\nfor sourcing `Nixpkgs`. While functional, they posed a challenge for exact\nreproducibility because they point to a moving target (the latest commit on a\nbranch). This meant that a `nix-build` command run yesterday might produce a\ndifferent result than one run today, simply because the channel updated.\n\nNix Flakes were introduced to address this. Flakes bring a built-in,\nstandardized way to define the exact inputs to a Nix build, including the\nprecise Git revision of `Nixpkgs` or any other dependency.\n\nHere's a quick comparison:\n\n| Feature              | Nix Channels (traditional)                                  | Nix Flakes (modern approach)                                                 |\n| :------------------- | :---------------------------------------------------------- | :--------------------------------------------------------------------------- |\n| **Input Source**     | Global system configuration (`nix-channel --update`)        | Explicitly defined in `flake.nix` (e.g., `github:NixOS/nixpkgs/nixos-23.11`) |\n| **Reproducibility**  | \"Rolling release\"; less reproducible across time/machines   | Highly reproducible due to locked inputs (`flake.lock`)                      |\n| **Dependency Mgmt.** | Implicitly managed by global channel                        | Explicitly declared and version-locked within `flake.nix`                    |\n| **Sharing**          | Relies on users having same channel version                 | Self-contained; `flake.lock` ensures everyone gets same inputs               |\n| **Learning Curve**   | Simpler initial setup, but tricky reproducibility debugging | Higher initial learning curve, but simplifies reproducibility                |\n\nThe ability of Flakes to \"lock\" the exact version of all dependencies in a\n`flake.lock` file is a game-changer for collaboration and long-term\nreproducibility, ensuring that your Nix configuration builds the same way, every\ntime, everywhere.\n\n## Nixpkgs\n\n**Nixpkgs** is the largest repository of Nix packages and NixOS modules.\n\nFor **NixOS** users, `nixos-unstable` channel branch is the rolling release,\nwhere the packages are tested and must pass integration tests.\n\nFor **standalone Nix** users, `nixpkgs-unstable` channel branch is the rolling\nrelease, where packages pass only basic build tests and are upgraded often.\n\nFor Flakes, as mentioned above they don't use channels so `nixpkgs` will be\nlisted as an `input` to your flake. (e.g.,\n`inputs.nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";`) When using flakes\nyou can actually disable channels and actually recommended to avoid conflicts\nbetween traditional channel-based workflows and the flake system.\n\n### Updates\n\nThe mechanism for updating your Nix environment differs fundamentally between\nchannels and flakes, directly impacting reproducibility and control.\n\n#### Updating with Channels (Traditional Approach)\n\nWith channels, updates are a global operation that pulls the latest state of a\nspecific branch.\n\n**How it works**: You typically use `nix-channel --update` to fetch the latest\ncommit from the channels you've subscribed to. For instance,\n`sudo nix-channel --update nixos` (for NixOS) or `nix-channel --update nixpkgs`\n(for `nix-env` on other Linux distributions).\n\n**Implication**: This command updates your local system's understanding of what\n\"nixos\" or \"nixpkgs-unstable\" means. From that point on, any\n`nixos-rebuild switch`, `nix-env -iA`, or `nix-build` commands that implicitly\nor explicitly refer to `nixpkgs` will use this newly updated version.\n\n**Reproducibility Challenge**: The update itself is not recorded in your\nconfiguration files. If you share your `configuration.nix` with someone, they\nmight run `nix-channel --update` on a different day and get a different set of\npackage versions because the channel has moved. This makes it challenging to\nguarantee that two users building the \"same\" configuration will get identical\nresults. You're effectively relying on the implicit, globally managed state of\nyour channels.\n\n#### Updating with Flakes (Modern Approach)\n\n**Flakes**, by contrast, use a more explicit and localized update mechanism tied\nto your `flake.lock` file.\n\n**How it works**: When you define a `flake.nix`, you specify the exact URL\n(e.g., a Git repository with a specific branch or tag) for each input. When you\nfirst use a flake, Nix resolves these URLs to a precise Git commit hash and\nrecords this hash, along with a content hash, in a `flake.lock` file.\n\nTo update your flake inputs, you run `nix flake update`.\n\n**Implication**: This command goes to each input's specified URL (e.g.,\n`github:NixOS/nixpkgs/nixos-unstable`) and fetches the latest commit for that\ninput. It then updates your `flake.lock` file with the new, precise Git commit\nhash and content hash for that input. Your `flake.nix` itself doesn't change,\nbut the `flake.lock` file now points to newer versions of your dependencies.\n\n**Reproducibility Advantage**: The `flake.lock` file acts as a manifest of your\nexact dependency versions.\n\n**Sharing**: When you share your flake (the `flake.nix` and `flake.lock` files),\nanyone using it will fetch precisely the same Git commit hashes recorded in the\n`flake.lock`, guaranteeing identical inputs and thus, identical builds (assuming\nthe same system architecture).\n\n**Updating Selectively**: You can update individual inputs within your flake by\nspecifying them: `nix flake update nixpkgs`. This provides fine-grained control\nover which parts of your dependency graph you want to advance.\n\n**Rolling Back**: Because the `flake.lock` explicitly records the versions, you\ncan easily revert to a previous state by checking out an older `flake.lock` from\nyour version control system.\n\n**In essence**: Channels involve a global \"pull\" of the latest branch state,\nmaking reproducibility harder to guarantee across time and machines. Flakes,\nhowever, explicitly pin all inputs in `flake.lock`, and updates involve\nexplicitly refreshing these pins, providing strong reproducibility and version\ncontrol out of the box.\n\n### Managing software with Nix\n\n**Derivation Overview**\n\nIn Nix, the process of managing software starts with **package definitions**.\nThese are files written in the Nix language that describe how a particular piece\nof software should be built. These package definitions, when processed by Nix,\nare translated into derivations.\n\nAt its core, a derivation in Nix is a blueprint or a recipe that describes how\nto build a specific software package or any other kind of file or directory.\nIt's a declarative specification of:\n\n- **Inputs**: What existing files or other derivations are needed as\n  dependencies.\n\n- **Build Steps**: The commands that need to be executed to produce the desired\n  output.\n\n- **Environment**: The specific environment (e.g., build tools, environment\n  variables) required for the build process.\n\n- **Outputs**: The resulting files or directories that the derivation produces.\n\nThink of a package definition as the initial instructions, and the derivation as\nthe detailed, low-level plan that Nix uses to actually perform the build.\n\nAgain, a derivation is like a blueprint that describes how to build a specific\nsoftware package or any other kind of file or directory.\n\n**Key Characteristics of Derivations:**\n\n- **Declarative**: You describe the desired outcome and the inputs, not the\n  exact sequence of imperative steps. Nix figures out the necessary steps based\n  on the builder and args.\n\n- **Reproducible**: Given the same inputs and build instructions, a derivation\n  will always produce the same output. This is a cornerstone of Nix's\n  reproducibility.\n\n- **Tracked by Nix**: Nix keeps track of all derivations and their outputs in\n  the Nix store. This allows for efficient management of dependencies and\n  ensures that different packages don't interfere with each other.\n\n- **Content-Addressed**: The output of a derivation is stored in the Nix store\n  under a unique path that is derived from the hash of all its inputs and build\n  instructions. This means that if anything changes in the derivation, the\n  output will have a different path.\n\nHere's a simple Nix derivation that creates a file named hello in the Nix store\ncontaining the text \"Hello, World!\":\n\n<details>\n<summary> ✔️ Hello World Derivation Example (Click to expand):</summary>\n\n```nix\n{pkgs ? import <nixpkgs> {}}:\npkgs.stdenv.mkDerivation {\n  name = \"hello-world\";\n\n  dontUnpack = true;\n\n  # No need for src = null; when dontUnpack = true;\n  # src = null;\n\n  buildPhase = ''\n     # Create a shell script that prints \"Hello, World!\"\n    echo '#!${pkgs.bash}/bin/bash' > hello-output-file # Shebang line\n    echo 'echo \"Hello, World!\"' >> hello-output-file # The command to execute\n    chmod +x hello-output-file # Make it executable\n  '';\n\n  installPhase = ''\n    mkdir -p $out/bin\n    cp hello-output-file $out/bin/hello # Copy the file from build directory to $out/bin\n  '';\n\n  meta = {\n    description = \"A simple Hello World program built with Nix\";\n    homepage = null;\n    license = pkgs.lib.licenses.unfree; # licenses.mit is often used as well\n    maintainers = [];\n  };\n}\n```\n\nAnd a `default.nix` with the following contents:\n\n```nix\n{ pkgs ? import <nixpkgs> {} }:\n\nimport ./hello.nix { pkgs = pkgs; }\n```\n\n- `{ pkgs ? import <nixpkgs> {} }`: This is a function that takes an optional\n  argument `pkgs`. We need Nixpkgs to access standard build environments like\n  `stdenv`.\n\n- `pkgs.stdenv.mkDerivation { ... }:` This calls the mkDerivation function from\n  the standard environment (stdenv). mkDerivation is the most common way to\n  define software packages in Nix.\n\n- `name = \"hello-world\";`: Human-readable name of the derivation\n\n- The rest are the build phases and package metadata.\n\nTo use the above derivation, save it as a `.nix` file (e.g. `hello.nix`). Then\nbuild the derivation using,:\n\n```bash\nnix-build\nthis derivation will be built:\n  /nix/store/9mc855ijjdy3r6rdvrbs90cg2gf2q160-hello-world.drv\nbuilding '/nix/store/9mc855ijjdy3r6rdvrbs90cg2gf2q160-hello-world.drv'...\nRunning phase: patchPhase\nRunning phase: updateAutotoolsGnuConfigScriptsPhase\nRunning phase: configurePhase\nno configure script, doing nothing\nRunning phase: buildPhase\nRunning phase: installPhase\nRunning phase: fixupPhase\nshrinking RPATHs of ELF executables and libraries in /nix/store/2ydxh5pd9a6djv7npaqi9rm6gmz2f73b-hello-world\nchecking for references to /build/ in /nix/store/2ydxh5pd9a6djv7npaqi9rm6gmz2f73b-hello-world...\npatching script interpreter paths in /nix/store/2ydxh5pd9a6djv7npaqi9rm6gmz2f73b-hello-world\nstripping (with command strip and flags -S -p) in  /nix/store/2ydxh5pd9a6djv7npaqi9rm6gmz2f73b-hello-world/bin\n/nix/store/2ydxh5pd9a6djv7npaqi9rm6gmz2f73b-hello-world\n```\n\n- Nix will execute the `buildPhase` and `installPhase`\n\n- After a successful build, the output will be in the Nix store. You can find\n  the exact path by looking at the output of the nix build command (it will be\n  something like `/nix/store/your-hash-hello-world`).\n\nRun the \"installed\" program:\n\n```bash\n./result/bin/hello\n```\n\n- This will execute the `hello` file from the Nix store and print\n  `\"Hello, World!\"`.\n\n</details>\n","number":[1,2],"sub_items":[],"path":"nix/nix_package_manager.md","source_path":"nix/nix_package_manager.md","parent_names":["Getting Started with the Nix Ecosystem"]}},{"Chapter":{"name":"Cachix and the devour-flake","content":"# Cachix and the devour-flake\n\n<details>\n<summary> Click to Expand Table of Contents</summary>\n\n<!-- toc -->\n\n</details>\n\nUsing devour-flake to Cache All Your Flake Outputs to Cachix\n\nWhen working with Nix flakes, it’s common to have many outputs—packages, apps,\ndev shells, NixOS or Darwin configurations, and more. Efficiently building and\ncaching all these outputs can be challenging, especially in CI or when\ncollaborating. This is where devour-flake and Cachix shine. Why Use\ndevour-flake?\n\nBy default, building all outputs of a flake with `nix build .#a .#b ... .#z` can\nbe slow and inefficient, as Nix will evaluate the flake multiple times—once for\neach output. devour-flake solves this by generating a \"consumer\" flake that\ndepends on all outputs, allowing you to build everything in one go with a single\nevaluation\n\n## Installation\n\nThere quite a few ways to do this, choose a method of installation from the\n[devour-flake](https://github.com/srid/devour-flake) repository and then\ncontinue with step 1.\n\nYou can even build it without installing with the following command:\n\n```bash\nnix build github:srid/devour-flake \\\n  -L --no-link --print-out-paths \\\n  --override-input flake path/to/flake | cachix push <name>\n```\n\n```bash\nnix-shell -p cachix\n```\n\nThis will push all flake outputs to cachix if you have a valid authentication\ntoken and have created a cache already.\n\nHow to Use devour-flake with Cachix\n\n1. Prerequisites\n\n- A Cachix cache: Create one on [Cachix](https://www.cachix.org/) and generate a\n  \"Write + Read\" auth token. You'll click the cache you just created and select\n  Settings, in the settings you'll find Auth Tokens. When in the Auth Tokens\n  section give your token a Description, Expiration date, and finally click\n  Generate.\n\n(Optional) Configure your token locally, copy your auth token for the following\ncommand:\n\n```bash\ncachix authtoken <YOUR_TOKEN>\n# Use cachix cli for the following\ncachix use your-cache-name\n```\n\n- `cachix use` adds your substitutors and trusted-public-keys to your\n  `~/.config/nix/nix.conf` and creates one if it doesn't exist.\n\n**Push All Flake Inputs to Cachix**\n\nReplace `<mycache>` with the name of the cache you just created.\n\n```bash\nnix flake archive --json \\\n  | jq -r '.path,(.inputs|to_entries[].value.path)' \\\n  | cachix push <mycache>\n```\n\nYou should see output similar to the following:\n\n```bash\nPushing 637 paths (2702 are already present) using zstd to cache sayls8 ⏳\n\n✓ /nix/store/0aqvmjvhkar3j2f7zag2wjl4073apnvk-vimplugin-crates.nvim-2025-05-30 (734.65 KiB)\n✓ /nix/store/02wm10zck7rb836kr0h3afjxl80866dp-X-Restart-Triggers-keyd (184.00 B)\n✓ /nix/store/0asdaaax0lf1wa6m6lqqdvc8kp6qn3f6-dconf-cleanup (1008.00 B)\n✓ /nix/store/09ki2jlh6sqbn01yw6n15h8d55ihxygf-helix-tree-sitter-mojo-3d7c53b8038f9ebbb57cd2e61296180aa5c1cf64 (601.37 KiB)\n✓ /nix/store/0i2c29nldqvb9pnypvp3ika4i7fhc0ck-devour-output (312.00 B)\n✓ /nix/store/0c0mwfb78xm862a7g4h9fhgzn55zppj6-helix-term (29.88 MiB)\n✓ /nix/store/0fhdpb2qck1kbngq1dlc8lyqqadj2pb1-hyprcursor-0.1.12+date=2025-06-05_45fcc10-lib (487.30 KiB)\n✓ /nix/store/0mfpi51bswgd91l8clqcz6mxy5k5zcd4-vimplugin-auto-pairs-2019-02-27 (40.60 KiB)\n✓ /nix/store/0k2zq8y78vrhhkf658j6i45vz3y89v11-helix-tree-sitter-tcl-56ad1fa6a34ba800e5495d1025a9b0fda338d5b8 (110.25 KiB)\n✓ /nix/store/0qxmahrw935136dbxkmvrg14fgnzi6bb-vimplugin-obsidian.nvim-2025-07-01 (493.02 KiB)\n✓ /nix/store/0wjppqzcbnlf9srhr6k27pz403j3mg2j-hm-session-vars.sh (1.86 KiB)\n✓ /nix/store/0z41071z33zg1zqyasccc3cfhxj389k0-helix-tree-sitter-swift-57c1c6d6ffa1c44b330182d41717e6fe37430704 (2.77 MiB)\n✓ /nix/store/0n5f1x8lpc93zm81bxrfh6yccyngvrdl-unit-plymouth-read-write.service (1.19 KiB)\n✓ /nix/store/0z8ac35n89lv2knzaj6kkp0cfxr6pmgc-hm_face.png (300.60 KiB)\n✓ /nix/store/0zp5846pry5rknnvzz81zlvj4ghnkxp5-hyprutils-0.8.1+date=2025-07-07_a822973 (421.64 KiB)\n✓ /nix/store/118ihgwjw6kp0528igns3pnvzbszljmg-unit-dbus.service (1.34 KiB)\n✓ /nix/store/0pajdq9mfgkcdwbqp38j7d4clc9h9iik-hm_.mozillafirefoxdefault.keep (112.00 B)\n✓ /nix/store/0nlvffvpx6s8mpd2rpnqb1bl5idd16yk-hm-dconf.ini (224.00 B)\n✓ /nix/store/1fiqgqvi574rdckav0ikdh8brwdhvh69-vimplugin-alpha-nvim-2025-05-26 (69.38 KiB)\n✓ /nix/store/1fqxw31p1llag0g7wg7izq22x5msz47r-vimplugin-persistence.nvim-2025-02-25 (37.74\n```\n\n> ❗ NOTE: The effectiveness of pushing the rest to cachix depend on your\n> network speed. I actually noticed a slow down after pushing the `nix/store`.\n> Pushing the `nix/store` is rarely necessary and can be very slow and\n> bandwidth-intensive. Most users will only need to push relevent outputs.\n\n**Push the Entire /nix/store**\n\n```bash\nnix path-info --all | cachix push <mycache>\n```\n\n**Pushing shell environment**\n\n```bash\nnix develop --profile dev-profile -c true\n# then run\ncachix push <mycache> dev-profile\n```\n\n- For the Flake way of doing things you would create something like the\n  following:\n\n```nix\n{\n  config,\n  lib,\n  pkgs,\n  ...\n}: let\n  cfg = config.custom.cachix;\nin {\n  options = {\n    custom.cachix.enable = lib.mkEnableOption \"Enable custom cachix configuration\";\n  };\n\n  config = lib.mkIf cfg.enable {\n    environment.systemPackages = with pkgs; [cachix];\n\n    # to prevent garbage collection of outputs immediately after building\n    nix.extraOptions = \"gc-keep-outputs = true\";\n    nix.settings = {\n      substituters = [\n        \"https://nix-community.cachix.org\"\n        \"https://hyprland.cachix.org\"\n        \"https://ghostty.cachix.org\"\n        \"https://neovim-nightly.cachix.org\"\n        \"https://yazi.cachix.org\"\n        \"https://helix.cachix.org\"\n        \"https://nushell-nightly.cachix.org\"\n        \"https://wezterm.cachix.org\"\n        \"https://sayls88.cachix.org\"\n        # \"https://nixpkgs-wayland.cachix.org\"\n      ];\n      trusted-public-keys = [\n        \"nix-community.cachix.org-1:mB9FSh9qf2dCimDSUo8Zy7bkq5CX+/rkCWyvRCYg3Fs=\"\n        \"hyprland.cachix.org-1:a7pgxzMz7+chwVL3/pzj6jIBMioiJM7ypFP8PwtkuGc=\"\n        \"ghostty.cachix.org-1:QB389yTa6gTyneehvqG58y0WnHjQOqgnA+wBnpWWxns=\"\n        \"neovim-nightly.cachix.org-1:feIoInHRevVEplgdZvQDjhp11kYASYCE2NGY9hNrwxY=\"\n        \"yazi.cachix.org-1:Dcdz63NZKfvUCbDGngQDAZq6kOroIrFoyO064uvLh8k=\"\n        \"helix.cachix.org-1:ejp9KQpR1FBI2onstMQ34yogDm4OgU2ru6lIwPvuCVs=\"\n        \"nushell-nightly.cachix.org-1:nLwXJzwwVmQ+fLKD6aH6rWDoTC73ry1ahMX9lU87nrc=\"\n        \"wezterm.cachix.org-1:kAbhjYUC9qvblTE+s7S+kl5XM1zVa4skO+E/1IDWdH0=\"\n        \"sayls88.cachix.org-1:LT8JnboX8mKhabC3Mj/ONHb5tyrjlnsdauQkD8Lu0us=\"\n        # \"nixpkgs-wayland.cachix.org-1:3lwxaILxMRkVhehr5StQprHdEo4IrE8sRho9R9HOLYA=\"\n      ];\n    };\n  };\n}\n```\n\n- The sayls88 entries are my custom cache. To find your trusted key go to the\n  cachix website, click on your cache and it is listed near the top.\n\n- I enable this with `custom.cachix.enable = true;` in my `configuration.nix` or\n  equivalent.\n\n- Another option is to use the top-level `nixConfig` attribute for adding your\n  substitutors and trusted-public-keys. You only need to choose 1 method FYI:\n\n```nix\n{\n  description = \"NixOS & Flake Config\";\n\n# the nixConfig here only affects the flake itself, not the system configuration!\n  nixConfig = {\n    experimental-features = [ \"nix-command\" \"flakes\" ];\n    trusted-users = [ \"ryan\" ];\n\n    substituters = [\n      # replace official cache with a mirror located in China\n      \"https://mirrors.ustc.edu.cn/nix-channels/store\"\n      \"https://cache.nixos.org\"\n    ];\n\n    # nix community's cache server\n    extra-substituters = [\n      \"https://nix-community.cachix.org\"\n      \"https://nixpkgs-wayland.cachix.org\"\n    ];\n    extra-trusted-public-keys = [\n      \"cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY=\"\n      \"nix-community.cachix.org-1:mB9FSh9qf2dCimDSUo8Zy7bkq5CX+/rkCWyvRCYg3Fs=\"\n      \"nixpkgs-wayland.cachix.org-1:3lwxaILxMRkVhehr5StQprHdEo4IrE8sRho9R9HOLYA=\"\n    ];\n  };\n# ... snip\n```\n\n2. Building and Caching All Outputs\n\nYou can build and push all outputs of your flake to Cachix using the following\ncommand when in your flake directory:\n\n```bash\nnix build github:srid/devour-flake \\\n -L --no-link --print-out-paths \\\n --override-input flake . \\\n | cachix push <your-cache-name>\n```\n\n- Replace `your-cache-name` with your actual Cachix cache name.\n\n  This command will:\n\n- Use devour-flake to enumerate and build all outputs of your flake (including\n  packages, devShells, NixOS configs, etc.)\n\n- Pipe the resulting store paths to cachix push, uploading them to your binary\n  cache.\n\n3. Example\n\nSuppose your cache is named my-flake-cache:\n\n```bash\nnix build github:srid/devour-flake \\\n -L --no-link --print-out-paths \\\n --override-input flake . \\\n | cachix push my-flake-cache\n```\n\n4. Integration in CI\n\nThis approach is particularly useful in CI pipelines, where you want to ensure\nall outputs are built and cached for collaborators and future builds. You can\nadd the above command to your CI workflow, ensuring the Cachix auth token is\nprovided as a secret\n\n5. Advanced: Using as a Nix App\n\nYou can add devour-flake as an input to your flake for local development:\n\n```nix\n{\n  inputs = {\n    devour-flake.url = \"github:srid/devour-flake\";\n    devour-flake.flake = false;\n  };\n}\n```\n\nAnd in your flake's `outputs`, add an overlay that makes `devour-flake`\navailable in your package set:\n\n```nix\noutputs = { self, nixpkgs, devour-flake, ... }@inputs: {\n  overlays.default = final: prev: {\n    devour-flake = import devour-flake { inherit (prev) pkgs; };\n  };\n\n  # Example: Add devour-flake to your devShell\n  devShells.x86_64-linux.default = let\n    pkgs = import nixpkgs {\n      system = \"x86_64-linux\";\n      overlays = [ self.overlays.default ];\n    };\n  in pkgs.mkShell {\n    buildInputs = [ pkgs.devour-flake ];\n  };\n};\n```\n\nUse devour-flake in your devShell:\n\n```bash\nnix develop\n```\n\nYou'll have the `devour-flake` command available for local use, so you can\nquickly build and push all outputs as needed.\n\n> TIP: Alternatively, use `devour-flake` as an app:\n>\n> ```nix\n> apps.x86_64-linux.devour-flake = {\n>  type = \"app\";\n>  program = \"${self.packages.x86_64-linux.devour-flake}/bin/devour-flake\";\n> };\n>\n> ```\n\nWhat Gets Built and Cached?\n\n`devour-flake` detects and builds all standard outputs of a flake, including:\n\n- packages\n\n- apps\n\n- checks\n\n- devShells\n\n- nixosConfigurations.\\*\n\n- darwinConfigurations.\\*\n\n- home-manager configurations\n\nThis ensures that everything your flake produces is available in your Cachix\ncache for fast, reproducible builds.\n\nReferences:\n\n[devour-flake documentation](https://github.com/srid/devour-flake)\n\n[Discourse Cachix for Flakes](https://discourse.nixos.org/t/how-to-set-up-cachix-in-flake-based-nixos-config/31781)\n\n[Cachix docs: Flakes](https://docs.cachix.org/installation#flakes)\n\n[Tweag Evaluation Caching](https://www.tweag.io/blog/2020-06-25-eval-cache/#:~:text=The%20overhead%20for%20creating%20the,nixpkgs%20blender%20takes%204.9%20seconds.)\n\n[Scrive Caching](https://scrive.github.io/nix-workshop/06-infrastructure/01-caching-nix.html)\n","number":[1,3],"sub_items":[{"Chapter":{"name":"Nix Paths","content":"# Nix Paths\n\n<details>\n<summary> ✔️ Click to Expand Table of Contents</summary>\n\n<!-- toc -->\n\n</details>\n\nThe following examples are done with a local `nixpkgs` clone located at\n`~/src/nixpkgs`\n\nPaths in Nix always need a `/` in them and always expand to absolute paths\nrelative to your current directory.\n\n```bash\nnix repl\nnix-repl> ./.\n/home/jr/src/nixpkgs\nnix-repl> ./. + \"/lib\"\n/home/jr/src/nixpkgs/lib\n```\n\nNix does _path normalization_ every time you append strings, so if you just add\na slash `/` its not actually there:\n\n```bash\nnix-repl> ./.\n/home/jr/src/nixpkgs\nnix-repl> ./. + \"/\"\n/home/jr/src/nixpkgs\nnix-repl> ./. + \"/\" + \"lib\"\n/home/jr/src/nixpkgslib\nnix-repl> \"${./.}/lib\"\n# using ${./.} causes a store copy\ncopying '/homr/jr/src/nixpkgs' to the store\n\"/nix/store/3z9fzx8z03wslxvri5syv3jnnhn5fkbd-nixpkgs/lib\"\nnix-repl> \"${toString ./.}/lib\"\n# using toString avoids making a store copy\n\"/home/jr/src/nixpkgs/lib\"\nnix-repl> ./lib/..             # nix removes all `..` to avoid redundant path resolutions\n/home/jr/src/nixpkgs\nnix-repl> :q\n```\n\n```bash\nrealpath ./lib/..\n/home/jr/src/nixpkgs\nln -s pkgs/applications lib-symlink\nrealpath ./lib-symlink/..\n/home/jr/src/nixpkgs/pkgs\nnix repl\nnix-repl> ./lib-symlink/..   # Nix doesn't read this file at all like realpath did\n/home/jr/src/nixpkgs\nnix-repl> builtins.readDir ./. # listing of all entries in current dir and their types\n{\n  \".devcontainer\" = \"directory\";\n  \".editorconfig\" = \"regular\";\n  \".git\" = \"directory\";\n  \".git-blame-ignore-revs\" = \"regular\";\n  \".gitattributes\" = \"regular\";\n  \".github\" = \"directory\";\n  \".gitignore\" = \"regular\";\n  \".mailmap\" = \"regular\";\n  \".mergify.yml\" = \"regular\";\n  \".version\" = \"symlink\";\n  \"CONTRIBUTING.md\" = \"regular\";\n  COPYING = \"regular\";\n  \"README.md\" = \"regular\";\n  ci = \"directory\";\n  \"default.nix\" = \"regular\";\n  doc = \"directory\";\n  \"flake.nix\" = \"regular\";\n  lib = \"directory\";\n  maintainers = \"directory\";\n  nixos = \"directory\";\n  pkgs = \"directory\";\n  \"shell.nix\" = \"regular\";\n}\nnix-repl> builtins.readFile ./default.nix\n\"let\\n  requiredVersion = import ./lib/minver.nix;\\nin\\n\\nif !builtins ? nixVersion\n || builtins.compareVersions requiredVersion builtins.nixVersion == 1 then\\n\\n  abort\n ''\\n\\n    This version of Nixpkgs requires Nix >= \\${requiredVersion}, please\n upgrade:\\n\\n    - If you are running NixOS, `nixos-rebuild' can be used to upgrade\n your system.\\n\\n    - Alternatively, with Nix > 2.0 `nix upgrade-nix' can be used\n to imperatively\\n      upgrade Nix. You may use `nix-env --version' to check which\n version you have.\\n\\n    - If you installed Nix using the install script (https://nixos.org/nix/install),\\n\n  it is safe to upgrade by running it again:\\n\\n          curl -L https://nixos.org/nix/install | sh\\n\\n\nFor more information, please see the NixOS release notes at\\n    https://nixos.org/nixos/manual\n or locally at\\n    \\${toString ./nixos/doc/manual/release-notes}.\\n\\n    If you need further help,\n see https://nixos.org/nixos/support.html\\n  ''\\n\\nelse\\n\\n  import ./pkgs/top-level/impure.nix\\n\"\nnix-repl> :l <nixpkgs/lib>\nnix-repl> importJSON ./pkgs/development/python-modules/notebook/missing-hashes.json # Return the nix value for JSON\n{\n  \"@nx/nx-darwin-arm64@npm:16.10.0\" = \"aabcc8499602b98c9fc3b768fe46dfd4e1b818caa84b740bd4f73a2e4528c719b979ecb1c10a0d793a1fead83073a08bc86417588046aa3e587e80af880bffd3\";\n  \"@nx/nx-darwin-x64@npm:16.10.0\" = \"9dd20f45f646d05306f23f5abb7ade69dcb962e23a013101e93365847722079656d30a19c735fdcfa5c4e0fdf08691f9d621073c58aef2861c26741ff4638375\";\n  \"@nx/nx-freebsd-x64@npm:16.10.0\" = \"35b93aabe3b3274d53157a6fc10fec7e341e75e6818e96cfbc89c3d5b955d225ca80a173630b6aa43c448c6b53b23f06a2699a25c0c8bc71396ee20a023d035f\";\n  \"@nx/nx-linux-arm-gnueabihf@npm:16.10.0\" = \"697b9fa4c70f84d3ea8fe32d47635864f2e40b0ceeb1484126598c61851a2ec34b56bb3eeb9654c37d9b14e81ce85a36ac38946b4b90ca403c57fe448be51ccb\";\n  \"@nx/nx-linux-arm64-gnu@npm:16.10.0\" = \"001e71fedfc763a4dedd6c5901b66a4a790d388673fb74675235e19bb8fe031ff3755568ed867513dd003f873901fabda31a7d5628b39095535cb9f6d1dc7191\";\n  \"@nx/nx-linux-arm64-musl@npm:16.10.0\" = \"58e3b71571bdadd2b0ddd24ea6e30cd795e706ada69f685403412c518fba1a2011ac8c2ac46145eab14649aa5a78e0cedcdb4d327ccb3b6ec12e055171f3840b\";\n  \"@nx/nx-linux-x64-gnu@npm:16.10.0\" = \"97729a7efb27301a67ebf34739784114528ddb54047e63ca110a985eaa0763c5b1ea7c623ead1a2266d07107951be81e82ffa0a30e6e4d97506659303f2c8c78\";\n  \"@nx/nx-linux-x64-musl@npm:16.10.0\" = \"442bdbd5e61324a850e4e7bd6f54204108580299d3c7c4ebcec324da9a63e23f48d797a87593400fc32af78a3a03a3c104bfb360f107fe732e6a6c289863853a\";\n  \"@nx/nx-win32-arm64-msvc@npm:16.10.0\" = \"b5c74184ebfc70294e85f8e309f81c3d40b5cf99068891e613f3bef5ddb946bef7c9942d9e6c7688e22006d45d786342359af3b4fc87aadf369afcda55c73187\";\n  \"@nx/nx-win32-x64-msvc@npm:16.10.0\" = \"c5b174ebd7a5916246088e17d3761804b88f010b6b3f930034fa49af00da33b6d1352728c733024f736e4c2287def75bafdc3d60d8738bd24b67e9a4f11763f8\";\n}\nnix-repl> builtins.toJSON  # serialize\n«primop toJSON»\nnix-repl> builtins.fromTOML\n«primop fromTOML»\nnix-repl> builtins.toXML\n```\n\nFor more serialization formats see `nixpkgs/lib/generators.nix` as well as in\n`nixpkgs/pkgs/pkgs-lib/formats/` we can see them with the `nix repl` as follows:\n\n```bash\ncd ~/src/nixpkgs\nnix repl\nnix-repl> :l .\nnix-repl> lib.generators.toYAML {} { a = 10; }\n\"{\\\"a\\\":10}\"\nnix-repl> lib.generators.toYAML {} { a.b.c = 10; }\n\"{\\\"a\\\":{\\\"b\\\":{\\\"c\\\":10}}}\"\nnix-repl> builtins.trace (lib.generators.toYAML {} { a.b.c = 10; }) null\ntrace: {\"a\":{\"b\":{\"c\":10}}}\nnull\nnix-repl> yamlFormat = pkgs.formats.yaml {}\n\nnix-repl> yamlFormat\n{\n  generate = «lambda generate @ /home/jr/src/nixpkgs/pkgs/pkgs-lib/formats.nix:111:9»;\n  type = { ... };\n}\n```\n\n- We can see that it provides a `generate` function that we can use. `generate`\n  doesn't just generate a string anymore because if we want to lift the\n  restriction at evaluation time we can't return the formatted form at\n  evaluation time anymore. We need a name to return a derivation continued\n  below:\n\n```bash\nyamlFormat.generate \"name\" { a.b.c = 10; }\n«derivation /nix/store/xakajb2rzbmqqkjbh08bxwqdf0xqvjly-name.drv»\nnix-repl> :b yamlFormat.generate \"name\" { a.b.c = 10; }\nThis derivation produced the following outputs:\nout -> /nix/store/y4c5029k6w3l0qmdw7cq396zrdy5x8yj-name\nnix-repl> :q\n```\n\nLet's cat the result to see if it's formatted correctly as YAML:\n\n```bash\ncat /nix/store/y4c5029k6w3l0qmdw7cq396zrdy5x8yj-name\n───────┬───────────────────────────────────────────────────────────────\n       │ File: /nix/store/y4c5029k6w3l0qmdw7cq396zrdy5x8yj-name\n───────┼──────────────────────────────────────────────────────────────\n   1   │ a:\n   2   │   b:\n   3   │     c: 10\n───────┴───────────────────────────────────────────────────────────\n```\n\nLooks good. There is also a `type`:\n\n```bash\nnix repl\nnix-repl> :l .\nnix-repl> yamlFormat = pkgs.format.yaml {}\nnix-repl> yamlFormat.type\n{\n  _type = \"option-type\";\n  check = «lambda check @ /home/jr/src/nixpkgs/lib/types.nix:1029:19»;\n  deprecationMessage = null;\n  description = \"YAML value\";\n  descriptionClass = \"conjunction\";\n  emptyValue = { ... };\n  functor = { ... };\n  getSubModules = null;\n  getSubOptions = «lambda @ /home/jr/src/nixpkgs/lib/types.nix:214:25»;\n  merge = «lambda merge @ /home/jr/src/nixpkgs/lib/types.nix:1031:13»;\n  name = \"nullOr\";\n  nestedTypes = { ... };\n  substSubModules = «lambda substSubModules @ /home/jr/src/nixpkgs/lib/types.nix:1046:29»;\n  typeMerge = «lambda defaultTypeMerge @ /home/jr/src/nixpkgs/lib/types.nix:115:10»;\n}\nnix-repl> lib.modules.mergeDefinitions [] yamlFormat.type [ { value = null; } ]\n{\n  defsFinal = [ ... ];\n  defsFinal' = { ... };\n  isDefined = true;\n  mergedValue = null;\n  optionalValue = { ... };\n}\nnix-repl> (lib.modules.mergeDefinitions [] yamlFormat.type [ { value = null; } ]).mergedValue\nnull\nnix-repl> :p (lib.modules.mergeDefinitions [] yamlFormat.type [ { value = { a.b.c = 10; }; } ]).mergedValue\n{\n  a = {\n    b = { c = 10; };\n  };\n}\nnix-repl> :p (lib.modules.mergeDefinitions [] yamlFormat.type [ { value = { a.b.c = 10; }; } { value = { a.b.d = 20; }; } ]).mergedValue\n{\n  a = {\n    b = {\n      c = 10;\n      d = 20;\n    };\n  };\n}\n```\n\n- `lib` can't access any packages, it is entirely at evaluation time. It can't\n  access any formatters or things like that. If we lift that restriction as is\n  done in `pkgs.formats` we can make it look much nicer.\n\n```bash\ncd ~/src/nixpkgs\nnix-build -A hello\nwarning: Nix search path entry '/nix/var/nix/profiles/per-user/root/channels' does not exist, ignoring\nthis path will be fetched (0.06 MiB download, 0.26 MiB unpacked):\n  /nix/store/29mhfr5g4dsv07d80b7n4bgs45syk3wl-hello-2.12.2\ncopying path '/nix/store/29mhfr5g4dsv07d80b7n4bgs45syk3wl-hello-2.12.2' from 'https://cache.nixos.org'...\n/nix/store/29mhfr5g4dsv07d80b7n4bgs45syk3wl-hello-2.12.2\n```\n\nSay we rely on this store path in a derivation:\n\n```bash\nnix-repl> thePath = \"/nix/store/29mhfr5g4dsv07d80b7n4bgs45syk3wl-hello-2.12.2\"\nnix-repl> thePath + \"/bin/hello\"\n\"/nix/store/29mhfr5g4dsv07d80b7n4bgs45syk3wl-hello-2.12.2/bin/hello\"\n```\n\n```bash\nhx ~/src/nixpkgs/test2.nix\n```\n\n```nix\n# test2.nix\nwith import ./. {};\n\nrunCommand \"test\" {\n    nativeBuildInputs = [\n        hello\n    ];\n}''\n  hello > $out\n''\n```\n\nTry building it:\n\n```bash\nnix-build test2.nix && cat result\nwarning: Nix search path entry '/nix/var/nix/profiles/per-user/root/channels' does not exist, ignoring\n/nix/store/m55p4vpb8s7s28s20vs89i467kxbrdac-test\nHello, world!\n```\n\nNow if we try it with the store path:\n\n```nix\n# test2.nix\nwith import ./. {};\n\nrunCommand \"test\" {\n}''\n  /nix/store/29mhfr5g4dsv07d80b7n4bgs45syk3wl-hello-2.12.2/bin/hello > $out\n''\n```\n\nThis doesn't work\n\n```bash\nnix-build test2.nix\nlast 1 log lines:\n> /build/.attr-0l2nkwhif96f51f4amnlf414lhl4rv9vh8iffyp431v6s28gsr90: line 1: /nix/store/29mhfr5g4dsv07d80b7n4bgs45syk3wl-hello-2.12.2/bin/hello: No such file or directory\nFor full logs, run:\nnix log /nix/store/58zcp9xwgf1sirmzf9sh61j8gz9lkw34-test.drv\nnix-instantiate test2.nix\n/nix/store/58zcp9xwgf1sirmzf9sh61j8gz9lkw34-test.drv\nnix derivation show /nix/store/58zcp9xwgf1sirmzf9sh61j8gz9lkw34-test.drv | jq\n{\n  \"/nix/store/58zcp9xwgf1sirmzf9sh61j8gz9lkw34-test.drv\": {\n    \"args\": [\n      \"-e\",\n      \"/nix/store/vj1c3wf9c11a0qs6p3ymfvrnsdgsdcbq-source-stdenv.sh\",\n      \"/nix/store/shkw4qm9qcw5sc5n1k5jznc83ny02r39-default-builder.sh\"\n    ],\n    \"builder\": \"/nix/store/xy4jjgw87sbgwylm5kn047d9gkbhsr9x-bash-5.2p37/bin/bash\",\n    \"env\": {\n      \"__structuredAttrs\": \"\",\n      \"buildCommand\": \"/nix/store/29mhfr5g4dsv07d80b7n4bgs45syk3wl-hello-2.12.2/bin/hello > $out\\n\",\n      \"buildInputs\": \"\",\n      \"builder\": \"/nix/store/xy4jjgw87sbgwylm5kn047d9gkbhsr9x-bash-5.2p37/bin/bash\",\n      \"cmakeFlags\": \"\",\n      \"configureFlags\": \"\",\n      \"depsBuildBuild\": \"\",\n      \"depsBuildBuildPropagated\": \"\",\n      \"depsBuildTarget\": \"\",\n      \"depsBuildTargetPropagated\": \"\",\n      \"depsHostHost\": \"\",\n      \"depsHostHostPropagated\": \"\",\n      \"depsTargetTarget\": \"\",\n      \"depsTargetTargetPropagated\": \"\",\n      \"doCheck\": \"\",\n      \"doInstallCheck\": \"\",\n      \"enableParallelBuilding\": \"1\",\n      \"enableParallelChecking\": \"1\",\n      \"enableParallelInstalling\": \"1\",\n      \"mesonFlags\": \"\",\n      \"name\": \"test\",\n      \"nativeBuildInputs\": \"\",\n      \"out\": \"/nix/store/ljrkx5midby3j7p4g96d74jrq8f9rpya-test\",\n      \"outputs\": \"out\",\n      \"passAsFile\": \"buildCommand\",\n      \"patches\": \"\",\n      \"propagatedBuildInputs\": \"\",\n      \"propagatedNativeBuildInputs\": \"\",\n      \"stdenv\": \"/nix/store/aq801xbgs98nxx3lckrym06qfvl8mfsf-stdenv-linux\",\n      \"strictDeps\": \"\",\n      \"system\": \"x86_64-linux\"\n    },\n    \"inputDrvs\": {\n      \"/nix/store/bmncp7arkdhrl6nkyg0g420935x792gl-stdenv-linux.drv\": {\n        \"dynamicOutputs\": {},\n        \"outputs\": [\n          \"out\"\n        ]\n      },\n      \"/nix/store/rfkzz952hz2d58d90mscxvk87v5wa5bz-bash-5.2p37.drv\": {\n        \"dynamicOutputs\": {},\n        \"outputs\": [\n          \"out\"\n        ]\n      }\n    },\n    \"inputSrcs\": [\n      \"/nix/store/shkw4qm9qcw5sc5n1k5jznc83ny02r39-default-builder.sh\",\n      \"/nix/store/vj1c3wf9c11a0qs6p3ymfvrnsdgsdcbq-source-stdenv.sh\"\n    ],\n    \"name\": \"test\",\n    \"outputs\": {\n      \"out\": {\n        \"path\": \"/nix/store/ljrkx5midby3j7p4g96d74jrq8f9rpya-test\"\n      }\n    },\n    \"system\": \"x86_64-linux\"\n  }\n}\n```\n\nYou see the `\"inputDrvs\"`, they are the derivations that we depend on and it\ndoesn't know about the `hello.drv`. In Nix for the builder sandbox it creates a\nsandbox that only contains the derivations that you depend on which ensures that\nyou can't depend on any derivation that you haven't explicitly decalred.\n\nNix does have `builtins.storePath` that allows you to do this, otherwise it's\nkind of an anti pattern.\n\n```nix\n# test2.nix\n# test2.nix\n# test2.nix\nwith import ./. {};\n  runCommand \"test\" {\n  } ''\n    ${builtins.storePath \"/nix/store/29mhfr5g4dsv07d80b7n4bgs45syk3wl-hello-2.12.2\"}/bin/hello > $out\n  ''\n```\n\n`builtins.storePath`: Turns a store path into the thing that it represents in\nthe store.\n\n```bash\nnix-build test2.nix && cat result\n/nix/store/x48741w0k9hgqywzv6wc7rk90r1y75js-test\nHello, world!\n```\n\nTo demonstrate what `builtins.storePath` does:\n\n```bash\nnix-repl> builtins.storePath \"/nix/store/29mhfr5g4dsv07d80b7n4bgs45syk3wl-hello-2.12.2/bin/hello\"\n\"/nix/store/29mhfr5g4dsv07d80b7n4bgs45syk3wl-hello-2.12.2/bin/hello\"\nnix-repl> builtins.getContext \"/nix/store/29mhfr5g4dsv07d80b7n4bgs45syk3wl-hello-2.12.2\"\n{ }\nnix-repl> builtins.getContext (builtins.storePath \"/nix/store/29mhfr5g4dsv07d80b7n4bgs45syk3wl-hello-2.12.2\")\n{\n  \"/nix/store/29mhfr5g4dsv07d80b7n4bgs45syk3wl-hello-2.12.2\" = { ... };\n}\nnix-repl> :p builtins.getContext (builtins.storePath \"/nix/store/29mhfr5g4dsv07d80b7n4bgs45syk3wl-hello-2.12.2\")\n{\n  \"/nix/store/29mhfr5g4dsv07d80b7n4bgs45syk3wl-hello-2.12.2\" = { path = true; };\n}\n```\n\n```bash\nnix-repl> :l .\nwarning: Nix search path entry '/nix/var/nix/profiles/per-user/root/channels' does not exist, ignoring\nAdded 24878 variables.\n\nnix-repl> hello.outPath\n# this is the output path of the hello derivation\n\"/nix/store/29mhfr5g4dsv07d80b7n4bgs45syk3wl-hello-2.12.2\"\nnix-repl> :p builtins.getContext hello.outPath\n# we see that this is a `.drv`, this is because derivations can have multiple outputs\n{\n  \"/nix/store/ljxsxdy1syy03b9kfnnh8x7zsk21fdcq-hello-2.12.2.drv\" = {\n    outputs = [ \"out\" ];\n  };\n}\n# for example\nnix-repl> openssl.outputs\n[\n  \"bin\"\n  \"dev\"\n  \"out\"\n  \"man\"\n  \"doc\"\n  \"debug\"\n]\nnix-repl> openssl.all\n# a list of all the derivations\n[\n  «derivation /nix/store/rw3y8k94ib37dc86n0wivr551wyzxgsk-openssl-3.4.1.drv»\n  «derivation /nix/store/rw3y8k94ib37dc86n0wivr551wyzxgsk-openssl-3.4.1.drv»\n  «derivation /nix/store/rw3y8k94ib37dc86n0wivr551wyzxgsk-openssl-3.4.1.drv»\n  «derivation /nix/store/rw3y8k94ib37dc86n0wivr551wyzxgsk-openssl-3.4.1.drv»\n  «derivation /nix/store/rw3y8k94ib37dc86n0wivr551wyzxgsk-openssl-3.4.1.drv»\n  «derivation /nix/store/rw3y8k94ib37dc86n0wivr551wyzxgsk-openssl-3.4.1.drv»\n]\nnix-repl> lib.concatStringsSep \" \" openssl.all\n\"/nix/store/rjzx8v679rwd6dsb6s08iy3j2rrax72s-openssl-3.4.1-bin /nix/store/kcgqglb4iax0zh5jlrxmjdik93wlgsrq-openssl-3.4.1-dev /nix/store/8pviily4fgsl02ijm65binz236717wfs-openssl-3.4.1 /nix/store/1l5b31cnswnbcdcac9rzs9xixnc2n9r5-openssl-3.4.1-man /nix/store/9fz5qmj0z70cbzy7mapml0sbi8z6ap0a-openssl-3.4.1-doc /nix/store/yk2g2gfcj2fy1ffyi1g91q7jmp4h8pxa-openssl-3.4.1-debug\"\nnix-repl> :p builtins.getContext (builtins.unsafeDiscardOutputDependency (lib.concatStringsSep \" \" openssl.all))\n{\n  \"/nix/store/rw3y8k94ib37dc86n0wivr551wyzxgsk-openssl-3.4.1.drv\" = {\n    outputs = [\n      \"bin\"\n      \"debug\"\n      \"dev\"\n      \"doc\"\n      \"man\"\n      \"out\"\n    ];\n  };\n}\nnix-repl> :p builtins.getContext openssl.drvPath\n{\n  \"/nix/store/rw3y8k94ib37dc86n0wivr551wyzxgsk-openssl-3.4.1.drv\" = { allOutputs = true; };\n}\n# useful if you need to create a derivation that copies this derivation to another machine\n# remote builders usually take care of this but you may need it occasionally\nnix-repl> :p builtins.getContext (builtins.unsafeDiscardOutputDependency openssl.drvPath)\n{\n  \"/nix/store/rw3y8k94ib37dc86n0wivr551wyzxgsk-openssl-3.4.1.drv\" = { path = true; };\n}\n```\n\nRelying on paths outside of the nix store is generally not recommended because\nof garbage collection and it's considered unsafe.\n","number":[1,3,1],"sub_items":[],"path":"nix/nixLang/nix_paths.md","source_path":"nix/nixLang/nix_paths.md","parent_names":["Getting Started with the Nix Ecosystem","Cachix and the devour-flake"]}},{"Chapter":{"name":"Hardening README","content":"# Hardening README\n\n<details>\n<summary> ✔️ Click to Expand Table of Contents</summary>\n\n<!-- toc -->\n\n</details>\n\n📌 **How to Use This Guide**\n\n**Read warnings**: Advanced hardening can break compatibility or cause data\nloss! Pause and research before enabling anything not listed above unless you\nunderstand the consequences.\n\nThe guide is broken up into 2 chapters:\n\n- [Hardening NixOS](https://saylesss88.github.io/nix/hardening_NixOS.html)\n\n- [Hardening Networking](https://saylesss88.github.io/nix/hardening_networking.html)\n\n## Getting Started\n\nThere is a lot covered in this guide which can get overwhelming when trying to\ndecide what is worth implementing. Here, I will list some common recommendations\nthat most users should follow to harden their stance.\n\n> \"The major problem with current systems is their inability to provide\n> effective isolation between various programs running on one machine. E.g. if\n> the user's Web browser gets compromised (due to a bug exploited by a malicious\n> web site), the OS is usually unable to protect other user's applications and\n> data from also being compromised.\"--Qubes arch-spec\n\n## Threat Modeling\n\nYou should always start by conducting a personal threat assesment to identify\npotential threats and vulnerabilities that you need to develop strategies to\ndefend against.\n\nThreat modeling in computing involves evaluating the security risks to your\ncomputer or network. It helps uncover possible threats and weaknesses so you can\ncreate plans to safeguard your systems and data effectively. By examining\nvarious attack scenarios, you can anticipate potential cyber threats and better\nprotect your digital resources.\n\nIt's not possible to protect yourself against every attack(er), focus on the\nmost probable threats to your specific situation.\n\n- [EFF Security Starter Pack](https://ssd.eff.org/playlist/want-security-starter-pack)\n\n- [EFF Your Security Plan](https://ssd.eff.org/module/your-security-plan)\n\n- [Kicksecure Computer Security Threat Modeling](https://www.kicksecure.com/wiki/Threat_Modeling)\n\n### Baseline Hardening\n\nBefore diving into advanced or specialized hardening, apply these baseline\nsecurity measures suitable for all NixOS users. These settings help protect your\nsystem with minimal risk of breaking workflows or causing admin headaches.\n\nThere is something to be said about the window manager you use. GNOME, KDE\nPlasma, and Sway secure privileged Wayland protocols like screencopy. This means\nthat on environments outside of GNOME, KDE, and Sway, applications can access\nscreen content of the entire desktop. This implicitly includes the content of\nother applications. It's primarily for this reason that Silverblue, Kinoite, and\nSericea images are recommended. COSMIC has plans to fix this.\n--[secureblue Images](https://secureblue.dev/images)\n\nSecureblue recommends disabling Xwayland and finding alternatives for those apps\nas well as disabling `xdg-desktop-portal-wlr`, this is because the wlroots\ndesktop portal reintroduces the screencopy vulnerability.\n\n- Use Disk Encryption (LUKS) to protect your data at rest.\n\n- Keep your system up to date (update regularly).\n\n- Use strong, unique passwords. To generate one from the command-line, there is\n  `pkgs.diceware`. Generate a password with: `diceware -n 12 -w en_eff`, add\n  spaces between the words for higher entropy.\n  - [Kicksecure Password_Generation](https://www.kicksecure.com/wiki/Passwords#Password_Generation)\n\n- Avoid reusing passwords, use a password manager.\n\n- Avoid storing files directly in the root home folder (i.e., `/home/user`),\n  create sub-folders instead.(i.e., Instead of creating `~/notes.txt`, create\n  `~/my-notes/notes.txt` or `~/Documents/notes.txt`).\n  - If you are able to implement a Mandatory Access Control framework, there are\n    more sub-folders that should be avoided such as `~/Downloads`. Another\n    reason to use non-default sub-dirs is to avoid typos deleting important\n    files.\n\n  - Home-Manager has an option `xdg.userDirs.enable`\n\n```nix\n# home.nix or equivalent\n{\n  xdg.userDirs.enable = true;\n  xdg.userDirs.createDirectories = true;\n  # Optionally create non-default sub-dirs\n  # xdg.userDirs.documents = \"/home/jr/my-documents\";\n  # xdg.userDirs.download = \"/home/jr/my-downloads\";\n}\n```\n\n- The XDG Base Directory Specification defines a consistent way for apps and\n  desktops to store and find files. It helps prevent \"dotfile clutter\" by\n  directing application files into clear, organized locations.\n\n- Only enable what you use, and actively disable what's no longer in use.\n\n- Enable at least a basic firewall, a more complex firewall example that\n  utilizes nftables is shared in the\n  [Hardening Networking Chapter](https://saylesss88.github.io/nix/hardening_networking.html)\n\nAlthough the firewall is enabled by default on NixOS, let's be explicit about\nit, add the following to your `configuration.nix` or equivalent:\n\n```nix\n# configuration.nix\n# this denies incoming connections but allows outgoing and established connections\nnetworking.firewall.enable = true;\n```\n\nMany services provide an option to open the required firewall ports\nautomatically. For example:\n\n```nix\nservices.tor.openFirewall = true;\n```\n\nThis prevents you from having to manually open ports\n\n**Audit and remove local user accounts that are no longer needed**: Regularly\nreview and remove unused or outdated accounts to reduce your system’s attack\nsurface, improve compliance, and ensure only authorized users have access. The\nfollowing setting ensures that user (and group) management is fully declarative:\n\n```nix\n# configuration.nix\n# All users must be declared\nusers.mutableUsers = false;\n```\n\nWith `users.mutableUsers = false;`, all non-declaratively managed (imperative)\nuser management including creation, modification, or password changes will fail\nor be reset on rebuild. User and group definitions become entirely controlled by\nyour system configuration for maximum reproducibility and security. If you need\nto add, remove, or modify users, you must do so in your `configuration.nix` and\nrebuild the system.\n\nDon't log in as `root`, it's unnecessary.\n\nCommands that require `root` permissions should be run individually using `sudo`\nin all cases. Avoid logging in as `root` & using `sudo su`.\n\nNever run GUI applications as `root`. If there is a legitimate reason for doing\nthis, use `lxsudo` instead.\n\n---\n\n> NOTE: There is mention of making\n> [userborn](https://github.com/nikstur/userborn) the default for NixOS in the\n> future. It can be more secure by prohibiting UID/GID re-use and giving\n> warnings about insecure password hashing schemes.\n\nI have personally had nothing but problems with `userborn` and find the docs\nextremely lacking, you need to read the source code to figure anything out which\nis ridiculous. I don't personally use this but if you figure it out, more power\nto ya.\n\nTo enable `userborn`, just add the following to your `configuration.nix` or\nequivalent:\n\n```nix\n# users.nix\n{pkgs,...}:{\nservices.userborn = {\n    enable = true;\n    # Only needed if `/etc` is immutable\n    # passwordFilesLocation = \"/var/lib/nixos/userborn\"\n};\n    users.users = {\n       \"newuser\" = {\n         homeMode = \"755\";\n         uid = 1000;\n         isNormalUser = true;\n         description = \"New user account\";\n         extraGroups = [ \"networkmanager\" \"wheel\" \"libvirtd\" ];\n         shell = pkgs.bash;\n         ignoreShellProgramCheck = true;\n         packages = with pkgs; [];\n       };\n    };\n    }\n```\n\nWith `userborn`, you configure your users as you normally would declaratively\nwith NixOS with `users.users`, change `\"newuser\"` to your desired username.\n\nExplicitly setting `uid = 1000;` is a best practice for compatibility and\npredictability.\n\n---\n\n**Only install, enable, and run what is needed**: Disable or uninstall\nunnecessary software and services to minimize potential vulnerabilities. Take\nadvantage of NixOS’s easy package management and minimalism to keep your system\nlean and secure.\n\n**Avoid permanently installing temporary tools**: Use tools like `nix-shell`,\n`comma`, `devShells` and `nix-direnv` to test or run software temporarily. This\nprevents clutter and reduces potential risks from unused software lingering on\nthe system.\n\n**Update regularly**: Keep your system and software up to date to receive the\nlatest security patches. Delaying updates leaves known vulnerabilities open to\nexploitation.\n\n**Apply the Principle of Least Privilege**: Never run tools or services as root\nunless absolutely necessary. Create dedicated users and groups with the minimum\nrequired permissions to limit potential damage if compromised.\n\n**Use strong passwords and passphrases**: Aim for at least 14–16 characters by\ncombining several unrelated words, symbols, and numbers. For example:\n`sunset-CoffeeHorse$guitar!`. Strong passphrases are both memorable and secure.\n\n**Use a password manager and enable multi-factor authentication (MFA)**: Manage\nunique, strong passwords effectively with a trusted manager and protect accounts\nwith MFA wherever possible for a second layer of defense.\n\n**Check logs regularly**: Reviewing your system logs helps you spot unusual\nactivity, errors, or failed login attempts that could indicate a security\nproblem. NixOS uses `journald` by default, which makes this easy. For example,\nto see the logs for your current boot session:\n\n```bash\njournalctl -b\n# for the previous session\njournalctl -b -1\n```\n\nAfter establishing some standard best practices and a hardened base, it’s time\nto dive deeper into system hardening, the process of adding layered safeguards\nthroughout your NixOS setup. This next section guides you through concrete steps\nand options for hardening critical areas of your system: from encryption and\nsecure boot to managing secrets, tightening kernel security, and leveraging\nplatform-specific tools.\n[Hardening NixOS](https://saylesss88.github.io/nix/hardening_NixOS.html)\n","number":[1,3,2],"sub_items":[],"path":"nix/index.md","source_path":"nix/README.md","parent_names":["Getting Started with the Nix Ecosystem","Cachix and the devour-flake"]}},{"Chapter":{"name":"Hardening NixOS","content":"# Hardening NixOS\n\n<details>\n<summary> Click to Expand Table of Contents</summary>\n\n<!-- toc -->\n\n</details>\n\n![guy fawks hacker](../images/guy_fawks.png)\n\nSecuring your NixOS system begins with a philosophy of minimalism, explicit\nconfiguration, and proactive control. As desktop Linux attracts more novice\nusers, it has become an increasingly valuable target for attackers. This makes\nit crucial to adopt security best practices early to protect your desktop from\ncommon attack vectors and to avoid configuration mistakes that could expose\nvulnerabilities.\n\n> ⚠️ Warning: I am not a security expert. This guide presents various options\n> for hardening NixOS, but it is your responsibility to evaluate whether each\n> adjustment suits your specific needs and environment. Security hardening and\n> process isolation can introduce stability challenges, compatibility issues, or\n> unexpected behavior. Additionally, these protections often come with\n> performance tradeoffs. Always conduct thorough research, there are no plug and\n> play one size fits all security solutions.\n\n> That said, I typically write about what I'm implementing myself to deepen\n> understanding and share what works for me. `--Source` means the proceeding\n> paragraph came from `--Source`, you can often click to check for yourself. If\n> you use some common sense with a bit of caution you could end up with a more\n> secure NixOS system that fits your needs.\n\n> Much of this guide draws inspiration or recommendations from the well-known\n> [Linux Hardening Guide](https://madaidans-insecurities.github.io/guides/linux-hardening.html)\n> by Madaidan's Insecurities. Madaidan’s work is widely regarded in technical\n> and security circles as one of the most comprehensive and rigorously\n> researched sources on practical Linux security, frequently cited for its depth\n> and actionable advice. For example, much of the original basis for hardening\n> for [nix-mineral](https://github.com/cynicsketch/nix-mineral) came from this\n> guide as well. This can be a starting point but shouldn't be blindly followed\n> either, always do your own research, things change frequently.\n\nFor an article with apposing perspectives, see\n[debunking-madaidans-insecurities](https://chyrp.cgps.ch/en/debunking-madaidans-insecurities/).\nWe can learn from both and hopefully find something in between that is closer to\nthe truth.\n\n> ❗ **Note on SELinux and AppArmor**: While NixOS can provide a high degree of\n> security through its immutable and declarative nature, it's important to\n> understand the limitations regarding Mandatory Access Control (MAC)\n> frameworks. Neither SELinux nor AppArmor are fully supported or widely used in\n> the NixOS ecosystem. You can do a lot to secure NixOS but if anonymity and\n> isolation are paramount, I recommend booting into a\n> [Tails USB stick](https://tails.net/). Or using\n> [Whonix](https://www.whonix.org/).\n\n☝️ The unique file structure of NixOS, particularly the immutable `/nix/store`,\nmakes it difficult to implement and manage the file-labeling mechanisms that\nthese frameworks rely on. There are ongoing community efforts to improve\nsupport, but as of now, they are considered experimental and not a standard part\nof a typical NixOS configuration. For an immutable distro that implements\nSELinux by default at a system level as well as many other hardening techniques,\nsee [Fedora secureblue](https://secureblue.dev/).\n\nContainers and VMs are beyond the scope of this chapter but can also enhance\nsecurity and sandboxing if configured correctly. See\n[Running NixOS in a VM](https://saylesss88.github.io/nix/kvm.html) for more\ndetails on running NixOS in a Secureblue VM for additional security.\n\nIt's crucial to **document every change** you make. By creating smaller,\nfeature-complete commits, each with a descriptive message, you're building a\nclear history. This approach makes it far simpler to revert a breaking change\nand quickly identify what went wrong. Over time, this discipline allows you to\ncreate security-focused checklists and ensure all angles are covered, building a\nmore robust and secure system.\n\nDon't rely on single solutions or products, develop processes and defense in\ndepth. Think ahead and fail securely so that a single failure doesn't mean total\ninsecurity.\n\nAttackers often monitor the latest Linux CVEs (Common Vulnerabilities and\nExposures) and check if and when specific distributions like NixOS have\nimplemented fixes. The unstable branch will receive the security patches and\nfixes faster than stable which is another thing to keep in mind.\n\nCheck out the\n[Hardening NixOS Baseline Hardening README](https://saylesss88.github.io/nix/index.html)\nfor baseline hardening recommendations and best practices.\n\nThere is something to be said about the window manager you use. GNOME, KDE\nPlasma, and Sway secure privileged Wayland protocols like screencopy. This means\nthat on environments outside of GNOME, KDE, and Sway, applications can access\nscreen content of the entire desktop. This implicitly includes the content of\nother applications. It's primarily for this reason that Silverblue, Kinoite, and\nSericea images are recommended. COSMIC has plans to fix this.\n--[secureblue Images](https://secureblue.dev/images)\n\nFor example, to disable Xwayland for sway on home-manager you would add:\n\n```nix\nwayland.windowManager.sway = {\n  enable = true;\n  extraConfig = ''\n    xwayland disable\n  '';\n}\n```\n\n- You may get an error saying you're only able to disable xwayland at boot,\n  restart your system and you'll be all set.\n\nYou can explicitly disable `xdg-desktop-portal-wlr` with systemd in your\n`configuration.nix` like this:\n\n```nix\n# configuration.nix\nsystemd.user.services.\"xdg-desktop-portal-wlr\" = {\n  enable = false;  # Masks/stops the wlr service\n};\nxdg.portal.wlr.enable = false;\n```\n\n## Common Attack Vectors for Linux\n\n<details>\n<summary> ✔️ Click to Expand Common Attack Vectors in Linux </summary>\n\n**Privilege escalation**: The unauthorized act of gaining elevated permissions\nrather than legitimate, controlled privilege use. It's a very common tactic that\nthreat actors use to take over a system, steal data, delete files, and more.\n\n**Processes to protect against Privilege escalation**\n\n- Adopt the principle of least privilege, only giving users the permissions that\n  they require to perform their duties.\n\n- Harden your system: Minimize the attack surface, use strong passwords, and\n  follow best practices.\n\n- Monitor relevant sources such as the\n  [NIST National Vulnerability Database](https://www.strongdm.com/nist-compliance),\n  [NixOS Security Advisories](https://github.com/NixOS/nix/security/advisories),\n  and\n  [NixOS Discourse Security](https://discourse.nixos.org/c/announcements/security/56)\n  So you'll know the latest CVEs and vulnerabilities in Linux and NixOS.\n\n- While not made for NixOS the\n  [linPEAS Privilege Escalation Awesome Script](https://github.com/peass-ng/PEASS-ng/tree/master/linPEAS)\n  gives you some useful info such as active capabilities and potential risks.\n\n- Remove unnecessary SUID binaries to reduce the attack surface.\n\n---\n\n**Use after Free/Double free**:\n\n**Use-After-Free (UAF)** is a type of software vulnerability that occurs in\nmemory unsafe languages (C C++) when a program continues to use a memory\nlocation after it has been freed or deallocated.\n\n**Double free**: is a flaw where a program frees the same memory block twice\nusing `free()` or `delete`, leading to undefined behavior and potential\nexploitation.\n\nMitigation techniques include the use of hardened allocators such as\n`hardened_malloc`, which improve memory management to detect and prevent UAF and\ndouble-free bugs. Recent versions of `glibc` also incorporate built-in checks to\ncatch double frees.\n\n---\n\n**Unauthorized Access**:\n\nUnauthorized access is the entry or use of your system, networks, or data by\nindividuals without permission. It's a common way for adversaries to exfiltrate\ndata, execute malicious code, and cause damage.\n\n**Protections against Unauthorized Access**\n\n- Strong Passwords, MFA, and robust Secrets management. In 2025, 22% of breaches\n  involved stolen credentials overall; in basic web app attacks, 88% used stolen\n  credentials.\n  --[StrongDM data-breach-statistics](https://www.strongdm.com/blog/data-breach-statistics)\n\n- Close unused ports with a Firewall\n\n- Encrypt data in transit and at rest\n\n- Watch your Logs, and deploy intrusion detection systems such as AIDE.\n\n- [SQL Injection CWE](https://cwe.mitre.org/data/definitions/89.html), SQL\n  injection is the most common critical web application vulnerability.\n\n- [Cross Site Scripting (XSS)](https://owasp.org/www-community/attacks/xss/)\n\n---\n\n**Misconfiguration**\n\n- With many new users trying NixOS, misconfiguration is common and an easy way\n  for an attacker to gain control over your system.\n\n- It is recommended to start slowly and try to ensure that you understand your\n  configuration. Avoid copy-pasting config files that you don't understand yet.\n\n---\n\n**Zero Day Exploits**:\n\nThe term \"Zero-Day\" refers to a security vulnerability or flaw that is unknown\nto the software developers or security teams, meaning they have had zero days to\ncreate a patch or fix for it. This term is often associated with concepts such\nas Vulnerabilities, Exploits, and Threats, and it’s important to distinguish\namong them:\n\n- A **Zero-Day Vulnerability** is a previously undiscovered security weakness or\n  flaw in software that malicious actors can exploit.\n\n- A **Zero-Day Exploit** describes the specific method or technique attackers\n  use to take advantage of that vulnerability to compromise a system.\n\n- A **Zero-Day Attack** happens when malicious actors launch an attack using a\n  zero-day exploit before the software vendor has had a chance to patch or fix\n  the vulnerability.\n\n- [Project Zero's 0day spreadsheet](https://docs.google.com/spreadsheets/d/1lkNJ0uQwbeC1ZTRrxdtuPLCIl7mlUreoKfSIgajnSyY/view?gid=0#gid=0).\n  You'll see that a majority of zero-days are Memory Corruption bugs.\n\n- [Zero-Day tracking project](https://www.zero-day.cz/database/)\n\n- [ Trend Micro's zero day inituative](https://www.zerodayinitiative.com/advisories/published/)\n\n</details>\n\n---\n\n## Minimal Installation with LUKS\n\nBegin with NixOS’s minimal installation image. This gives you a base system with\nonly essential tools and no extras that could introduce vulnerabilities.\n\nNixOS's declarative model makes auditing the installed packages and services\neasy, do so regularly.\n\n---\n\n## Manual Encrypted Install Following the Manual\n\nEncryption is the process of using an algorithm to scramble plaintext data into\nciphertext, making it unreadable except to a person who has the key to decrypt\nit.\n\n**Data at rest** is data in storage, such as a computer's or a servers hard\ndisk.\n\n**Data at rest encryption** (typically hard disk encryption), secures the\ndocuments, directories, and files behind an encryption key. Encrypting your data\nat rest prevents data leakage, physical theft, unauthorized access, and more as\nlong as the key management scheme isn't compromised.\n\n- [Minimal ISO Download (64-bit Intel/AMD)](https://channels.nixos.org/nixos-25.05/latest-nixos-minimal-x86_64-linux.iso)\n\n- [NixOS Manual Installation](https://nixos.org/manual/nixos/stable/#sec-installation)\n\n- [NixOS Wiki Full Disk Encryption](https://wiki.nixos.org/wiki/Full_Disk_Encryption)\n\n- The\n  [NSA, CISA, and NIST warn](https://www.nsa.gov/Press-Room/Press-Releases-Statements/Press-Release-View/Article/3498776/post-quantum-cryptography-cisa-nist-and-nsa-recommend-how-to-prepare-now/)\n  that nation-state actors are likely stockpiling encrypted data now, preparing\n  for a future when quantum computers could break today’s most widely used\n  encryption algorithms. Sensitive data with long-term secrecy needs is\n  especially at risk.\n\n- This is a wake-up call to use the strongest encryption available today and to\n  plan early for post-quantum security.\n\n- [NIST First 3 Post-Quantum Encryption Standards](https://www.nist.gov/news-events/news/2024/08/nist-releases-first-3-finalized-post-quantum-encryption-standards)\n  Organizations and individuals should prepare to migrate cryptographic systems\n  to these new standards as soon as practical.\n\n- They chose\n  [Four Quantum-Resistant Cryptographic Algorithms](https://www.nist.gov/news-events/news/2022/07/nist-announces-first-four-quantum-resistant-cryptographic-algorithms)\n  warning that public-key cryptography is especially vulnerable and widely used\n  to protect digital information.\n\n---\n\n## Guided Encrypted BTRFS Subvol install using disko\n\nUse LUKS encryption to protect your data at rest, the following guide is a\nminimal disko encrypted installation:\n[Encrypted Install](https://saylesss88.github.io/installation/enc/enc_install.html)\n\n---\n\n## Installing Software\n\n> The 2025 Edgescan study examined full-stack applications and found that\n> one-third contained critical or severe vulnerabilities, putting them at risk.\n> Over 45% of large enterprises leave unresolved vulnerabilities for more than a\n> year. This shows the necessity of containing your apps in sandboxes when\n> possible.\n> --[edgescan Vulnerability Report](https://www.edgescan.com/stats-report/)\n\n> ⚠️ For system security it is strongly advised to not install\n> [proprietary](https://en.wikipedia.org/wiki/Proprietary_software),\n> [non-freedom](https://www.gnu.org/proprietary/proprietary.html) software.\n> Instead, use of\n> [Free Software](https://www.fsf.org/about/what-is-free-software) is\n> [recommended](https://www.gnu.org/philosophy/shouldbefree.html) --Kicksecure\n\n- [Proprietary Software is Often Malware](https://www.gnu.org/proprietary/proprietary.html)\n  NOTE: While I respect the importance of software freedom, I choose to focus on\n  practical, technical solutions rather than engage with the ideological tone\n  often present in related advocacy.\n  - [User Freedom Threats](https://www.kicksecure.com/wiki/Miscellaneous_Threats_to_User_Freedom)\n\n  - [Proprietary Back Doors](https://www.gnu.org/proprietary/proprietary-back-doors.html)\n\n  - [EFF Back Doors](https://www.eff.org/deeplinks/2015/02/who-really-owns-your-drones)\n\n```nix\n# configuration.nix\nnixpkgs.config.allowUnfree = false;\n```\n\nTo explicitly disable it for flakes:\n\n```nix\n# ...snip...\npkgs = import nixpkgs {\n  system = \"x86_64-linux\";\n  config = {\n    allowUnfree = false;\n  };\n};\n# ...snip...\n```\n\nMost users don't fully understand that running any software without sandboxing\ngives it unrestricted access to their user data and system resources. There is a\nwidespread lack of awareness that Linux apps generally run with the full\npermissions of the user. It's easy to overlook the fact that \"trusted source\"\ndoesn't mean \"safe to run uncontained\". --summarized from kicksecure docs\n\n**Pre-Install Recommendations**\n\nWhen installing software, first check\n[search.nixos](https://search.nixos.org/packages), and follow the `Homepage`\nlink to ensure that said package is maintained.\n\nFor example, when I search for `doas`, and go to the\n[Homepage](https://github.com/Duncaen/OpenDoas) link, I can see that the most\nrecent commit was made 3 years ago. For certain software this might not be an\nissue but `doas` isn't one of them.\n\nLooking at the `sudo-rs`\n[Homepage](https://github.com/trifectatechfoundation/sudo-rs) I can see that it\nwas updated yesterday (11-19-25) and might be a better alternative. It's\nmaintained and written in a memory safe language.\n\nFor critical apps like `sudo`, you should also check for vulnerabilities in said\nsoftware. If you did so for `sudo-rs`, you'd see\n[CVE-2025-64170](https://nvd.nist.gov/vuln/detail/CVE-2025-64170) and see that\nit's been patched. You can then look at the\n[sudo-rs package.nix](https://github.com/NixOS/nixpkgs/blob/master/pkgs/by-name/su/sudo-rs/package.nix)\nto ensure that the versions match. (As of 11-20-25 they match).\n\n---\n\n**nixpkgs-unstable Security Overview**\n\n- `nixpkgs-unstable` tracks the master branch of the Nixpkgs repo and is\n  constantly updated.\n\n- This branch gets security updates faster, patching vulnerabilities faster.\n\n- Since it's a rolling-release, packages are less thoroughly tested. This\n  increases the risk of new, undiscovered bugs or regressions. Some of which\n  could have security implications.\n\n- The packages are generally the most recent upstream versions, which is\n  important for security-sensitive software like browsers and kernels, as old\n  versions may have publicly known, unpatched vulnerabilities.\n\n- As the name states, `nixpkgs-unstable` is less stable and an update is more\n  likely to cause your system to fail to build due to breaking changes in Nix\n  expressions.\n\n- I personally use unstable for everything, but I don't mind having to fix\n  issues that arise.\n\n---\n\n**Stable (e.g., `nixos-24.05`) Security Overview**\n\nStable Nixpkgs channels correspond to point release (e.g., released every 6\nmonths) and are supported for a limited period (typically one month past the\nnext release).\n\n- Stable channels generally only receive conservative bug and security fixes.\n  Major version bumps for features are typically avoided to maintain \"stability\n  against deliberate changes\", which means you won't get the latest upstream\n  features or general bug fixes.\n\n- While critical security updates are backported quickly, updates for less\n  critical packages may be slower or not happen at all if they require a\n  significant refactoring or version bump.\n\n- Stable channels are generally more stable, meaning updates are less likely to\n  introduce breaking changes to your configuration or system environment.\n\n- Many packages will be older versions. If a critical security vulnerability\n  requires a major upstream version update (which is often avoided in a stable\n  channel), the maintainers must backport the patch, a process which can\n  introduce its own set of risks and delays.\n\n---\n\n**What should you use?**\n\nThe primary security trade-off is between **patching speed for known\nvulnerabilities** and **stability/exposure to new bugs**:\n\n- Choose `unstable` if you prioritize getting the latest security fixes\n  (especially for end-user apps like browsers) as soon as they are available\n  upstream, accepting a higher risk of non-security-related system breakage or\n  new, undiscovered bugs.\n\n- Choose `stable` if you prioritize system predictability and stability, relying\n  on dedicated backports for critical vulnerabilities, while accepting that\n  non-critical security and bug fixes will be delayed or absent until the next\n  major release.\n\nA common hybrid approach is to use the `stable` channel as the base for the OS\nand selectively pin specific packages from `unstable` to ensure they receive\nrapid security updates.\n\nWith flakes it's easy to add both `stable` and `unstable` as flake inputs and\naccess each with some simple logic.\n\n<details>\n<summary> ✔️ Click to Expand Flake example using both stable & unstable </summary>\n\n```nix\n{\n  description = \"NixOS configuration with two or more channels\";\n\n inputs = {\n    nixpkgs.url = \"github:NixOS/nixpkgs/nixos-25.05\";\n    nixpkgs-unstable.url = \"github:NixOS/nixpkgs/nixos-unstable\";\n  };\n\n  outputs =\n    { nixpkgs, nixpkgs-unstable, ... }:\n    {\n      nixosConfigurations.\"your-host\" = nixpkgs.lib.nixosSystem {\n        modules = [\n          {\n            nixpkgs.overlays = [\n              (final: prev: {\n                unstable = nixpkgs-unstable.legacyPackages.${prev.system};\n                # use this variant if unfree packages are needed:\n                # unstable = import nixpkgs-unstable {\n                #   inherit prev;\n                #   system = prev.system;\n                #   config.allowUnfree = true;\n                # };\n              })\n            ];\n          }\n          ./configuration.nix\n        ];\n      };\n    };\n}\n```\n\n- This is also how you enable unfree packages for flakes rather than in your\n  `configuration.nix`.\n\nNow you can specify which packages are to be installed with which channel like\nso:\n\n```nix\n# configuration.nix\n{ pkgs, ... }:\n{\n  environment.systemPackages = [\n    pkgs.firefox\n    pkgs.unstable.helix\n  ];\n  # ...\n}\n```\n\n</details>\n\n---\n\n## Users and SUID Binaries\n\n**Replacing sudo with run0**\n\n> NOTE: The point here is to avoid using the setuid binary (`sudo`), `run0` is a\n> wrapper over `systemd-run` which speaks over Inter-process Communication\n> Mechanisms (IPC) to PID1 which is considered safer than running a setuid\n> binary. We separate our daily user from administration tasks and authenticate\n> through our admin account. This reduces the attack surface by removing sudo as\n> well as reduces the risk of local privilege escalation.\n\n- **IPC** is the mechanism that allows processes to communicate. There are two\n  methods of IPC, shared memory and message passing. An OS can implement both.\n\n- **PID 1** is the first userspace process the kernel starts (the init system),\n  which becomes the ancestor and reaper of all other processes; because it runs\n  as root, is always present, and controls the system lifecycle, any bugs or\n  design issues in PID 1 have outsized security impact and can translate into\n  system-wide compromise or denial of service.\n\n<details>\n<summary> Click to Expand SUID and run0 resources </summary>\n\n- [run0 explained by Lennart](https://mastodon.social/@pid_eins/112353324518585654)\n\n- [setuid Wikipedia](https://en.wikipedia.org/wiki/Setuid)\n\n- Using `run0` removes of these classes of\n  [attacks](https://ruderich.org/simon/notes/su-sudo-from-root-tty-hijacking)\n\n- The following lists some of the downsides\n  [kicksecure vs secureblue](https://www.kicksecure.com/wiki/Dev/secureblue)\n\n</details>\n\n`run0` is not a SUID, it asks the service manager to invoke a command or shell\nunder the target user's UID. The target command is invoked in an isolated exec\ncontext, freshly forked off PID1 without inheriting any context from the client.\n\nThe core danger of **setuid** (Set User ID) lies in its ability to allow a\nlow-privilege user to execute a program with the **permissions of the file's\nowner**, which is most often the powerful **root user**.\n\n### 💥 The Danger of setuid\n\nFor granting limited, controlled privilege escalation to apps, the primary\nchoices are broadly between traditional **setuid/setgid permissions** and more\nmodern **Linux capabilities**. [Jump to Capabilities](#capabilities)\n\n- [Understanding setuid/setgid](https://www.cbtnuggets.com/blog/technology/system-admin/linux-file-permissions-understanding-setuid-setgid-and-the-sticky-bit)\n\nUse the following command to find all SUID binaries:\n\n```bash\nsudo find / -perm -4000 -type f -ls 2>/dev/null\n```\n\nThe `setuid` permission is dangerous because it creates a privilege escalation\npathway that can be exploited for malicious purposes.\n\n- Temporary Root Access: When a file has the setuid bit set and is owned by\n  `root`, any user who executes that program instantly and temporarily gains the\n  full power of the root user while the program runs.\n\n- If a setuid program (such as `passwd`, or `sudo`) contain a security flaw,\n  such as a buffer overflow (Common in C) or improper input validation, an\n  attacker can exploit the flaw.\n\n- Since the program is running with root privileges, the attacker can execute\n  shell code or commands with root access, completely compromising the entire\n  system.\n\nNormally the root user (UID 0) gets unrestricted access to almost everything on\nthe entire system.\n\nI rebuild/update way too often to completely separate the accounts and allow no\nadmin tasks for my daily user. That may be a better option for servers, etc.\n\nCreate an admin user for administrative tasks and remove your daily user from\nthe `wheel` group, and disable the `sudo`, `su`, and `pkexec` SUIDs:\n\n```users.nix\n{ config, pkgs, lib }:\n{\nusers.users.admin = {\n    isNormalUser = true;\n    description  = \"System administrator\";\n    extraGroups  = [ \"wheel\" ];   # wheel = sudo\n    # run `mkpasswd --method=yescrypt` and replace \"changeme\" w/ the result\n    initialHashedPassword = \"changeme\";           # change with `passwd admin` later\n    openssh.authorizedKeys.keys = [\n      # (optional) paste your SSH public key here\n      # \"ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAI...\"\n    ];\n  };\n    users.groups.admin = {};\n    users.mutableUsers = false;\n\n  # --------------------------------------------------------------------\n  # 2. Existing daily user – remove from wheel, keep everything else\n  # --------------------------------------------------------------------\n  users.users.daily = {\n    isNormalUser = true;\n    description  = \"Daily driver account\";\n    extraGroups  = lib.mkForce [ \"networkmanager\" \"audio\" \"video\" ]; # keep useful groups\n    initialHashedPassword = \"changeme\";\n    # Remove `wheel` by *not* listing it (mkForce overrides any default)\n  };\n  users.groups.daily = {};\n\nsecurity = {\npolkit.enable = true;\n# Disable sudo\nsudo.enable = false;\nwrappers = {\n    su.setuid = lib.mkForce = false;\n    sudo.setuid = lib.mkForce = false;\n    sudoedit.setuid = lib.mkForce = false;\n    sg.setuid = lib.mkForce = false;\n    fusermount.setuid = lib.mkForce = false;\n    fusermount3.setuid = lib.mkForce = false;\n    mount.setuid = lib.mkForce = false;\n    pkexec.setuid = lib.mkForce = false;\n    newgrp.setuid = lib.mkForce = false;\n    newgidmap.setuid = lib.mkForce = false;\n    newuidmap.setuid= lib.mkForce = false;\n};\n# Or hyprlock, required for swaylock to accept your password\npam.services.swaylock = {\n  text = ''\n    auth include login\n    account include login\n    password include login\n    session include login\n  '';\n  };\n};\n```\n\nThe `security.wrappers...` removes the setuid bit making the commands unusable\nremoving the SUID vulnerabilities for `su` and `pkexec`. You can find the other\nSUID wrappers in `/run/wrappers/bin/`, such as `fusermount` and more.\n\nSUID's that can be disabled:\n\n- `umount`: Allows unprivileged users to unmount devices listed in your fstab.\n\n- `mount`: Same as above but for mounting.\n\n- `sg`: Executes a command as a different group.\n\n- `mtr-packet`: Used by mtr to create network sockets.\n\n- `fusermount`, `fusermount3`: Allows unprivileged users to mount FUSE\n  filesystems. Can be disabled if you don't use FUSE (e.g., Appimages, etc.)\n\n- `newuidmap`, `newgidmap`: Used for user namespace creation (Often used for\n  unprivileged containers). (Disable if you don't use unprivileged\n  containers/namespaces)\n\n---\n\nNever Disable:\n\n- `unix_chkpwd`: This is a core PAM helper to securely check user passwords\n  against the root-readable `/etc/shadow`.\n\nCheck again which SUID binaries are active:\n\n```bash\nsudo find / -perm -4000 -type f -ls 2>/dev/null\n```\n\n---\n\nYou will have to use `run0` to authenticate your daily user, for example:\n\n```bash\nrun0 nixos-rebuild switch --flake .\n```\n\nSince `run0` doesn't cache results and `nixos-rebuild` calls on Polkit 3 times,\nso on every rebuild, you will be asked for your password 3 times which isn't\nideal. I found the following workaround that will only ask for your password\nonce.\n\nAdd the following to your `configuration.nix`, replacing `user-name` with your\nusername:\n\n```nix\n security.polkit.extraConfig = ''\n     polkit.addRule(function(action, subject) {\n       if (subject.user == \"user-name\") {\n         if (action.id.indexOf(\"org.nixos\") == 0) {\n           polkit.log(\"Caching admin authentication for single NixOS operation\");\n           return polkit.Result.AUTH_ADMIN_KEEP;\n         }\n       }\n     });\n   '';\n```\n\nCreate a zsh function for easy access:\n\n```nix\n# zsh.nix\n#...snip...\ninitContent = ''\n  fr() {\n    run0 nixos-rebuild switch --flake \"/home/$USER/flake#\"$(hostname)\n  }\n'';\n```\n\nNeedless to say, this is less secure but much more convenient than entering your\npassword 3 times on every single rebuild.\n\nWithout the `pam` settings for swaylock, it won't accept your password to log\nback in.\n\n**run0 Usage Example**\n\nWhen you are in a privileged shell, `run0` changes the color of the background\nto red to remind you of this.\n\nExample creating a user:\n\n1. `run0`\n\n2. `adduser admin`\n\n3. `usermod -aG wheel admin`\n\n4. `passwd admin`\n\n5. `exit`\n\n6. `reboot`\n\nThis is just an example, since we manage our users declaratively the user\ncreated would be discarded on the next rebuild because of the\n`users.mutableUsers = false;` setting. You could of course change this to `true`\nto manage your users imperatively but I don't recommend it.\n\n---\n\n### Capabilities\n\n<details>\n\n<summary> ✔️ Click to expand capabilities examples </summary>\n\nOne way to help get rid of setuid binaries is to replace them with capabilities.\nI personally only remove the SUID bit and don't try to replace with capabilities\nas of now. You can still use the commands from `security.wrappers` such as\n`run0 su -`.\n\nCapabilities provide a subset of what is available to root to a process. This\nbreaks up root privileges into smaller units that can independently grant access\nto processes. This reduces the full set of privileges, decreasing the risk of\nexploitation.\n\n(This is just an example):\n\n```nix\n{\n  # a setuid root program\n  doas =\n    { setuid = true;\n      owner = \"root\";\n      group = \"root\";\n      source = \"${pkgs.doas}/bin/doas\";\n    };\n\n  # a setgid program\n  locate =\n    { setgid = true;\n      owner = \"root\";\n      group = \"mlocate\";\n      source = \"${pkgs.locate}/bin/locate\";\n    };\n\n  # a program with the CAP_NET_RAW capability\n  ping =\n    { owner = \"root\";\n      group = \"root\";\n      capabilities = \"cap_net_raw+ep\";\n      source = \"${pkgs.iputils.out}/bin/ping\";\n    };\n}\n```\n\nList the highest capability number for your kernel with:\n\n```bash\ncat /proc/sys/kernel/cap_last_cap\n# Output:\n40\n```\n\nList available Linux capabilities:\n\n```bash\ncapsh --print\n```\n\nList processes:\n\n```bash\nps\n# Example Output\nPID    TTY     TIME   CMD\n8063   pts/1    02     zsh\n```\n\n```bash\ncat /proc/8063/status | grep Cap\n# Output\nCapInh: 0000000800000000\nCapPrm: 0000000000000000\nCapEff: 0000000000000000\nCapBnd: 000001ffffffffff\nCapAmb: 0000000000000000\n```\n\n```bash\ncapsh --decode=000001ffffffffff\n# Output\n0x000001ffffffffff=cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend,cap_audit_read,cap_perfmon,cap_bpf,cap_checkpoint_restore\n```\n\n`cap_net_raw`: Allows the program to use raw and unbuffered network sockets,\nwhich is what `ping` and `mtr-packet` need to send ICMP packets.\n\n`cap_sys_admin`: Grants a variety of system administration operations, including\nthe ability to perform FUSE mounts. This is a powerful capability, but it's\nstill more restrictive than full root SUID.\n\n- `+ep`: This is crucial. It stands for:\n  - `e` (Effective): The set of capabilities actually used by the process when\n    running.\n\n  - `p` (Permitted): The set of capabilities that can be enabled by the process.\n\nBy using this approach, you are following the security principle of least\nprivilege, significantly reducing the attack surface compared to traditional\nSUID binaries.\n\n- [security.wrappers](https://search.nixos.org/options?channel=unstable&show=security.wrappers&query=security.wrappers)\n\n- [Linux Audit capabilities 101](https://linux-audit.com/kernel/capabilities/linux-capabilities-101/)\n\n- [Kicksecure's take on capabilities](https://www.kicksecure.com/wiki/Dev/secureblue#capabilities)\n\n- [capabilities(7)](https://man7.org/linux/man-pages/man7/capabilities.7.html)\n\n- [capabilities and seccomp](https://docs.redhat.com/en/documentation/red_hat_enterprise_linux_atomic_host/7/html/container_security_guide/linux_capabilities_and_seccomp)\n\n</details>\n\n---\n\n## Impermanence\n\nImpermanence, especially when using a `tmpfs` as the root filesystem, provides\nseveral significant security benefits. The core principle is that impermanence\ndefeats persistence, a fundamental goal for any attacker.\n\nWhen you use a root-as-tmpfs setup on NixOS, the boot process loads the entire\noperating system from the read-only Nix store into a `tmpfs` in RAM. The mutable\ndirectories, such as `/etc` and `/var`, are then created on this RAM disk. When\nthe system is shut down, the `tmpfs` is wiped, leaving the on-disk storage\nuntouched and secure.\n\nThis means you get a fresh, secure boot every time, making it much harder for an\nattacker to maintain a presence on your system.\n\n- [Erase your Darlings (ZFS)](https://grahamc.com/blog/erase-your-darlings/)\n\n- [Encrypted BTRFS Impermanence Guide](https://saylesss88.github.io/installation/enc/encrypted_impermanence.html)\n  Only follow this guide if you also followed the encrypted disko install,\n  impermanence is designed to be destructive and needs to match your config\n  exactly.\n\n## Replace timesyncd with a chron job that enables Network Time Security (NTS)\n\nThis is implementing the GrapheneOS/secureblue NTS chrony settings to NixOS:\n\n```nix\n{ config\n, ...\n}:\n{\n  services.chrony = {\n    enable = true;\n    enableNTS = true;\n    servers = [\n        \"server time.cloudflare.com iburst nts\"\n        \"server ntppool1.time.nl iburst nts\"\n        \"server nts.netnod.se iburst nts\"\n        \"server ptbtime1.ptb.de iburst nts\"\n        \"server time.dfm.dk iburst nts\"\n        \"server time.cifelli.xyz iburst nts\"\n     ];\n    # havent worked out the kinks yet\n  #  extraConfig = ''\n  #      minsources 3\n  #      authselectmode require\n\n  #      # EF\n  #      dscp 46\n\n  #      driftfile /var/lib/chrony/drift\n  #      dumpdir /var/lib/chrony\n  #      ntsdumpdir /var/lib/chrony\n\n  #      leapseclist /usr/share/zoneinfo/leap-seconds.list\n  #      makestep 1.0 3\n\n  #      rtconutc\n\n  #      cmdport 0\n\n  #      noclientlog\n  #  '';\n  };\n}\n```\n\nEnsure NTS is being used with:\n\n```bash\nsudo chronyc -N authdata\n```\n\n---\n\n## Secure Boot\n\n<!-- ![Virus](../images/virus1.png) -->\n\nEnable a UEFI password or Administrator password where it requires\nauthentication in order to access the UEFI/BIOS.\n\nSecure Boot helps ensure only signed, trusted kernels and bootloaders are\nexecuted at startup.\n\nUseful Resources:\n\n<details>\n<summary> ✔️ Click to Expand Secure Boot Resources </summary>\n\n- [The Strange State of Authenticated Boot and Encryption](https://0pointer.net/blog/authenticated-boot-and-disk-encryption-on-linux.html)\n\n- [NixOS Wiki Secure Boot](https://wiki.nixos.org/wiki/Secure_Boot)\n\n- [lanzaboote repo](https://github.com/nix-community/lanzaboote)\n\n</details>\n\nPractical Lanzaboote Secure Boot setup for NixOS:\n[Guide:Secure Boot on NixOS with Lanzaboote](https://saylesss88.github.io/installation/enc/lanzaboote.html)\n\n---\n\n### The Kernel\n\nThe Kernel Self Protection Project:\n\n- [KSPP Recommended_Settings](https://kspp.github.io/Recommended_Settings)\n\nGiven the kernel's central role, it's a frequent target for malicious actors,\nmaking robust hardening essential.\n\nNixOS provides a `hardened` profile that applies a set of security-focused\nkernel and system configurations.\n\nFor flakes, you could do something like the following in your\n`configuration.nix` or equivalent to import `hardened.nix` and enable\n`profiles.hardened`:\n\n```nix\n# configuration.nix\n{ pkgs, inputs, ... }: let\n   modulesPath = \"${inputs.nixpkgs}/nixos/modules\";\n\nin {\n  imports = [ \"${modulesPath}/profiles/hardened.nix\" ];\n\n}\n```\n\n- There is a proposal to remove it completely that has gained ground, the\n  following thread discusses why:\n  [Discourse Thread](https://discourse.nixos.org/t/proposal-to-deprecate-the-hardened-profile/63081)\n\n- [PR #383438](https://github.com/NixOS/nixpkgs/pull/383438) Proposed removal\n  PR.\n\n- Check\n  [hardened.nix](https://github.com/NixOS/nixpkgs/blob/master/nixos/modules/profiles/hardened.nix)\n  to see exactly what adding it enables to avoid duplicates and conflicts moving\n  on. I included this for completeness, the choice is yours if you want to use\n  it or not.\n\n## Choosing your Kernel\n\nSee which kernel you're currently using with:\n\n```bash\n# show the kernel release\nuname -r\n# show kernel version, hostname, and architecture\nuname -a\n```\n\nShow the configuration of your current kernel:\n\n```bash\nzcat /proc/config.gz\n# ...snip...\n#\n# Compression\n#\nCONFIG_CRYPTO_DEFLATE=m\nCONFIG_CRYPTO_LZO=y\nCONFIG_CRYPTO_842=m\nCONFIG_CRYPTO_LZ4=m\nCONFIG_CRYPTO_LZ4HC=m\nCONFIG_CRYPTO_ZSTD=y\n# end of Compression\n# ...snip...\n```\n\nThe [NixOS Manual](https://nixos.org/manual/nixos/stable/#sec-kernel-config)\nstates that the default Linux kernel configuration should be fine for most\nusers.\n\nThe Linux kernel is typically released under two forms: stable and long-term\nsupport (LTS). Choosing either has consequences, do your research.\n[Stable vs. LTS kernels](https://madaidans-insecurities.github.io/guides/linux-hardening.html#stable-vs-lts)\n\n- [The Linux Kernel Archives Active kernel releases](https://www.kernel.org/category/releases.html)\n\n**OR**, you can choose the hardened kernel for a kernel that prioritizes\nsecurity over everything else.\n\n---\n\n### The Hardened Kernel\n\n> NOTE: Expect breakage when using the hardened kernel. `linux-hardened`\n> completely disables\n> [unprivileged user namespaces](https://secureblue.dev/articles/userns), which\n> are required for Flatpak, chromium-based browsers, and more.\n\nThe `linuxPackages_latest_hardened` attribute has been deprecated. If you want\nto use a hardened kernel, it is now recommended to use `linux_hardened`, which\nis aliased to `linux_default.kernel`.\n\nYou can find the latest available hardened kernel packages by searching\n[pkgs/top-level/linux-kernels.nix](https://github.com/NixOS/nixpkgs/blob/master/pkgs/top-level/linux-kernels.nix).\n\nIt is recommended to use `linux_hardened` without specifying a version, such as:\n\n```nix\nboot.kernelPackages = pkgs.linuxPackages_hardened;\n```\n\n`linux_hardened` is aliased to the `linux_default.kernel`.\n\nNote that this not only replaces the kernel, but also packages that are specific\nto the kernel version, such as NVIDIA video drivers. This also removes your\nability to use the `.extend` kernel attribute, they are only available to\n_kernel package sets_ (e.g., `linuxPackages_hardened`)\n\n- If you decide to use this, read further before rebuilding.\n\nYou can inspect\n[nixpkgs/pkgs/os-specific/linux/kernel/hardened/patches.json](https://github.com/NixOS/nixpkgs/blob/master/pkgs/os-specific/linux/kernel/hardened/patches.json)\nto see the metadata of the patches that are applied. You can then follow the\nlinks in the `.json` file to see the patch diffs.\n\n---\n\n### sysctl\n\nA tool for checking the security hardening options of the Linux kernel:\n\n```nix\nenvironment.systemPackages = [ pkgs.kernel-hardening-checker ];\n```\n\n`sysctl` is a tool that allows you to view or modify kernel settings and\nenable/disable different features.\n\nCheck all `sysctl` parameters against the `kernel-hardening-checker`\nrecommendations:\n\n```bash\nsudo sysctl -a > params.txt\nkernel-hardening-checker -l /proc/cmdline -c /proc/config.gz -s ./params.txt\n```\n\nCheck the value of a specific parameter:\n\n```bash\nsudo sysctl -a | grep \"kernel.kptr_restrict\"\n# Output:\nkernel.kptr_restrict = 2\n```\n\nCheck Active Linux Security Modules:\n\n```bash\ncat /sys/kernel/security/lsm\n# Output:\nFile: /sys/kernel/security/lsm\ncapability,landlock,yama,bpf,apparmor\n```\n\nCheck Kernel Configuration Options:\n\n```bash\nzcat /proc/config.gz | grep CONFIG_SECURITY_SELINUX\nzcat /proc/config.gz | grep CONFIG_HARDENED_USERCOPY\nzcat /proc/config.gz | grep CONFIG_STACKPROTECTOR\n```\n\nSince it is difficult to see exactly what enabling the hardened_kernel does.\nBefore rebuilding, you could do something like this to see exactly what is\nadded:\n\n```bash\nsudo sysctl -a > before.txt\n```\n\nAnd after the rebuild:\n\n```bash\nsudo sysctl -a > after.txt\n```\n\nAnd finally run a `diff` on them:\n\n```bash\ndiff before.txt after.txt\n```\n\nYou can also diff against `after.txt` for future changes to avoid duplicates,\nthis seems easier to me than trying to parse through the patches.\n\n---\n\n## Kernel Security Settings\n\n```nix\nsecurity = {\n      protectKernelImage = true;\n      lockKernelModules = false; # this breaks iptables, wireguard, and virtd\n\n      # force-enable the Page Table Isolation (PTI) Linux kernel feature\n      forcePageTableIsolation = true;\n\n      # User namespaces are required for sandboxing.\n      # this means you cannot set `\"user.max_user_namespaces\" = 0;` in sysctl\n      allowUserNamespaces = true;\n\n      # Disable unprivileged user namespaces, unless containers are enabled\n      unprivilegedUsernsClone = config.virtualisation.containers.enable;\n      allowSimultaneousMultithreading = true;\n}\n```\n\n---\n\n## Further Hardening with sysctl\n\n`sysctl` hardening settings further reinforce kernel-level protections. The\nhardened kernel includes security patches and stricter defaults, but it doesn't\ncover all runtime tunables. Refer to the above commands to get a diff of the\nchanges.\n\n[boot.kernel.sysctl](https://nixos.org/manual/nixos/stable/options#opt-boot.kernel.sysctl):\nRuntime parameters of the Linux kernel, as set by sysctl(8). Note that the\nsysctl parameters names must be enclosed in quotes. Values may be a string,\ninteger, boolean, or null.\n\nCheck what each setting does [sysctl-explorer](https://sysctl-explorer.net/)\n\nRefer to\n[madadaidans-insecurities#sysctl-kernel](https://madaidans-insecurities.github.io/guides/linux-hardening.html#sysctl-kernel)\nfor the following settings and their explainations.\n\nAlso see the\n[Kernel Self Protection Projects sysctls](https://kspp.github.io/Recommended_Settings#sysctls)\n\n```nix\n  boot.kernel.sysctl = {\n    \"fs.suid_dumpable\" = 0;\n    # prevent pointer leaks\n    \"kernel.kptr_restrict\" = 2;\n    # restrict kernel log to CAP_SYSLOG capability\n    \"kernel.dmesg_restrict\" = 1;\n    # Note: certian container runtimes or browser sandboxes might rely on the following\n    # restrict eBPF to the CAP_BPF capability\n    \"kernel.unprivileged_bpf_disabled\" = 1;\n    # should be enabled along with bpf above\n    # \"net.core.bpf_jit_harden\" = 2;\n    # restrict loading TTY line disciplines to the CAP_SYS_MODULE\n    \"dev.tty.ldisk_autoload\" = 0;\n    # prevent exploit of use-after-free flaws\n    \"vm.unprivileged_userfaultfd\" = 0;\n    # kexec is used to boot another kernel during runtime and can be abused\n    \"kernel.kexec_load_disabled\" = 1;\n    # Kernel self-protection\n    # SysRq exposes a lot of potentially dangerous debugging functionality to unprivileged users\n    # 4 makes it so a user can only use the secure attention key. A value of 0 would disable completely\n    \"kernel.sysrq\" = 4;\n    # disable unprivileged user namespaces, Note: Docker, NH, and other apps may need this\n    # \"kernel.unprivileged_userns_clone\" = 0; # Set to 1 because it makes NH and other programs fail\n    # This should be set to 0 if you don't rely on flatpak, NH, Docker, etc.\n    \"kernel.unprivileged_userns_clone\" = 1;\n    # restrict all usage of performance events to the CAP_PERFMON capability\n    \"kernel.perf_event_paranoid\" = 3;\n\n    # Network\n    # protect against SYN flood attacks (denial of service attack)\n    \"net.ipv4.tcp_syncookies\" = 1;\n    # protection against TIME-WAIT assassination\n    \"net.ipv4.tcp_rfc1337\" = 1;\n    # enable source validation of packets received (prevents IP spoofing)\n    \"net.ipv4.conf.default.rp_filter\" = 1;\n    \"net.ipv4.conf.all.rp_filter\" = 1;\n\n    \"net.ipv4.conf.all.accept_redirects\" = 0;\n    \"net.ipv4.conf.default.accept_redirects\" = 0;\n    \"net.ipv4.conf.all.secure_redirects\" = 0;\n    \"net.ipv4.conf.default.secure_redirects\" = 0;\n    # Protect against IP spoofing\n    \"net.ipv6.conf.all.accept_redirects\" = 0;\n    \"net.ipv6.conf.default.accept_redirects\" = 0;\n    \"net.ipv4.conf.all.send_redirects\" = 0;\n    \"net.ipv4.conf.default.send_redirects\" = 0;\n\n    # prevent man-in-the-middle attacks\n    \"net.ipv4.icmp_echo_ignore_all\" = 1;\n\n    # ignore ICMP request, helps avoid Smurf attacks\n    \"net.ipv4.conf.all.forwarding\" = 0;\n    \"net.ipv4.conf.default.accept_source_route\" = 0;\n    \"net.ipv4.conf.all.accept_source_route\" = 0;\n    \"net.ipv6.conf.all.accept_source_route\" = 0;\n    \"net.ipv6.conf.default.accept_source_route\" = 0;\n    # Reverse path filtering causes the kernel to do source validation of\n    \"net.ipv6.conf.all.forwarding\" = 0;\n    \"net.ipv6.conf.all.accept_ra\" = 0;\n    \"net.ipv6.conf.default.accept_ra\" = 0;\n\n    ## TCP hardening\n    # Prevent bogus ICMP errors from filling up logs.\n    \"net.ipv4.icmp_ignore_bogus_error_responses\" = 1;\n\n    # Userspace\n    # restrict usage of ptrace\n    \"kernel.yama.ptrace_scope\" = 2;\n\n    # ASLR memory protection (64-bit systems)\n    \"vm.mmap_rnd_bits\" = 32;\n    \"vm.mmap_rnd_compat_bits\" = 16;\n\n    # only permit symlinks to be followed when outside of a world-writable sticky directory\n    \"fs.protected_symlinks\" = 1;\n    \"fs.protected_hardlinks\" = 1;\n    # Prevent creating files in potentially attacker-controlled environments\n    \"fs.protected_fifos\" = 2;\n    \"fs.protected_regular\" = 2;\n\n    # Randomize memory\n    \"kernel.randomize_va_space\" = 2;\n    # Exec Shield (Stack protection)\n    \"kernel.exec-shield\" = 1;\n\n    ## TCP optimization\n    # TCP Fast Open is a TCP extension that reduces network latency by packing\n    # data in the sender’s initial TCP SYN. Setting 3 = enable TCP Fast Open for\n    # both incoming and outgoing connections:\n    \"net.ipv4.tcp_fastopen\" = 3;\n    # Bufferbloat mitigations + slight improvement in throughput & latency\n    \"net.ipv4.tcp_congestion_control\" = \"bbr\";\n    \"net.core.default_qdisc\" = \"cake\";\n  };\n```\n\n> ❗ Note: The above settings are fairly aggressive and can break common\n> programs, read the comment warnings.\n\n---\n\n## Hardening Boot Parameters\n\n`boot.kernelParams` can be used to set additional kernel command line arguments\nat boot time. It can only be used for built-in modules.\n\nYou can find the following settings in the\n[Boot parameters section](https://madaidans-insecurities.github.io/guides/linux-hardening.html#boot-parameters)\n\n```nix\n# boot.nix\n      boot.kernelParams = [\n        # make it harder to influence slab cache layout\n        \"slab_nomerge\"\n        # enables zeroing of memory during allocation and free time\n        # helps mitigate use-after-free vulnerabilaties\n        \"init_on_alloc=1\"\n        \"init_on_free=1\"\n        # randomizes page allocator freelist, improving security by\n        # making page allocations less predictable\n        \"page_alloc.shuffel=1\"\n        # enables Kernel Page Table Isolation, which mitigates Meltdown and\n        # prevents some KASLR bypasses\n        \"pti=on\"\n        # randomizes the kernel stack offset on each syscall\n        # making attacks that rely on a deterministic stack layout difficult\n        \"randomize_kstack_offset=on\"\n        # disables vsyscalls, they've been replaced with vDSO\n        \"vsyscall=none\"\n        # disables debugfs, which exposes sensitive info about the kernel\n        \"debugfs=off\"\n        # certain exploits cause an \"oops\", this makes the kernel panic if an \"oops\" occurs\n        \"oops=panic\"\n        # only alows kernel modules that have been signed with a valid key to be loaded\n        # making it harder to load malicious kernel modules\n        # can make VirtualBox or Nvidia drivers unusable\n        \"module.sig_enforce=1\"\n        # prevents user space code excalation\n        \"lockdown=confidentiality\"\n        # \"rd.udev.log_level=3\"\n        # \"udev.log_priority=3\"\n      ];\n```\n\nThis is a thoughtful start to hardening boot parameters, there are more\nrecommendations in the guide.\n\nKernel modules for hardware devices are generally loaded automatically by\n`udev`. You can force a module to be loaded via `boot.kernelModules`.\n\n---\n\n**Hardening Modprobe**\n\nYou can use both `extraModprobeConfig` & `blacklistedKernelModules` to disable\ndifferent features. If you prefer, you can place these in the next section as\nwell.\n\n```nix\nboot.extraModprobeConfig = ''\n     # firewire and thunderbolt\n    install firewire-core /bin/false\n    install firewire_core /bin/false\n    install firewire-ohci /bin/false\n    install firewire_ohci /bin/false\n    install firewire_sbp2 /bin/false\n    install firewire-sbp2 /bin/false\n    install firewire-net /bin/false\n    install thunderbolt /bin/false\n    install ohci1394 /bin/false\n    install sbp2 /bin/false\n    install dv1394 /bin/false\n    install raw1394 /bin/false\n    install video1394 /bin/false\n'';\n# OR\n#boot.blacklistedKernelModules = [\n#  \"firewire-core\"\n#  # ... snip ...\n#];\n```\n\n---\n\n**Blacklisting Kernel Parameters**\n\nBlacklisting unused kernel modules reduces the attack surface.\n\n[boot.blacklistedKernelModules](https://nixos.org/manual/nixos/stable/options#opt-boot.blacklistedKernelModules):\nList of names of kernel modules that should not be loaded automatically by the\nhardware probing code.\n\nYou can find the following settings in the\n[Blacklisting Kernel Modules Section](https://madaidans-insecurities.github.io/guides/linux-hardening.html#kasr-kernel-modules)\n\n```nix\n      boot.blacklistedKernelModules = [\n        # Obscure networking protocols\n        \"dccp\"   # Datagram Congestion Control Protocol\n        \"sctp\"  # Stream Control Transmission Protocol\n        \"rds\"  # Reliable Datagram Sockets\n        \"tipc\"  # Transparent Inter-Process Communication\n        \"n-hdlc\" # High-level Data Link Control\n        \"ax25\"  # Amateur X.25\n        \"netrom\"  # NetRom\n        \"x25\"     # X.25\n        \"rose\"\n        \"decnet\"\n        \"econet\"\n        \"af_802154\"  # IEEE 802.15.4\n        \"ipx\"  # Internetwork Packet Exchange\n        \"appletalk\"\n        \"psnap\"  # SubnetworkAccess Protocol\n        \"p8023\"  # Novell raw IEE 802.3\n        \"p8022\"  # IEE 802.3\n        \"can\"   # Controller Area Network\n        \"atm\"\n        # Various rare filesystems\n        \"cramfs\"\n        \"freevxfs\"\n        \"jffs2\"\n        \"hfs\"\n        \"hfsplus\"\n        \"udf\"\n\n        # \"squashfs\"  # compressed read-only file system used for Live CDs\n        # \"cifs\"  # cmb (Common Internet File System)\n        # \"nfs\"  # Network File System\n        # \"nfsv3\"\n        # \"nfsv4\"\n        # \"ksmbd\"  # SMB3 Kernel Server\n        # \"gfs2\"  # Global File System 2\n        # vivid driver is only useful for testing purposes and has been the\n        # cause of privilege escalation vulnerabilities\n        # \"vivid\"\n      ];\n```\n\nAs with the `kernelParameters` above, there are more suggestions in the guide, I\nhave used the above parameters along with the commented out ones and had no\nissues.\n\nAlso see\n[SecureBlue's blacklist.conf](https://github.com/secureblue/secureblue/blob/live/files/system/etc/modprobe.d/blacklist.conf)\nfor more ideas.\n\n---\n\n## Hardened Memory Allocator\n\n> NOTE: There is a performance cost to enabling a hardened memory allocator, and\n> some apps will not work without a workaround such as Firefox, Thunderbird,\n> Torbrowser, LibreWolf, and ZenBrowser to name a few.\n\nWith memory corruption bugs being the leading zero day category, it's clearly\nsomething that you should be concerned with.\n\nThe grapheneOS `hardened_malloc` is available for NixOS in two variants, add\neither to your `configuration.nix` or equivalent to apply them:\n\n1. `environment.memoryAllocator.provider = \"graphene-hardened\";`: This is the\n   default configuration template that has all normal optional security features\n   enabled. It's aggressive, you can expect app breakage and a performance cost.\n\n2. `environment.memoryAllocator.provider = \"graphene-hardened-light\";`: The\n   light template disables the slap quarantines, write after free check, slot\n   randomization and raises the guard slab interval from 1 to 8 but leaves\n   zero-on-free and slab canaries enabled. This version has solid performance\n   and is still far more secure than the standard allocator.\n\n`libhardened_malloc.so` is typically installed to\n`/usr/local/lib/libhardened_malloc.so` and referenced from `/etc/ld.so.preload`.\n\n- [NixOS Manual memoryAllocator](https://nixos.org/manual/nixos/stable/options#opt-environment.memoryAllocator.provider)\n\n- [GrapheneOS hardened_malloc](https://github.com/GrapheneOS/hardened_malloc?tab=readme-ov-file#traditional-linux-based-operating-systems)\n\n- [GrapheneOS/secureblue discussion on hardened_malloc issues](https://github.com/secureblue/secureblue/issues/193#issuecomment-1953323680)\n\n- [ld.so man page](https://man7.org/linux/man-pages/man8/ld.so.8.html)\n\n- [Exploring hardened_malloc](https://www.synacktiv.com/en/publications/exploring-grapheneos-secure-allocator-hardened-malloc)\n\n---\n\n## Hardening Systemd\n\n<!-- ![Hacker](../images/hacker.png) -->\n\n`systemd` is the core \"init system\" and service manager that controls how\nservices, daemons, and basic system processes are started, stopped and\nsupervised on modern Linux distributions, including NixOS. It provides a suite\nof basic building blocks for a Linux system as well as a system and service\nmanager that runs as `PID 1` and starts the rest of the system.\n\nBecause it launches and supervises almost all system services, hardening systemd\nmeans raising the baseline security of your entire system.\n\nDisable coredumps:\n\n```nix\nsystemd.coredump.enable = false;\n# ➡️ Sets the kernel's resource limit (ulimit -c 0)\n  security.pam.loginLimits = [\n    {\n      domain = \"*\"; # Applies to all users/sessions\n      type = \"-\"; # Set both soft and hard limits\n      item = \"core\"; # The soft/hard limit item\n      value = \"0\";   # Core dumps size is limited to 0 (effectively disabled)\n    }\n  ];\n```\n\nDisabling coredumps helps save space and improves security/privacy because when\na program fails, a coredump contains an exact copy of a programs running memory\nat the time of the crash. This can inadvertently expose sensitive data.\n\nIf a program is handling private information when it crashes, the core dump file\ncould contain:\n\n- **Passwords**: Stored in memory before being sent or hashed.\n\n- **Encryption Keys**: Used for securing network connections.\n\n- **Personal Info**: Chat messages, website forms, etc.\n\nIt can give a minor performance upgrade and does reduce the attack surface. If a\nmalicious program were to gain access to your system, one of the first things it\nmight look for are core dump files to extract sensitive data. By disabling them,\nyou eliminate this potential source of information leakage.\n\n`dbus-broker` is generally considered more secure and robust but isn't the\ndefault as of yet. To set `dbus-broker` as the default:\n\n```nix\n  users.groups.netdev = {};\n  services = {\n    dbus.implementation = \"broker\";\n    logrotate.enable = true;\n    journald = {\n      storage = \"volatile\"; # Store logs in memory\n      upload.enable = false; # Disable remote log upload (the default)\n      extraConfig = ''\n        SystemMaxUse=500M\n        SystemMaxFileSize=50M\n      '';\n    };\n  };\n```\n\n- `dbus-broker` is more resilient to resource exhaustion attacks and integrates\n  better with Linux security features.\n\n- [Rethinking-the-dbus-message-bus](https://dvdhrm.github.io/rethinking-the-dbus-message-bus/)\n\n- Setting `storage = \"volatile\"` tells journald to keep log data only in memory.\n  There is a tradeoff though, If you need long-term auditing or troubleshooting\n  after a reboot, this will not preserve system logs.\n\n- `upload.enable` is for forwarding log messages to remote servers, setting this\n  to false prevents accidental leaks of potentially sensitive or internal system\n  information.\n\n- Enabling `logrotate` prevents your disk from filling with excessive\n  **legacy/service** log files. These are the classic plain-text logs.\n\n- Systemd uses `journald` which stores logs in a binary format\n\nYou can check the security status with:\n\n```bash\nsystemd-analyze security\n# or for a detailed view of individual services security posture\nsystemd-analyze security NetworkManager\n```\n\nOptionally disable vulnerable services to reduce the attack surface, obviously\ndon't disable what you need, or change your habits:\n\n```nix\nservices = {\n    # mDNS/DNS-SD\n    avahi.enable = false;\n    # Geoclue (location services)\n    geoclue2.enable = false;\n    udisks2.enable = false;\n    accounts-daemon.enable = false;\n  };\n  # Only needed for WWAN/3G/4G modems, otherwise it runs `mmcli` unnecessarily\n  networking.modemmanager.enable = false;\n  # Bluetooth has a long history of vulnerabilities\n  hardware.bluetooth.enable = false;\n  # Prefer manual upgrades on a hardened system\n  system.autoUpgrade.enable = false;\n```\n\nFurther reading on systemd:\n\n<details>\n<summary> ✔️ Click to Expand Systemd Resources </summary>\n\n- [systemd.io](https://systemd.io/)\n\n- [Rethinking PID 1](https://0pointer.de/blog/projects/systemd.html)\n\n- [Biggest Myths about Systemd](https://0pointer.de/blog/projects/the-biggest-myths.html)\n\n</details>\n\nThe following is a repo containing many of the Systemd hardening settings in\nNixOS format:\n\n[nix-system-services-hardened](https://github.com/wallago/nix-system-services-hardened)\n\nFor example, to harden bluetooth you could add the following to your\n`configuration.nix` or equivalent:\n\n```nix\nsystemd.services = {\n      bluetooth.serviceConfig = {\n      ProtectKernelTunables = lib.mkDefault true;\n      ProtectKernelModules = lib.mkDefault true;\n      ProtectKernelLogs = lib.mkDefault true;\n      ProtectHostname = true;\n      ProtectControlGroups = true;\n      ProtectProc = \"invisible\";\n      SystemCallFilter = [\n        \"~@obsolete\"\n        \"~@cpu-emulation\"\n        \"~@swap\"\n        \"~@reboot\"\n        \"~@mount\"\n      ];\n      SystemCallArchitectures = \"native\";\n    };\n}\n```\n\nAs you can see from above, you typically use the `serviceConfig` attribute to\nharden settings for systemd services.\n\n```bash\nsystemd-analyze security bluetooth\n→ Overall exposure level for bluetooth.service: 3.3 OK 🙂\n```\n\n<details>\n<summary> Click to expand `systemd.nix` example implementing many of the recommendations </summary>\n\n```nix\n{lib, ...}: {\n  systemd.services = {\n    # \"home-manager-jr\".after = [\"network-online.target\"];\n    # \"home-manager-jr\".wantedBy = [\"multi-user.target\"];\n    \"user@\".serviceConfig = {\n      ProtectSystem = \"strict\";\n      ProtectClock = true;\n      ProtectHostname = true;\n      ProtectKernelTunables = true;\n      ProtectKernelModules = true;\n      ProtectKernelLogs = true;\n      ProtectProc = \"invisible\";\n      PrivateTmp = true;\n      PrivateNetwork = true;\n      MemoryDenyWriteExecute = false;\n      RestrictAddressFamilies = [\n        \"AF_UNIX\"\n        \"AF_NETLINK\"\n        \"AF_BLUETOOTH\"\n      ];\n      RestrictNamespaces = true;\n      RestrictRealtime = true;\n      RestrictSUIDSGID = true;\n      SystemCallFilter = [\n        \"~@keyring\"\n        \"~@swap\"\n        \"~@debug\"\n        \"~@module\"\n        \"~@obsolete\"\n        \"~@cpu-emulation\"\n      ];\n      SystemCallArchitectures = \"native\";\n    };\n    acpid.serviceConfig = {\n      ProtectSystem = \"full\";\n      ProtectHome = true;\n      RestrictAddressFamilies = [\"AF_INET\" \"AF_INET6\"];\n      SystemCallFilter = \"~@clock @cpu-emulation @debug @module @mount @raw-io @reboot @swap\";\n      ProtectKernelTunables = true;\n      ProtectKernelModules = true;\n    };\n\n    auditd.serviceConfig = {\n      NoNewPrivileges = true;\n      ProtectSystem = \"full\";\n      ProtectHome = true;\n      ProtectHostname = true;\n      ProtectKernelTunables = true;\n      ProtectKernelModules = true;\n      ProtectControlGroups = true;\n      ProtectProc = \"invisible\";\n      ProtectClock = true;\n      PrivateTmp = true;\n      PrivateNetwork = true;\n      PrivateMounts = true;\n      PrivateDevices = true;\n      RestrictNamespaces = true;\n      RestrictRealtime = true;\n      RestrictSUIDSGID = true;\n      RestrictAddressFamilies = [\n        \"~AF_INET6\"\n        \"~AF_INET\"\n        \"~AF_PACKET\"\n      ];\n      MemoryDenyWriteExecute = true;\n      LockPersonality = true;\n      SystemCallFilter = [\n        \"~@clock\"\n        \"~@module\"\n        \"~@mount\"\n        \"~@swap\"\n        \"~@obsolete\"\n        \"~@cpu-emulation\"\n      ];\n      SystemCallArchitectures = \"native\";\n      CapabilityBoundingSet = [\n        \"~CAP_CHOWN\"\n        \"~CAP_FSETID\"\n        \"~CAP_SETFCAP\"\n      ];\n    };\n\n    cups.serviceConfig = {\n      NoNewPrivileges = true;\n      ProtectSystem = \"full\";\n      ProtectHome = true;\n      ProtectKernelModules = true;\n      ProtectKernelTunables = true;\n      ProtectKernelLogs = true;\n      ProtectControlGroups = true;\n      ProtectHostname = true;\n      ProtectClock = true;\n      ProtectProc = \"invisible\";\n      RestrictRealtime = true;\n      RestrictNamespaces = true;\n      RestrictSUIDSGID = true;\n      RestrictAddressFamilies = [\n        \"AF_UNIX\"\n        \"AF_NETLINK\"\n        \"AF_INET\"\n        \"AF_INET6\"\n        \"AF_PACKET\"\n      ];\n\n      MemoryDenyWriteExecute = true;\n      SystemCallFilter = [\n        \"~@clock\"\n        \"~@reboot\"\n        \"~@debug\"\n        \"~@module\"\n        \"~@swap\"\n        \"~@obsolete\"\n        \"~@cpu-emulation\"\n      ];\n      SystemCallArchitectures = \"native\";\n      LockPersonality = true;\n    };\n\n    NetworkManager.serviceConfig = {\n      NoNewPrivileges = true;\n      ProtectHome = true;\n      ProtectKernelModules = true;\n      ProtectKernelLogs = true;\n      ProtectControlGroups = true;\n      ProtectClock = true;\n      ProtectHostname = true;\n      ProtectProc = \"invisible\";\n      PrivateTmp = true;\n      RestrictRealtime = true;\n      RestrictAddressFamilies = [\n        \"AF_UNIX\"\n        \"AF_NETLINK\"\n        \"AF_INET\"\n        \"AF_INET6\"\n        \"AF_PACKET\"\n      ];\n      RestrictNamespaces = true;\n      RestrictSUIDSGID = true;\n      MemoryDenyWriteExecute = true;\n      SystemCallFilter = [\n        \"~@mount\"\n        \"~@module\"\n        \"~@swap\"\n        \"~@obsolete\"\n        \"~@cpu-emulation\"\n        \"ptrace\"\n      ];\n      SystemCallArchitectures = \"native\";\n      LockPersonality = true;\n    };\n\n    wpa_supplicant.serviceConfig = {\n      NoNewPrivileges = true;\n      ProtectSystem = \"strict\";\n      ProtectHome = true;\n      ProtectKernelModules = true;\n      ProtectKernelLogs = true;\n      ProtectControlGroups = true;\n      ProtectClock = true;\n      ProtectHostname = true;\n      ProtectProc = \"invisible\";\n      PrivateTmp = true;\n      PrivateMounts = true;\n      RestrictRealtime = true;\n      RestrictAddressFamilies = [\n        \"AF_UNIX\"\n        \"AF_NETLINK\"\n        \"AF_INET\"\n        \"AF_INET6\"\n        \"AF_PACKET\"\n      ];\n      RestrictNamespaces = true;\n      RestrictSUIDSGID = true;\n      MemoryDenyWriteExecute = true;\n      SystemCallFilter = [\n        \"~@mount\"\n        \"~@raw-io\"\n        \"~@privileged\"\n        \"~@keyring\"\n        \"~@reboot\"\n        \"~@module\"\n        \"~@swap\"\n        \"~@resources\"\n        \"~@obsolete\"\n        \"~@cpu-emulation\"\n        \"ptrace\"\n      ];\n      SystemCallArchitectures = \"native\";\n      LockPersonality = true;\n      CapabilityBoundingSet = \"CAP_NET_ADMIN CAP_NET_RAW\";\n    };\n\n    dbus.serviceConfig = {\n      NoNewPrivileges = true;\n      ProtectSystem = \"stric\";\n      ProtectControlGroups = true;\n      ProtectHome = true;\n      ProtectHostname = true;\n      ProtectKernelTunables = true;\n      ProtectKernelModules = true;\n      ProtectKernelLogs = true;\n      PrivateMounts = true;\n      PrivateDevices = true;\n      PrivateTmp = true;\n      RestrictSUIDSGID = true;\n      RestrictRealtime = true;\n      RestrictAddressFamilies = [\n        \"AF_UNIX\"\n      ];\n      RestrictNamespaces = true;\n      SystemCallErrorNumber = \"EPERM\";\n      SystemCallArchitectures = \"native\";\n      SystemCallFilter = [\n        \"~@obsolete\"\n        \"~@resources\"\n        \"~@debug\"\n        \"~@mount\"\n        \"~@reboot\"\n        \"~@swap\"\n        \"~@cpu-emulation\"\n      ];\n      LockPersonality = true;\n      IPAddressDeny = [\"0.0.0.0/0\" \"::/0\"];\n      MemoryDenyWriteExecute = true;\n      DevicePolicy = \"closed\";\n      UMask = 0077;\n    };\n\n    nscd.serviceConfig = {\n      ProtectClock = true;\n      ProtectHostname = true;\n      ProtectKernelTunables = true;\n      ProtectKernelModules = true;\n      ProtectKernelLogs = true;\n      ProtectControlGroups = true;\n      ProtectProc = \"invisible\";\n      RestrictNamespaces = true;\n      RestrictRealtime = true;\n      MemoryDenyWriteExecute = true;\n      LockPersonality = true;\n      SystemCallFilter = [\n        \"~@mount\"\n        \"~@swap\"\n        \"~@clock\"\n        \"~@obsolete\"\n        \"~@cpu-emulation\"\n      ];\n      SystemCallArchitectures = \"native\";\n      CapabilityBoundingSet = [\n        \"~CAP_CHOWN\"\n        \"~CAP_FSETID\"\n        \"~CAP_SETFCAP\"\n      ];\n    };\n    bluetooth.serviceConfig = {\n      ProtectKernelTunables = lib.mkDefault true;\n      ProtectKernelModules = lib.mkDefault true;\n      ProtectKernelLogs = lib.mkDefault true;\n      ProtectHostname = true;\n      ProtectControlGroups = true;\n      ProtectProc = \"invisible\";\n      SystemCallFilter = [\n        \"~@obsolete\"\n        \"~@cpu-emulation\"\n        \"~@swap\"\n        \"~@reboot\"\n        \"~@mount\"\n      ];\n      SystemCallArchitectures = \"native\";\n    };\n    systemd-rfkill.serviceConfig = {\n      ProtectSystem = \"strict\";\n      ProtectHome = true;\n      ProtectKernelTunables = true;\n      ProtectKernelModules = true;\n      ProtectControlGroups = true;\n      ProtectClock = true;\n      ProtectProc = \"invisible\";\n      ProcSubset = \"pid\";\n      PrivateTmp = true;\n      MemoryDenyWriteExecute = true;\n      NoNewPrivileges = true;\n      LockPersonality = true;\n      RestrictRealtime = true;\n      SystemCallArchitectures = \"native\";\n      UMask = \"0077\";\n      IPAddressDeny = \"any\";\n    };\n    systemd-machined.serviceConfig = {\n      NoNewPrivileges = true;\n      ProtectSystem = \"strict\";\n      ProtectHome = true;\n      ProtectClock = true;\n      ProtectHostname = true;\n      ProtectKernelTunables = true;\n      ProtectKernelModules = true;\n      ProtectKernelLogs = true;\n      ProtectProc = \"invisible\";\n      PrivateTmp = true;\n      PrivateMounts = true;\n      PrivateUsers = true;\n      PrivateNetwork = true;\n      RestrictNamespaces = true;\n      RestrictRealtime = true;\n      RestrictSUIDSGID = true;\n      RestrictAddressFamilies = [\"AF_UNIX\"];\n      MemoryDenyWriteExecute = true;\n      SystemCallArchitectures = \"native\";\n    };\n    systemd-udevd.serviceConfig = {\n      NoNewPrivileges = true;\n      ProtectSystem = \"strict\";\n      ProtectHome = true;\n      ProtectKernelLogs = true;\n      ProtectControlGroups = true;\n      ProtectClock = true;\n      ProtectProc = \"invisible\";\n      RestrictNamespaces = true;\n      CapabilityBoundingSet = \"~CAP_SYS_PTRACE ~CAP_SYS_PACCT\";\n    };\n    nix-daemon.serviceConfig = {\n      NoNewPrivileges = true;\n      ProtectControlGroups = true;\n      ProtectKernelModules = true;\n      PrivateMounts = true;\n      PrivateTmp = true;\n      PrivateDevices = true;\n      RestrictSUIDSGID = true;\n      RestrictRealtime = true;\n      RestrictNamespaces = [\"~cgroup\"];\n      RestrictAddressFamilies = [\n        \"AF_UNIX\"\n        \"AF_NETLINK\"\n        \"AF_INET6\"\n        \"AF_INET\"\n      ];\n      CapabilityBoundingSet = [\n        \"~CAP_SYS_CHROOT\"\n        \"~CAP_BPF\"\n        \"~CAP_AUDIT_WRITE\"\n        \"~CAP_AUDIT_CONTROL\"\n        \"~CAP_AUDIT_READ\"\n        \"~CAP_SYS_PTRACE\"\n        \"~CAP_SYS_NICE\"\n        \"~CAP_SYS_RESOURCE\"\n        \"~CAP_SYS_RAWIO\"\n        \"~CAP_SYS_TIME\"\n        \"~CAP_SYS_PACCT\"\n        \"~CAP_LINUX_IMMUTABLE\"\n        \"~CAP_IPC_LOCK\"\n        \"~CAP_WAKE_ALARM\"\n        \"~CAP_SYS_TTY_CONFIG\"\n        \"~CAP_SYS_BOOT\"\n        \"~CAP_LEASE\"\n        \"~CAP_BLOCK_SUSPEND\"\n        \"~CAP_MAC_ADMIN\"\n        \"~CAP_MAC_OVERRIDE\"\n      ];\n      SystemCallErrorNumber = \"EPERM\";\n      SystemCallArchitectures = \"native\";\n      SystemCallFilter = [\n        \"~@resources\"\n        \"~@module\"\n        \"~@obsolete\"\n        \"~@debug\"\n        \"~@reboot\"\n        \"~@swap\"\n        \"~@cpu-emulation\"\n        \"~@clock\"\n        \"~@raw-io\"\n      ];\n      LockPersonality = true;\n      MemoryDenyWriteExecute = false;\n      DevicePolicy = \"closed\";\n      UMask = 0077;\n    };\n    systemd-journald.serviceConfig = {\n      NoNewPrivileges = true;\n      ProtectProc = \"invisible\";\n      ProtectHostname = true;\n      PrivateMounts = true;\n    };\n  };\n}\n```\n\n</details>\n\n---\n\n## Lynis and other tools\n\nLynis is a security auditing tool for systems based on UNIX like Linux, macOS,\nBSD, and others.--[lynis repo](https://github.com/CISOfy/lynis)\n\n`chkrootkit` was removed as it is unmaintained and archived upstream.\n\nInstallation:\n\n```nix\nenvironment.systemPackages = [\npkgs.lynis\npkgs.clamav\npkgs.aide\n ];\n```\n\n<details>\n<summary> ✔️ Click to Expand AIDE Example </summary>\n\nAIDE is an intrusion detection system (IDS) that will notify us whenever it\ndetects that a potential intrusion has occurred. When a system is compromised,\nattackers typically will try to change file permissions and escalate to the root\nuser account and start to modify system files, AIDE can detect this.\n\nTo set up AIDE on your system follow these steps:\n\n1. Create the `aide.conf`:\n\n```bash\nsudo mkdir -p /var/lib/aide && cd /var/lib/aide/\nsudo hx aide.conf\n```\n\nAdd the following content to `/var/lib/aide/aide.conf`:\n\n```conf\n# aide.conf\n# Example configuration file for AIDE.\n\n@@define DBDIR /var/lib/aide\n\n# The location of the database to be read.\ndatabase_in=file:@@{DBDIR}/aide.db.gz\n\n# The location of the database to be written.\n#database_out=sql:host:port:database:login_name:passwd:table\n#database_out=file:aide.db.new\ndatabase_out=file:@@{DBDIR}/aide.db.new.gz\n\n# Whether to gzip the output to database\ngzip_dbout=yes\n\nlog_level=info\n\nreport_url=file:/var/log/aide/aide.log\nreport_url=stdout\n#report_url=stderr\n#NOT IMPLEMENTED report_url=mailto:root@foo.com\n#NOT IMPLEMENTED report_url=syslog:LOG_AUTH\n\n# These are the default rules.\n#\n#p:      permissions\n#i:      inode:\n#n:      number of links\n#u:      user\n#g:      group\n#s:      size\n#b:      block count\n#m:      mtime\n#a:      atime\n#c:      ctime\n#S:      check for growing size\n#md5:    md5 checksum\n#sha1:   sha1 checksum\n#rmd160: rmd160 checksum\n#tiger:  tiger checksum\n#haval:  haval checksum\n#gost:   gost checksum\n#crc32:  crc32 checksum\n#R:      p+i+n+u+g+s+m+c+md5\n#L:      p+i+n+u+g\n#E:      Empty group\n#>:      Growing logfile p+u+g+i+n+S\n\n# You can create custom rules like this.\n\nNORMAL = R+b+sha512\n\nDIR = p+i+n+u+g\n\n# Next decide what directories/files you want in the database.\n\n/boot   NORMAL\n/bin    NORMAL\n/sbin   NORMAL\n/lib    NORMAL\n/opt    NORMAL\n/usr    NORMAL\n/root   NORMAL\n\n# Check only permissions, inode, user and group for /etc, but\n# cover some important files closely.\n/etc    p+i+u+g\n!/etc/mtab\n/etc/exports  NORMAL\n/etc/fstab    NORMAL\n/etc/passwd   NORMAL\n/etc/group    NORMAL\n/etc/gshadow  NORMAL\n/etc/shadow   NORMAL\n\n/var/log   p+n+u+g\n\n# With AIDE's default verbosity level of 5, these would give lots of\n# warnings upon tree traversal. It might change with future version.\n#\n#=/lost\\+found    DIR\n#=/home           DIR\n```\n\nCreate the logfile:\n\n```bash\nsudo mkdir -p /var/log/aide\nsudo touch /var/log/aide/aide.log\n```\n\n2. Generate the initial database, this will store the checksums of all files\n   that it's configured to monitor. Take note of the location of the new\n   database, mine was `/etc/aide.db.new`\n\n```bash\nsudo aide --config /var/lib/aide/aide.conf --init\n```\n\n3. Move the new database and remove the `.new`:\n\n```bash\nsudo mv /var/lib/aide/aide.db.new.gz /var/lib/aide/aide.db.gz\n```\n\n```bash\nls /var/lib/aide/\naide.conf   aide.db.gz\n```\n\n4. Check with AIDE:\n\n```bash\nsudo aide --check --config /var/lib/aide/aide.conf\nStart timestamp: 2025-09-05 09:50:07 -0400 (AIDE 0.19.2)\nAIDE found NO differences between database and filesystem. Looks okay!!\n```\n\n5. Whenever you make changes to system files, or especially after running a\n   system update or installing new tools, you have to rescan all files to update\n   their checksums in the AIDE database:\n\n```bash\nsudo aide --update --config /var/lib/aide/aide.conf\n```\n\nUnfortunately, AIDE doesn't automatically replace the old database so you have\nto rename the new one again:\n\n```bash\nsudo mv /var/lib/aide/aide.db.new.gz /var/lib/aide/aide.db.gz\n```\n\nAnd finally check again:\n\n```bash\nsudo aide --check --config /var/lib/aide/aide.conf\n```\n\n- [aide(1) man page](https://linux.die.net/man/1/aide)\n\n</details>\n\n<details>\n<summary> ✔️ Click to Expand clamav.nix Example </summary>\n\n```nix\n{pkgs, ...}: {\n  environment.systemPackages = with pkgs; [\n    clamav\n  ];\n  services.clamav = {\n    # Enable clamd daemon\n    daemon.enable = true;\n    updater.enable = true;\n    updater.frequency = 12; # Number of database checks per day\n    scanner = {\n      enable = true;\n      # 4:00 AM\n      interval = \"*-*-* 04:00:00\";\n      scanDirectories = [\n        \"/home\"\n        \"/var/lib\"\n        \"/tmp\"\n        \"/etc\"\n        \"/var/tmp\"\n      ];\n    };\n  };\n}\n```\n\n</details>\n\nLynis Usage:\n\n```bash\nsudo lynis show commands\n# Output:\nCommands:\nlynis audit\nlynis configure\nlynis generate\nlynis show\nlynis update\nlynis upload-only\n\nsudo lynis audit system\n# Output:\n  Lynis security scan details:\n\n  Hardening index : 79 [###############     ]\n  Tests performed : 234\n  Plugins enabled : 0\n\n  Components:\n  - Firewall               [V]\n  - Malware scanner        [V]\n\n  Scan mode:\n  Normal [V]  Forensics [ ]  Integration [ ]  Pentest [ ]\n\n  Lynis modules:\n  - Compliance status      [?]\n  - Security audit         [V]\n  - Vulnerability scan     [V]\n```\n\n- The \"Lynis hardening index\" is an overall impression on how well a system is\n  hardened. However, this is just an indicator on measures taken - not a\n  percentage of how safe a system might be. A score over 75 typically indicates\n  a system with more than average safety measures implemented.\n\n- Lynis will give you more recommendations for securing your system as well.\n\nIf you use `clamscan`, create the following log file:\n\n```bash\nsudo touch /var/log/clamscan.log\n```\n\nExample cron job for `clamav` & `aide`:\n\n```nix\n{pkgs, ...}: {\n  services.cron = {\n    enable = true;\n    # messages.enable = true;\n    systemCronJobs = [\n      # Every day at 2:00 AM, run clamscan as root and append output to a log file\n      \"0 2 * * * root ${pkgs.clamav}/bin/clamscan -r /home >> /var/log/clamscan.log\"\n      \"0 11 * * * ${pkgs.aide}/bin/aide --check --config /var/lib/aide/aide.conf\"\n    ];\n  };\n}\n```\n\nClamAV usage:\n\nYou can run `clamav` manually with:\n\n```bash\n# Recursive Scan:\nsudo clamscan -r ~/home\n```\n\n> ❗ NOTE: You only need either the individual `pkgs.clamav` with the cron job\n> **OR** the `clamd-daemon` module. `clamdscan` is for software integration and\n> uses a different user that doesn't have permission to scan your files. You can\n> use `clamdscan --fdpass /path/to/scan` to pass the necessary file permissions.\n> NOTE: `clamdscan` runs in the background, you can watch it with `top`.\n\n## Securing SSH\n\n> **Security information**: Changing SSH configuration settings can\n> significantly impact the security of your system(s). It is crucial to have a\n> solid understanding of what you are doing before making any adjustments. Avoid\n> blindly copying and pasting examples, including those from this Wiki page,\n> without conducting a thorough analysis. Failure to do so may compromise the\n> security of your system(s) and lead to potential vulnerabilities. Take the\n> time to comprehend the implications of your actions and ensure that any\n> changes made are done thoughtfully and with care. --NixOS Wiki\n\n> ❗ NOTE: Choose one, either `ssh-agent` or `gpg-agent`\n\n1. Use normal SSH keys generated with `ssh-keygen`, this is recommended unless\n   you have a good reason for not using it.\n\n**OR**\n\n2. Use a GPG key with `gpg-agent` (which acts as your SSH agent). Complex, and\n   harder to understand in my opinion.\n\nMy setup caused conflicts when enabling `programs.ssh.startAgent` so I chose\n`gpg-agent` personally.\n\nThere are situations where you are required to use one or the other like for\nheadless CI/CD environments, `ssh-keygen` is required.\n\n- [Click Here for GnuPG and gpg-agent chapter](https://saylesss88.github.io/nix/gpg-agent.html)\n\nFurther reading:\n\n<details>\n<summary> ✔️ Click to Expand Resourses on OpenSSH </summary>\n\n- [Arch Wiki OpenSSH](https://wiki.archlinux.org/title/OpenSSH)\n\n- [Gentoo GnuPG](https://wiki.gentoo.org/wiki/GnuPG)\n\n- [A Visual Explanation of GPG Subkeys](https://rgoulter.com/blog/posts/programming/2022-06-10-a-visual-explanation-of-gpg-subkeys.html)\n\n- [Secure Secure Shell](https://blog.stribik.technology/2015/01/04/secure-secure-shell.html)\n\n</details>\n\n---\n\n## Key generation\n\n### ssh-keygen\n\nThe `ed25519` algorithm is significantly faster and more secure when compared to\n`RSA`. You can also specify the key derivation function (KDF) rounds to\nstrengthen protection even more.\n\nFor example, to generate a strong key for GitHub:\n\n```bash\nssh-keygen -t ed25519 -a 32 -f ~/.ssh/id_ed25519_github_$(date +%Y-%m-%d) -C \"SSH Key for GitHub\"\n```\n\n- `-t` is for type\n\n- `-a 32` sets the number of KDF rounds. The standard is usually good enough,\n  adding extra rounds can make it harder to brute-force.\n\n- `-f` is for filename\n\n### OpenSSH Server\n\nFirst of all, if you don't use SSH don't enable it in the first place. If you do\nuse SSH, it's important to understand what that opens you up to.\n\nThe following are some recommendations from Mozilla on OpenSSH:\n\n- [Mozilla OpenSSH guidelines](https://infosec.mozilla.org/guidelines/openssh.html)\n\nThe following OpenSSH setup is based on the above guidelines with strong\nalgorithms, and best practices: (EDITED: 10-07-25 to follow best-practices on\npost-quantum crypto)\n\n```nix\n{config, ...}: {\n  config = {\n    services = {\n      fail2ban = {\n        enable = true;\n        maxretry = 5;\n        bantime = \"1h\";\n        # ignoreIP = [\n        # \"172.16.0.0/12\"\n        # \"192.168.0.0/16\"\n        # \"2601:881:8100:8de0:31e6:ac52:b5be:462a\"\n        # \"matrix.org\"\n        # \"app.element.io\" # don't ratelimit matrix users\n        # ];\n\n        bantime-increment = {\n          enable = true; # Enable increment of bantime after each violation\n          multipliers = \"1 2 4 8 16 32 64 128 256\";\n          maxtime = \"168h\"; # Do not ban for more than 1 week\n          overalljails = true; # Calculate the bantime based on all the violations\n        };\n      };\n      openssh = {\n        enable = true;\n        settings = {\n          PasswordAuthentication = false;\n          PermitEmptyPasswords = false;\n          PermitTunnel = false;\n          UseDns = false;\n          KbdInteractiveAuthentication = false;\n          X11Forwarding = config.services.xserver.enable;\n          MaxAuthTries = 3;\n          MaxSessions = 2;\n          ClientAliveInterval = 300;\n          ClientAliveCountMax = 0;\n          AllowUsers = [\"your-user\"];\n          TCPKeepAlive = false;\n          AllowTcpForwarding = false;\n          AllowAgentForwarding = false;\n          LogLevel = \"VERBOSE\";\n          PermitRootLogin = \"no\";\n          KexAlgorithms = [\n            # Post-Quantum: https://www.openssh.org/pq.html\n            \"mlkem768x25519-sha256\"\n            \"sntrup761x25519-sha512\"\n            \"curve25519-sha256@libssh.org\"\n            \"ecdh-sha2-nistp521\"\n            \"ecdh-sha2-nistp384\"\n            \"ecdh-sha2-nistp256\"\n            \"diffie-hellman-group-exchange-sha256\"\n          ];\n          Ciphers = [\n            \"aes256-gcm@openssh.com\"\n            \"aes128-gcm@openssh.com\"\n            # stream cipher alternative to aes256, proven to be resilient\n            # Very fast on basically anything\n            \"chacha20-poly1305@openssh.com\"\n            # industry standard, fast if you have AES-NI hardware\n            \"aes256-ctr\"\n            \"aes192-ctr\"\n            \"aes128-ctr\"\n          ];\n          Macs = [\n            # Combines the SHA-512 hash func with a secret key to create a MAC\n            \"hmac-sha2-512-etm@openssh.com\"\n            \"hmac-sha2-256-etm@openssh.com\"\n            \"umac-128-etm@openssh.com\"\n            \"hmac-sha2-512\"\n            \"hmac-sha2-256\"\n            \"umac-128@openssh.com\"\n          ];\n        };\n        # These keys will be generated for you\n        hostKeys = [\n          {\n            path = \"/etc/ssh/ssh_host_ed25519_key\";\n            type = \"ed25519\";\n          }\n        ];\n      };\n    };\n  };\n}\n```\n\nTCP port 22 (ssh) is opened automatically if the SSH daemon is enabled\n(`services.openssh.enable = true;`)\n\nMuch of the SSH hardening settings came from\n[ryanseipp's secure-ssh Guide](https://ryanseipp.com/post/nixos-secure-ssh/)\nwith some additions of my own.\n\nFail2Ban is an intrusion prevention software framework. It's designed to prevent\nbrute-force attacks by scanning log files for suspicious activity, such as\nrepeated failed login attempts.\n\nOpenSSH is the primary tool for secure remote access for NixOS. Enabling it\nactivates the OpenSSH server on the system, allowing incoming SSH connections.\n\nThe above configuration is a robust setup for securing an SSH server by:\n\n- Preventing brute-force attacks with Fail2Ban\n\n- Eliminating password authentication in favor of more secure SSH keys\n\n- Restricting user access and preventing root login\n\n- Disabling potentially risky forwarding features (tunnel, TCP, agent)\n\n- Enforce the use of strong, modern cryptographic algorithms for all SSH\n  communications.\n\n- Enhanced logging for better auditing.\n\nFurther Reading:\n\n- [OpenSSH](https://www.openssh.com/)\n\n- [DigitalOcean how fail2ban works](https://www.digitalocean.com/community/tutorials/how-fail2ban-works-to-protect-services-on-a-linux-server)\n\n---\n\n## Encrypted Secrets\n\nNever store secrets in plain text in repositories. Use something like\n[sops-nix](https://github.com/Mic92/sops-nix), which lets you keep encrypted\nsecrets under version control declaratively.\n\nAnother option is [agenix](https://github.com/ryantm/agenix)\n\n- [NixOS Wiki Agenix](https://wiki.nixos.org/wiki/Agenix)\n\n### Sops-nix Guide\n\nProtect your secrets, the following guide is on setting up Sops on NixOS:\n[Sops Encrypted Secrets](https://saylesss88.github.io/installation/enc/sops-nix.html)\n\n---\n\n## Auditd\n\nTo enable the Linux Audit Daemon (`auditd`) and define a very basic rule set,\nyou can use the following NixOS configuration. This example demonstrates how to\nlog every program execution (`execve`) on a 64-bit architecture.\n\n```nix\n# modules/security/auditd-minimal.nix (or directly in configuration.nix)\n{\n  # start as early in the boot process as possible\n  boot.kernelParams = [\"audit=1\"];\n  security.auditd.enable = true;\n  security.audit.enable = true;\n  security.audit.rules = [\n    # Log all program executions on 64-bit architecture\n    \"-a exit,always -F arch=b64 -S execve\"\n  ];\n}\n```\n\n- `audit=1` Enables auditing at the kernel level very early in the boot process.\n  Without this, some events could be missed.\n\n- `security.auditd.enable = true;` Ensures the `auditd` userspace daemon is\n  started.\n\n- While often enabled together, `security.audit.enable` specifically refers to\n  enabling the NixOS module for audit rules generation.\n\n- `execve` (program executions)\n\n- This is just a basic configuration, there is much more that can be tracked.\n\n---\n\n## USB Port Protection\n\nIt's important to protect your USB ports to prevent BadUSB attacks, data\nexfiltration, unauthorized device access, malware injection, etc.\n\nTo get a list of your connected USB devices you can use `lsusb` from the\n`usbutils` package.\n\n```bash\nlsusb\n```\n\nTo list the devices recognized by USBGuard, run:\n\n```bash\nsudo usbguard list-devices\n```\n\n- [MyNixOS services.usbguard](https://mynixos.com/options/services.usbguard)\n\nChange `your-user` to your username:\n\n```nix\n# usbguard.nix\n{\n  config,\n  pkgs,\n  lib,\n  ...\n}: let\n  inherit (lib) mkIf;\n  cfg = config.custom.security.usbguard;\nin {\n  options.custom.security.usbguard = {\n    enable = lib.mkEnableOption \"usbguard\";\n  };\n\n  config = mkIf cfg.enable {\n    services.usbguard = {\n      enable = true;\n      IPCAllowedUsers = [\"root\" \"your-user\"];\n    # presentDevicePolicy refers to how to treat USB devices that are already connected when the daemon starts\n      presentDevicePolicy = \"allow\";\n      rules = ''\n        # allow `only` devices with mass storage interfaces (USB Mass Storage)\n        allow with-interface equals { 08:*:* }\n        # allow mice and keyboards\n        # allow with-interface equals { 03:*:* }\n\n        # Reject devices with suspicious combination of interfaces\n        reject with-interface all-of { 08:*:* 03:00:* }\n        reject with-interface all-of { 08:*:* 03:01:* }\n        reject with-interface all-of { 08:*:* e0:*:* }\n        reject with-interface all-of { 08:*:* 02:*:* }\n      '';\n    };\n\n    environment.systemPackages = [pkgs.usbguard];\n  };\n}\n```\n\nThe above settings can be found in\n[RedHat UsbGuard](https://docs.redhat.com/en/documentation/red_hat_enterprise_linux/7/html/security_guide/sec-using-usbguard)\n\nThe only `allow` rule is for devices with **only** mass storage interfaces\n(`08:*:*`) i.e., USB Mass storage devices, devices like keyboards and mice\n(which use interface class `03:*:*`) implicitly **not allowed**.\n\nThe `reject` rules reject devices with a suspicious combination of interfaces. A\nUSB drive that implements a keyboard or a network interface is very suspicious,\nthese `reject` rules prevent that.\n\nThe `presentDevicePolicy = \"allow\";` allows any device that is present at daemon\nstart up even if they're not explicitly allowed. However, newly plugged in\ndevices must match an `allow` rule or get denied implicitly.\n\nThe `presentDevicePolicy` should be one of: # one of `\"apply-policy\"`(default,\nevaluate the rule set for every present device), `\"block\"`, `\"reject\"`, `\"keep\"`\n(keep whatever state the device is currently in), or `\"allow\"`, which is used in\nthe example.\n\nThere is also the\n[usbguard-notifier](https://github.com/Cropi/usbguard-notifier)\n\nAnd enable it with the following in your `configuration.nix` or equivalent:\n\n```nix\n# configuration.nix\nimports = [\n    ./usbguard.nix\n];\ncustom.security.usbguard.enable = true;\n```\n\n> ❗ If you are ever unsure about a setting that you want to harden and think\n> that it could possibly break your system you can always use a specialisation\n> reversing the action and choose it's generation at boot up. For example, to\n> force-reverse the above settings you could:\n>\n> ```nix\n> # configuration.nix\n> specialisation.no-usbguard.configuration = {\n>     services.usbguard.enable = lib.mkForce false;\n> };\n> ```\n>\n> - This is a situation where I recommend this, it's easy to lock yourself out\n>   of your keyboard, mouse, etc. when trying to configure this.\n\nFurther Reading:\n\n- [NinjaOne BadUSB](https://www.ninjaone.com/it-hub/endpoint-security/what-is-badusb/)\n\n- [USBGuard](https://usbguard.github.io/)\n\n- [NixCraft USBGuard](https://www.cyberciti.biz/security/how-to-protect-linux-against-rogue-usb-devices-using-usbguard/)\n\n---\n\n## Doas over sudo (Warning Doas is unmaintained)\n\n<details>\n<summary> ✔️ Click to Expand Unmaintained Doas example </summary>\n\n> NOTE: I have moved to `run0` for authentication which is included by default\n> with systemd. It's actually a symlink to the existing `systemd-run` tool. It\n> behaves like a secure `sudo` alternative: it spawns a transient service under\n> PID 1 for privilege escalation, without relying on SUID (set user ID)\n> binaries.\n\n> ⚠️ Warning the Nixpkgs version of `doas`,\n> [OpenDoas](https://github.com/Duncaen/OpenDoas) is unmaintained and hasn't\n> been updated in 3 to 4 years. If you don't like `run0`, consider using\n> `sudo-rs`. I'm leaving this here for now, may remove it in the future to not\n> promote using unmaintained software, you've been warned.\n\n- [Why run0](https://mastodon.social/@pid_eins/112353324518585654)\n\n- SUID = \"Set User ID\": When a binary has the SUID bit set, it runs with the\n  privileges of the file's owner (often root). There is a long history of\n  vulnerabilities with SUID binaries.\n\nFor a more minimalist version of `sudo` with a smaller codebase and attack\nsurface, consider `doas`. Replace `userName` with your username:\n\n```nix\n# doas.nix\n{\n  lib,\n  config,\n  pkgs, # Add pkgs if you need to access user information\n  ...\n}: let\n  cfg = config.custom.security.doas;\nin {\n  options.custom.security.doas = {\n    enable = lib.mkEnableOption \"doas\";\n  };\n\n  config = lib.mkIf cfg.enable {\n    # Disable sudo\n    security.sudo.enable = false;\n\n    # Enable and configure `doas`.\n    security.doas = {\n      enable = true;\n      extraRules = [\n        {\n          # Grant doas access specifically to your user\n          users = [\"userName\"]; # <--- Only give access to your user\n          # persist = true; # Convenient but less secure\n          # noPass = true;    # Convenient but even less secure\n          keepEnv = true; # Often necessary\n          # Optional: You can also specify which commands they can run, e.g.:\n          # cmd = \"ALL\"; # Allows running all commands (default if not specified)\n          # cmd = \"/run/current-system/sw/bin/nixos-rebuild\"; # Only allow specific command\n        }\n      ];\n    };\n\n    # Add an alias to the shell for backward-compat and convenience.\n    environment.shellAliases = {\n      sudo = \"doas\";\n    };\n  };\n}\n```\n\nYou would then import this into your `configuration.nix` and enable/disable it\nwith the following:\n\n```nix\n# configuration.nix\n\nimports = [\n    ./doas.nix\n];\n\ncustom.security.doas.enable = true;\n```\n\n> ❗ NOTE: Many people opt for the less secure `groups = [\"wheel\"];` in the\n> above configuration instead of `users = [\"userName\"];` to give wider access,\n> the choice is yours.\n\n</details>\n\n---\n\n## Firejail\n\n> ❗️ Critics such as madaidan say that Firejail worsens security by acting as a\n> privilege escalation hole. Firejail requires the executable to be setuid,\n> meaning it runs with root privileges.This is risky because any vulnerability\n> in Firejail can lead to privilege escalation. This combined with many\n> convenience features and complicated command line flags leads to a large\n> attack surface.\n\n- I haven't personally tried\n  [nix-bwrapper](https://github.com/Naxdy/nix-bwrapper) myself yet, but it's\n  another sandboxing option that looks interesting. Bubblewrap is known for\n  having a more minimal design and smaller attack surface.\n  - Also see: [Flatpak section](#flatpak) for another option for sandboxing.\n\n- [nix-bubblewrap](https://sr.ht/~fgaz/nix-bubblewrap/) is another option.\n\n- [NixOS Wiki Firejail](https://wiki.nixos.org/wiki/Firejail)\n\n- [Arch Wiki Firejail](https://wiki.archlinux.org/title/Firejail)\n\n> ❗ WARNING: Running untrusted code is never safe, sandboxing cannot change\n> this. --Arch Wiki\n\n```nix\n# firejail.nix\n{\n  pkgs,\n  lib,\n  ...\n}: {\n  programs.firejail = {\n    enable = true;\n    wrappedBinaries = {\n      # Sandbox a web browser\n      librewolf = {\n        executable = \"${lib.getBin pkgs.librewolf}/bin/librewolf\";\n        profile = \"${pkgs.firejail}/etc/firejail/librewolf.profile\";\n      };\n      # Sandbox a file manager\n      thunar = {\n        executable = \"${lib.getBin pkgs.xfce.thunar}/bin/thunar\";\n        profile = \"${pkgs.firejail}/etc/firejail/thunar.profile\";\n      };\n      # Sandbox a document viewer\n      zathura = {\n        executable = \"${lib.getBin pkgs.zathura}/bin/zathura\";\n        profile = \"${pkgs.firejail}/etc/firejail/zathura.profile\";\n      };\n    };\n  };\n}\n```\n\n`wrappedBinaries` is a list of applications you want to run inside a sandbox.\nOnly the apps in the `wrappedBinaries` attribute set will be automatically\nfirejailed when launched the usual way.\n\nOther apps may be started manually using `firejail <app>`, or added to\n`wrappedBinaries` if you want automatic sandboxing, just make sure the profile\nexists.\n\nTo inspect which profiles are available, after rebuilding go to `/nix/store/`, I\nused Yazi to search for `/firejail` and followed it to `firejail/etc`, where the\nprofiles are.\n\nThere are many flags and options available with firejail, I suggest checking out\n`man firejail`.\n\nThere are comments explaining what's going on in:\n[firejail/package.nix](https://github.com/NixOS/nixpkgs/blob/master/pkgs/by-name/fi/firejail/package.nix)\n\nFirejail is a SUID program that reduces the risk of security breaches by\nrestricting the running environment of untrusted applications using\n[Linux namespaces](https://lwn.net/Articles/531114/) and\n[seccomp-bpf](https://l3net.wordpress.com/2015/04/13/firejail-seccomp-guide/)--[Firejail Security Sandbox](https://firejail.wordpress.com/)\n\nIt provides sandboxing and access restriction per application, much like what\nAppArmor/SELinux does at a kernel level. However, it's not as secure or\ncomprehensive as kernel-enforced MAC systems (AppArmor/SELinux), since it's a\nuserspace tool and can potentially be bypassed by privilege escalation exploits.\n\n---\n\n## Flatpak\n\n> ❗️NOTE: You cannot effectively use Firejail with Flatpak apps because of how\n> their sandboxing technologies operate. Flatpak also won't work with the\n> hardened kernel because they require unprivileged user namespaces which the\n> hardened kernel completely disables.\n\nApps that don't have a flatpak equivalent can be further hardened with\nbubblewrap independently but bubblewrap is not needed on Flatpak apps.\n\nBecause of this limited native MAC (Mandatory Access Control) support on NixOS,\nusing Flatpak is often a good approach to get sandboxing and isolation for many\nGUI apps.\n\n- Flatpak bundles runtimes and sandbox mechanisms that provide app isolation\n  independently of the host system's AppArmor or SELinux infrastructure. This\n  can improve security and containment for GUI applications running on NixOS\n  despite the system lacking full native MAC coverage.\n\n- Flatpak apps benefit from sandboxing through bubblewrap, which isolate apps\n  and restrict access to user/home and system resources.\n\nAdd Flatpak with the FlatHub repository for all users:\n\n```nix\nservices.flatpak.enable = true;\n  systemd.services.flatpak-repo = {\n    wantedBy = [ \"multi-user.target\" ];\n    path = [ pkgs.flatpak ];\n    script = ''\n      flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo\n      # Only apps that are verified\n      # flatpak remote-add --if-not-exists --subset=verified flathub-verified https://flathub.org/repo/flathub.flatpakrepo\n    '';\n  };\nxdg = {\n  portal = {\n    enable = true;\n    extraPortals = [ pkgs.xdg-desktop-portal-gtk ];\n    config.common.default = [ \"gtk\" ];\n  };\n};\n# Disables screencopy\nsystemd.user.services.\"xdg-desktop-portal-wlr\" = {\n  enable = false;\n};\n```\n\n- [Flathub Verified Apps](https://docs.flathub.org/docs/for-users/verification)\n\n- [Flatpak the good the bad the ugly](https://secureblue.dev/articles/flatpak)\n\nThen you can either find apps through [FlatHub](https://flathub.org/en) or on\nthe cmdline with `flatpak search <app>`. Flatpak is best used for GUI apps, some\nCLI apps can be installed through it but not all.\n\n- There is also [nix-flatpak](https://github.com/gmodena/nix-flatpak), which\n  enables you to manage your flatpaks declaratively.\n\n- [Flatseal](https://flathub.org/en/apps/com.github.tchx84.Flatseal) is GUI\n  utility that enables you to review and modify permissions from your Flatpak\n  apps. Many apps by default come with smart-card support, X11 & Wayland\n  support, and more, disabling unnecessary permissions is recommended.\n\n- [Warehouse](https://flathub.org/en/apps/io.github.flattool.Warehouse) provides\n  a simple UI to control complex Flatpak options, no cmdline required.\n\nI have heard that it is not recommended to use Flatpak browsers because in order\nfor flatpak to work it has to disable some of the built-in browser sandboxing\nwhich can reduce security. I haven't found any examples of Flatpak browsers\nbeing exploited but it's something to keep in mind.\n\n---\n\n## SeLinux/AppArmor MAC (Mandatory Access Control)\n\n**AppArmor** is available on NixOS, but is still in a somewhat experimental and\nevolving state. There are only a few profiles that have been adapted to NixOS,\nsee here\n[Discourse on default-profiles](https://discourse.nixos.org/t/apparmor-default-profiles/16780)\nWhich guides you here\n[apparmor/includes.nix](https://github.com/NixOS/nixpkgs/blob/2acaef7a85356329f750819a0e7c3bb4a98c13fe/nixos/modules/security/apparmor/includes.nix)\nwhere you can see some of the abstractions and tunables to follow progress.\n\n**SELinux**: Experimental, not fully integrated, recent progress for\nadvanced/curious users; expect rough edges and manual intervention if you want\nto try it. Most find SELinux more complex to configure and maintain than\nAppArmor.\n\nThis isn't meant to be a comprehensive guide, more to get people thinking about\nsecurity on NixOS.\n\nSee the following guide on hardening networking:\n\n- [Hardening Networking](https://saylesss88.github.io/nix/hardening_networking.html)\n\n---\n\n## Resources\n\n### Advanced Hardening with `nix-mineral` (Community Project)\n\n<details>\n<summary> ✔️ Click to Expand section on `nix-mineral` </summary>\n\nFor users seeking a more comprehensive and opinionated approach to system\nhardening beyond the built-in `hardened` profile, the community project\n[`nix-mineral`](https://github.com/cynicsketch/nix-mineral) offers a declarative\nNixOS module.\n\n`nix-mineral` aims to apply a wide array of security configurations, focusing on\ntweaking kernel parameters, system settings, and file permissions to reduce the\nattack surface.\n\n- **Community Project Status:** `nix-mineral` is a community-maintained project\n  and is not officially part of the Nixpkgs repository or NixOS documentation.\n  Its development status is explicitly stated as \"Alpha software,\" meaning it\n  may introduce stability issues or unexpected behavior.\n\nFor detailed information on `nix-mineral`'s capabilities and current status,\nrefer directly to its\n[GitHub repository](https://github.com/cynicsketch/nix-mineral).\n\n</details>\n\n<details>\n<summary> ✔️ Click to Expand Resources </summary>\n\n- [AppArmor and apparmor.d on NixOS](https://hedgedoc.grimmauld.de/s/hWcvJEniW#)\n\n- [SELinux on NixOS](https://tristanxr.com/post/selinux-on-nixos/)\n\n- [Paranoid NixOS](https://xeiaso.net/blog/paranoid-nixos-2021-07-18/)\n\n- [NixOS Wiki Security](https://wiki.nixos.org/wiki/Security)\n\n- [Luks Encrypted File Systems](https://nixos.org/manual/nixos/unstable/index.html#sec-luks-file-systems)\n\n- [Discourse A Modern and Secure Desktop](https://discourse.nixos.org/t/a-modern-and-secure-desktop-setup/41154)\n\n- [notashelf NixOS Security 1 Systemd](https://notashelf.dev/posts/insecurities-remedies-i)\n\n- [ryanseipp hardening-nixos](https://ryanseipp.com/post/hardening-nixos/)\n\n- [madaidans Linux Hardening Guide](https://madaidans-insecurities.github.io/guides/linux-hardening.html)\n\n- [Hardening-Linux-Servers](https://cybersecuritynews.com/hardening-linux-servers)\n\n- [linux-audit Linux Server hardening best practices](https://linux-audit.com/linux-server-hardening-most-important-steps-to-secure-systems/)\n\n- [linux-audit Linux security guide extended](https://linux-audit.com/linux-security-guide-extended-version/)\n\n- [Arch Wiki Security](https://wiki.archlinux.org/title/Security)\n\n- [Gentoo Security_Handbook Concepts](https://wiki.gentoo.org/wiki/Security_Handbook/Concepts)\n\n- [secureblue FAQ](https://secureblue.dev/faq)\n\n- [Excellent Kicksecure Docs](https://www.kicksecure.com/wiki/Documentation)\n\n- [Awesome-Security-Hardening List](https://github.com/decalage2/awesome-security-hardening)\n\n- [factorable.net (study of RSA and DSA crypto keys) FAQ](https://factorable.net/faq.html)\n\n- [The cr.yp.to blog Entropy](https://blog.cr.yp.to/20140205-entropy.html)\n\n- [NixOS Security wishlist](https://delroth.net/posts/nixos-security-wishlist/)\n\n- [Beejus IPC guide](https://beej.us/guide/bgipc/html/)\n\n- [GeeksforGeeks IPC](https://www.geeksforgeeks.org/operating-systems/inter-process-communication-ipc/)\n\nneal.codes vulnerability scan script:\n\n```bash\nnix-shell -p grype sbomnix --run '\n  sbomnix /run/current-system --csv /dev/null --spdx /dev/null --cdx sbom.cdx.json;\n  grype sbom.cdx.json\n'\n```\n\n- [neal.codes nixos-stig-anduril](https://github.com/nealfennimore/nixos-stig-anduril)\n\n- [Suse Linux Hardening Guide](https://www.suse.com/c/linux-hardeningthe-complete-guide-to-securing-your-systems/)\n\n**Government Resources 1st 6 come from gentoo's Security_Handbook)**\n\n- [The Austrailian Cyber Security Centre's Informational Security Manual (ISM)](https://www.cyber.gov.au/sites/default/files/2023-03/Information%20Security%20Manual%20-%20%28March%202023%29.pdf)\n\n- [The Australian Government's Protective Security Policy Framework (PSPF)](https://www.protectivesecurity.gov.au/policies)\n\n- [The Australian Cyber Security Centre's Protect Yourself page](https://www.cyber.gov.au/protect-yourself)\n\n- [The UK Government's Security Policy Framework (SPF)](https://www.gov.uk/government/publications/security-policy-framework/hmg-security-policy-framework)\n\n- [The UK Government's Information Security Policy Framework (ISF)](https://www.gov.uk/government/publications/information-security-policy-framework)\n\n- [The US National Institute of Standards and Technology's Cybersecurity page](https://www.nist.gov/cybersecurity)\n- [NixOS STIG](https://stigviewer.com/stigs/anduril_nixos)\n\n- STIGs are configuration standards developed by the Defense Information Systems\n  Agency (DISA) to secure systems and software for the U.S. Department of\n  Defense (DoD). They are considered a highly authoritative source for system\n  hardening.There are recommendations for hardening all kinds of software in the\n  [Stig Viewer](https://stigviewer.com/stigs)\n\n- [CIS Benchmarks](https://www.cisecurity.org/cis-benchmarks)\n\n- [NSA Cybersecurity Directorate](https://github.com/nsacyber)\n\n</details>\n","number":[1,3,3],"sub_items":[],"path":"nix/hardening_NixOS.md","source_path":"nix/hardening_NixOS.md","parent_names":["Getting Started with the Nix Ecosystem","Cachix and the devour-flake"]}},{"Chapter":{"name":"GnuPG & gpg-agent on NixOS","content":"# GnuPG & `gpg-agent` on NixOS\n\n<details>\n<summary> Click to Expand Table of Contents</summary>\n\n<!-- toc -->\n\n</details>\n\n> ⚠️ **SECURITY WARNING**: This guide involves sensitive cryptographic material.\n> **Never share your private key or passphrase**. Backup your keys and handle\n> them with extreme care.\n\n## 🔑 Key Concepts\n\n**GnuPG** is a complete and free implementation of the OpenPGP standard. It\nallows you to encrypt and sign your data and communications, has a versatile key\nmanagement system, and access modules for many kinds of public key directories.\nGnuPG (GPG), is a command line tool for secure communication.\n\n**PGP (Pretty Good Privacy)** and **GPG (GNU Privacy Guard)**. While distinct,\nthey are deeply interconnected and, for the rest of this section, I'll use the\nterms interchangeably.\n\n**PGP** was the original, groundbreaking software that brought robust public-key\ncryptography to the masses. It set the standard for secure email communication.\nHowever, PGP later became a commercial product.\n\nTo provide a free and open-source alternative that anyone could use and inspect,\n**GPG** was created. Crucially, **GPG** is a complete implementation of the\nOpenPGP standard. This open standard acts as a universal language for encryption\nand digital signatures.\n\nGnuPG uses a more complex scheme in which a user has a primary keypair and then\nzero or more additional subordinate keypairs.\n\nSigning public keys with the corresponding private key is called _self-signing_,\nand a public key that has self-signed user IDs bound to it is called a\n_certificate_.\n\n**Web of Trust**: Rather than validate every single key individually, you can\nrely on other factors such as if it has been signed by a key that you fully\ntrust or if it has been signed by three marginally trusted keys to validate\nkeys.\n\n`gpg-agent` is a daemon to manage secret (private) keys independently from any\nprotocol. It is used as a backed for `gpg` and `gpgsm` as well as for a couple\nof other utilities. --[man gpg-agent](https://man.cx/gpg-agent)\n\nThere are numerous front-ends for gpg as well, i.e., GUI apps that simplify many\nof the commands and processes. Two that I touch on in this overview are\n`seahorse` and `kleopatra`.\n\n### Asymmetric Encryption (Public-Key cryptography)\n\nE2ee requires that every sender and recipient does a one time preparation, which\ninvolves the generation of personal random numbers. Two such random numbers are\nnecessary, one will be called your secret key and another one will be called\nyour public key (together your _personal key_). These numbers are very big, they\nconsist of hundreds or thousands of digits.\n\nA message can be encrypted using the recipients public key and can only be\ndecrypted with the matching private key. In other words, if you exchange\n**public keys** with someone you both can encrypt messages that only the other\ncan decrypt with their own **private key**. **You must never share the private\nkey or the private keys passphrase with anyone else**.\n\n**What’s safe to share?**\n\n- Your public key (used to encrypt files and verify signatures)\n\n- Your key ID (identifies your key, useful for sharing public keys or configs)\n\n- Your keys fingerprint `gpg --fingerprint`\n\n**What must never be shared?**\n\n- Your private (secret) key, usually in your `~/.gnupg/private-keys-v1.d/`\n  directory. Usually called your _private keyring_. **Your main goal should be\n  the protection of your private key**.\n\n- **Your passphrase for your private key**. Even if someone is able to somehow\n  get your private key, they need to break the passphrase to access it\n  unencrypted. **Protect this passphrase**!\n\n**Best Practices**\n\nDon't rely on the short KeyID, at least use long OpenPGP Key IDs (for example\n0xA1E6148633874A3D), they are 64 bits long and harder to spoof. Even better, use\nthe fingerprint.This is accomplished in the configuration with\n`keyid-format = \"0xlong\";`, and `with-fingerprint`.\n\nAlways sign your public keys before you publish them to prevent man in the\nmiddle attacks and other modifications. When a subkey or userID is generated it\nis self-signed automatically, which is why you need to enter your password.\n\nDon't blindly trust keys from keyservers. You should verify the full key\nfingerprint with the owner over the phone if possible.\n\n- [Verifying software signatures](https://www.kicksecure.com/wiki/Verifying_Software_Signatures)\n\nUse a strong primary key, don't use 1024-bit DSA, 1024-bit RSA, or SHA-1 for\nsigning they are no longer recommended.\n\nChoose an expiration date less than 2 years, you can add time if needed.\nRemember this date.\n\nRotate your subkeys.\n\nKeep your primary key offline, this ensures that it can't be stolen by an\nattacker allowing him to create new identities. We accomplish this by creating\nsubkeys and only adding the subkeys keygrip and the subkeys `default-key` to our\nconfiguration keeping the primary key out of it.\n\nSince we will be removing our primary key, even we won't be able to create\nadditional keys so it's important to think ahead and make all the keys you'll\nneed. However, it is as easy as reimporting it to give yourself access again.\n\nMany of these best practices come from the following guide:\n\n- [RiseUp gpg-best-practices](https://riseup.net/ru/security/message-security/openpgp/gpg-best-practices)\n\n---\n\nHome Manager module with `gpg-agent`, `gnupg`, and `pinentry-gnome3`:\n\n```nix\n# gpg-agent.nix\n{\n  config,\n  lib,\n  pkgs,\n  ...\n}: {\n  options = {\n    custom.pgp = {\n      enable = lib.mkEnableOption {\n        description = \"Enable PGP Gnupgp\";\n        default = false;\n      };\n    };\n  };\n\n  config = lib.mkIf config.custom.pgp.enable {\n    services = {\n      ## Enable gpg-agent with ssh support\n      gpg-agent = {\n        enable = true;\n        enableSshSupport = true;\n        enableZshIntegration = true;\n        # pinentry is a collection of simple PIN or passphrase dialogs used for\n        # password entry\n        pinentryPackage = pkgs.pinentry-gnome3;\n      };\n\n      ## We will put our keygrip here\n      gpg-agent.sshKeys = [];\n    };\n    home.packages = [pkgs.gnupg];\n    programs = {\n      # Gui for OpenPGP\n      seahorse.enable = true;\n      gpg = {\n        ## Enable GnuPG\n        enable = true;\n\n        # homedir = \"/home/userName/.config/gnupg\";\n        settings = {\n          # Default/trusted key ID (helpful with throw-keyids)\n          # Example, you will put your own keyid here\n          # Use `gpg --list-keys`\n          # default-key = \"0x37ACBCDA569C5C44788\";\n          # trusted-key = \"0x37ACBCDA569C5C44788\";\n          # https://github.com/drduh/config/blob/master/gpg.conf\n          # https://www.gnupg.org/documentation/manuals/gnupg/GPG-Configuration-Options.html\n          # https://www.gnupg.org/documentation/manuals/gnupg/GPG-Esoteric-Options.html\n          # Some Best Practices, stronger algos etc\n          # Use AES256, 192, or 128 as cipher\n          personal-cipher-preferences = \"AES256 AES192 AES\";\n          # Use SHA512, 384, or 256 as digest\n          personal-digest-preferences = \"SHA512 SHA384 SHA256\";\n          # Use ZLIB, BZIP2, ZIP, or no compression\n          personal-compress-preferences = \"ZLIB BZIP2 ZIP Uncompressed\";\n          # Default preferences for new keys\n          default-preference-list = \"SHA512 SHA384 SHA256 AES256 AES192 AES ZLIB BZIP2 ZIP Uncompressed\";\n          # SHA512 as digest to sign keys\n          cert-digest-algo = \"SHA512\";\n          # SHA512 as digest for symmetric ops\n          s2k-digest-algo = \"SHA512\";\n          # AES256 as cipher for symmetric ops\n          s2k-cipher-algo = \"AES256\";\n          # UTF-8 support for compatibility\n          charset = \"utf-8\";\n          # Show Unix timestamps\n          fixed-list-mode = \"\";\n          # No comments in signature\n          no-comments = \"\";\n          # No version in signature\n          no-emit-version = \"\";\n          # Disable banner\n          no-greeting = \"\";\n          # Long hexidecimal key format\n          keyid-format = \"0xlong\";\n          # Display UID validity\n          list-options = \"show-uid-validity\";\n          verify-options = \"show-uid-validity\";\n          # Display all keys and their fingerprints\n          with-fingerprint = \"\";\n          # Cross-certify subkeys are present and valid\n          require-cross-certification = \"\";\n          # Disable caching of passphrase for symmetrical ops\n          no-symkey-cache = \"\";\n          # Enable smartcard\n          # use-agent = \"\";\n        };\n      };\n    };\n  };\n}\n```\n\n> 🤔 Fun Fact: Elliot Alderson mentions encrypting Evil Corps files with 256 bit\n> AES encryption ensuring that it's impossible to break in `eps1.9_zer0.daY.avi`\n> of Mr. Robot.\n\n- The default path is `~/.gnupg`, if you prefer placing it in the `~/.config`\n  directory or elsewhere, uncomment the `homedir` line and change `userName` to\n  your username.\n\n- I use hyprland so `pinentry-gnome3` works for me, there is also the following\n  options for this attribute:\n\n- `pinentry-tty`\n\n- `pinentry-qt`\n\n- `pinentry-gtk2`\n\nAnd more, research what you need and use the correct one.\n\nEnable in your `home.nix` or equivalent:\n\n```nix\n# home.nix\n# ... snip ...\nimports = [\n    ./gpg-agent.nix\n];\ncustom.pgp.enable = true;\n# ... snip ...\n```\n\n`gpg --full-generate-key` can be used to generate a basic keypair.\n\n`gpg --expert --full-generate-key` can be used for keys that require more\ncapabilities.\n\n> ❗ NOTE: We will first generate our GPG primary key that is required to\n> atleast have sign capabilities, we will then derive subkeys from said primary\n> key and use them for signing and encrypting. It is recommended to generate a\n> revoke certificate right after creating your primary key.\n\nTo generate your gpg primary key you can do the following:\n\n```bash\ngpg --full-generate-key\n```\n\n- Choose `(10) (sign only)`\n\n- Give it a name and description\n\n- Give it an expiration date, 1y is common\n\n- Use a strong passphrase or password\n\n- Give it a comment, I typically add the date\n\nIf you see a warning about incorrect permissions, you can run the following:\n\n```bash\nchmod 700 ~/.gnupg\nchmod 600 ~/.gnupg/*\n```\n\nVerify:\n\n```bash\nls -ld ~/.gnupg\n# Should show: drwx------\n\nls -l ~/.gnupg\n# Files should show: -rw-------\n```\n\n### Generate a Revocation Certificate\n\n`mykey` must be a key specifier, either the keyID of the primary keypair or any\npart of the user ID that identifies the keypair:\n\nReplace `mykeyID` with the keyID of your primary key and store the cert in a\nsafe place:\n\n```bash\ngpg --output revoke.asc --gen-revoke mykeyID\nCreate a revocation certificate for this key? (y/N)\nPlease select the reason for the revocation:\n  0 = No reason specified\n  1 = Key has been compromised\n  2 = Key is superseded\n  3 = Key is no longer used\n  Q = Cancel\n(Probably you want to select 1 here)\nYour decision?\n```\n\nThe certificate will be output to a file `revoke.asc`. If the `--output` is\nommitted, the result will be placed on stdout.\n\nSince it's a short certificate, you can print a hardcopy and store it somewhere\nsafe. The cert shouldn't be somewhere that others can access it since anyone\ncould publish the revoke cert and render the corresponding public key useless.\n\nTo apply the revoke cert, import it:\n\n```bash\ngpg --import revoke.asc\n# And optionally push the revoked key to public keyservers to notify others:\ngpg --keyserver keyserver.ubuntu.com --send-keys YOUR_KEYID\n```\n\n---\n\nAfter fixing, run `gpg --list-keys --with-fingerprint`, which lists your public\nkeys:\n\n```bash\n# Take note of your public key\ngpg --list-keys --with-fingerprint\n/home/jr/.gnupg/pubring.kbx\n---------------------------\npub   ed25519/0x095782A1B124AF15 2025-08-23 [SCA] [expires: 2026-08-23]\nKey fingerprint = 5908 9C5B FEC8 0D75 FCB0  E206 0958 82C1 A124 CF15\nuid                   [ultimate] Jr (08-23-25) <sayls8@proton.me>\n```\n\n- Copy the KeyID, in this example it would be `0x095722B2A123CF15`. We will use\n  it for the command below.\n\nThe warning should be gone.\n\nNow we will generate 2 subkeys, 1 for encryption and 1 for authentication.\n\n```bash\ngpg --expert --edit-key 0x095722B2A123CF15\n```\n\nChoose 11 (set your own capabilities) and add A (Authenticate) and type `save`\nto save and exit. Repeat this again and choose ECC (encrypt only).\n\n> ❗ `gpg --edit-key` has many more capabilities, after launching type `help`.\n\n**Add Keygrip of Authenticate Subkey to `sshcontrol` for gpg-agent**\n\n```bash\ngpg --list-secret-keys --with-keygrip --keyid-format LONG\n```\n\nCopy the keygrip of the subkey with Authenticate capabilities\n\nAdd the keygrip number to your `gpg-agent.sshKeys` and rebuild, this adds an SSH\nkey to `gpg-agent`. This is for the SSH key functionality of `gpg-agent`, while\nthe key ID (`default-key`) is for GPG-specific operations like signing commits:\n\n```nix\n# gpg-agent.nix\ngpg-agent.sshKeys = [\"6BD11826F3845BC222127FE3D22C92C91BB3FB32\"];\n```\n\n- By itself, a keygrip cannot be used to reconstruct your private key. It's\n  derived from the public key material, not from the secret key itself so it's\n  safe to version control. Don't put your keygrip in a public repo if you don't\n  want people to know you use that key for signing/authentication. It's not a\n  security risk, but it leaks a tiny bit of metadata.\n\nThe following article mentions the keygrip being computed from public elements\nof the key:\n\n- [gnupg-users what-is-a-keygrip](https://gnupg-users.gnupg.narkive.com/q5JtahdV/gpg-agent-what-is-a-keygrip)\n\nAdd the KeyId to your `gpg-agent.nix`, this declares your default-key to persist\nthrough rebuilds:\n\nCopy the public key of the same subkey with Authenticate capabilities you will\nsee something like `[SA]` next to it for Sign and Authenticate:\n\n```nix\n# gpg-agent.nix\ngpg.settings = {\n    # Replace with your own Subkeys KeyID `gpg --list-keys --keyid-format LONG`\n    default-key = \"Ox37ACA569C5C44787\";\n    trusted-key = \"Ox37ACA569C5C44787\";\n};\n```\n\nThis key should be signed automatically, ensure that it is:\n\n```bash\ngpg --sign-key Ox37ACA569C5C44787\n```\n\nRebuild, and check that everything is correct with:\n\n```bash\nssh-add -L\n# you should see something like:\nssh-ed25519 AABCC3NzaC1lZDI1NTE5ABBAIHyujgyCjjBTqIuFM3EMUSo6RGklmOXQW3uWRhWdJ1Mm (none)\n```\n\n- Never version-control your private key files or `.gnupg` contents.\n\nAdd the following to your shell config:\n\n```bash\n# zsh.nix\n# ... snip ...\ninitContent = ''\n    export GPG_TTY=$(tty)\n    export SSH_AUTH_SOCK=$(gpgconf --list-dirs agent-ssh-socket)\n    gpgconf --launch gpg-agent\n'';\n# ... snip ...\n```\n\nRebuild and then restart `gpg-agent` if necessary:\n\n```bash\ngpgconf --kill gpg-agent\ngpgconf --launch gpg-agent\n```\n\nTest, these should match:\n\n```bash\necho \"$SSH_AUTH_SOCK\"\n# output\n/run/user/1000/gnupg/d.wft5hcsny4qqq3g31c76534j/S.gpg-agent.ssh\n\ngpgconf --list-dirs agent-ssh-socket\n# output\n/run/user/1000/gnupg/d.wft5hcsny4qqq3g31c76834j/S.gpg-agent.ssh\n```\n\n```bash\nssh-add -L\n# Copy the entire following line:\nssh-ed25519 AABBC3NzaC1lZDI1NTE5AAAAIGXwhVokJ6cKgodYT+0+0ZrU0sBqMPPRDPJqFxqRtM+I (none)\n```\n\n- Mine shows `(none)` because I left the comment field blank when creating the\n  key and doesn't affect functionality.\n\nThen, in your server's NixOS configuration (e.g., `configuration.nix`): Change\n`yourUser` to your username. This is how you grant access to a remote machine,\nand the public key from the GPG subkey is what's added here, the output of\n`ssh-add -L`:\n\n```nix\nusers.users.yourUser = {\nopenssh = {\n  authorizedKeys.keys = [\n    # Replace with the output of `ssh-add -L`\n    \"ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIGXwhVokJ6cKgodYT+0+0ZrU0sBqMPPRDPJqFxqRtM+I (none)\"\n  ];\n};\n};\n```\n\n> ❗ NOTE: Only the **public** key goes here, it's safe to commit to version\n> control. If you prefer not to hardcode it in the config, you can reference it\n> from a `.pub` file in your repo and read it with\n> `builtins.readFile ./mykey.pub`\n\nRebuild your system and test an SSH connection into the server:\n\n```bash\nssh -p <your-port> user@hostname\n```\n\n- `<your-port>` is often `22` so it would be something like:\n\n```bash\nssh -p 22 bill@xps\n```\n\nOnce you successfully sign in to SSH, it will ask you if you're sure you trust\nthe remote server's SSH host key. Once you type `yes`, it will automatically be\nused for tasks such as file decryption.\n\n### Remove and Store your Primary Key offline\n\n> ❗ NOTE: After you remove your primary key, you will no longer be able to\n> derive subkeys from it or sign keys unless you re-import it.\n\n```bash\n# extract the primary key\ngpg -a --export-secret-key sayls8@proton.me > secret_key\n# extract the subkeys, which we will reimport later\ngpg -a --export-secret-subkeys sayls8@proton.me > secret_subkeys.gpg\n# delete the secret keys from the keyring, so only subkeys are left\ngpg --delete-secret-keys sayls8@proton.me\nDelete this key from the keyring? (y/N) y\nThis is a secret key! - really delete? (y/N) y\n# reimport the subkeys\ngpg --import secret_subkeys.gpg\n# verify everything is in order\ngpg --list-secret-keys\n# remove the subkeys from disk\nrm secret_subkeys.gpg\n```\n\nI recommend also keeping a `.gpg` version to make it easy to re-import your\nprimary key: `gpg --export-secret-keys --armor --output private-key-bak.gpg`\n\nThen store `secret_key` on an encrypted USB drive or somewhere offline. If you\nwant to protect it for now, you can just use the encryption subkey that we\ncreated to encrypt `secret_key` with a passphrase:\n\n```bash\ngpg --list-keys --keyid-format LONG\n```\n\nCopy the KeyID of the subkey with encrypt capabilities for the following\ncommand:\n\n```bash\n# Encrypting your secret key for yourself\ngpg --encrypt --recipient Ox37ACA569C5C44787 secret_key\n```\n\nYou can check that the secret key material is missing with\n`gpg --list-secret-keys`, you should see `sec#` instead of `sec`.\n\n```bash\ngpg --list-secret-keys\n# Output:\nsec#  ed25519/0x\n# ...snip...\n```\n\nThe above set of commands are from the\n[RiseUp Keep your primary key offline](https://riseup.net/ru/security/message-security/openpgp/gpg-best-practices#keep-your-primary-key-entirely-offline)\n\n## Add your GPG Key to GitHub\n\nPlug your own public key from `gpg --list-keys` in the following command:\n\n```bash\ngpg --armor --export <Public-Key>\n```\n\nCopy the entire block from `-----BEGIN PGP PUBLIC KEY BLOCK-----` to\n`-----END PGP PUBLIC KEY BLOCK-----`\n\n> ❗ You can also paste the above block into a public keyserver such as\n> `keys.openpgp.org`. This allows others to find and use your key to encrypt\n> messages or verify your signatures. Many tools and users rely on public key\n> servers to fetch keys automatically. You can also publish your revocation\n> certificates, which help others know if your key is compromised or revoked.\n> This can be a privacy concern as key servers publish (and keep) associated\n> user IDs and metadata linked to your key, such as your email.\n\nIt's the same process as adding an SSH key, Go to Settings, SSH and GPG keys,\n`New GPG key` and your all set.\n\n### Sign your Commits for Git\n\n```nix\n# git.nix\n{...}: {\n    programs.git = {\n        enable = true;\n      extraConfig = {\n          commit.gpgsign = true;\n          user.signingkey = \"0x0666C1A265F156\"\n      };\n    };\n}\n```\n\nAfter this, you will be prompted for your Private Keys password on every commit.\n\nIf you look at your commits on GitHub, after adding the GPG key and the above\nsettings to your git setup it will show your commits are `Verified`.\n\n### Backing up Your Keys\n\n```bash\ngpg --export-secret-keys --armor --output my-private-key-backup.gpg\n```\n\nYour private keys will be encrypted with a passphrase into a .gpg file. Store\nthis backup in a secure location line an encrypted USB drive. This can prevent\nyou from losing access to your keys in the case of disk failure or accidents.\n\nYou can export your public keys and publish them publicly if you choose:\n\n```bash\ngpg --export --armor --output my-public-keys.gpg\n```\n\nNow if your keys ever get lost or corrupted, you can import these backups.\n\n## Encrypt a File with PGP\n\nThe easy way to do this is with an app like Kleopatra, available as\n`pkgs.kdePackages.kleopatra`. Kleopatra will automatically recognize your gpg\nkeys and enable you to easily encrypt messages by clicking the Notepad, typing\nyour message and clicking `Sign/Encrypt Notepad`. You can also choose to encrypt\nthe message with a password, where anyone that has the password can read the\nmessage.\n\nUsing the above and below methods enable you to encrypt any message for\nbasically any service and just copy past the encrypted text into the service for\nadded privacy.\n\nEncrypting a whole directory is a bit more involved and requires using\ncompression.\n\n### List your keys and get the key ID\n\n```bash\ngpg --list-keys --keyid-format LONG\n```\n\nExample output, don't use RSA keys:\n\n```bash\npub   rsa4096/ABCDEF1234567890 2024-01-01 [SC]\nuid           [ultimate] Your Name <you@example.com>\nsub   rsa4096/1234567890ABCDEF 2024-01-01 [E]\n```\n\n- Notice the `sub` and the `[E]` for the subkey with encrypt capabilities.\n\n- The part after the slash on the `pub` line is your key ID (`ABCDEF1234567890`\n  in the example)\n\n- You can also use your email or name to refer to the key in most commands.\n\n### Encrypt a file\n\nIn order to encrypt a document you must have the public keys of the intended\nrecipients.\n\n```bash\necho \"This file will be encrypted\" > file.txt\n```\n\nEncrypting for yourself (using a key ID as recipient):\n\n```bash\ngpg --encrypt --recipient ABCDEF1234567890 file.txt\n```\n\n```bash\nls\n│  7 │ file.txt            │ file │     28 B │ now           │\n│  8 │ file.txt.gpg        │ file │    191 B │ now           │\n```\n\nEncrypting for someone else with their email (public key identifier):\n\n```bash\ngpg --output file.gpg --encrypt --recipient jake@proton.me file.txt\n```\n\n```bash\nls\nfile.txt\nfile.gpg\n```\n\n`gpg --encrypt` doesn't modify the original file. It creates a new encrypted\nfile by default with `gpg` amended to the filename.\n\n```bash\ngpg --decrypt file.txt.gpg\ngpg: encrypted with cv25519 key, ID 0x4AC131B80CEC833E, created 2025-07-31\n      \"GPG Key <sayls8@proton.me>\"\nThis file will be encrypted\n```\n\nOr, to save the decrypted text to a file:\n\n```bash\ngpg --output decrypted_file.txt --decrypt file.txt.gpg\ncat decrypted_file.txt\n# Output\nFile: decrypted.txt\nThis file will be encrypted\n```\n\n- You will be asked for the passphrase you used when creating the key in order\n  to decrypt the file.\n\n### Sign and Verify Signatures\n\nWhen you sign a document it is certified and timestamped. If after the doc is\nsigned, if the doc is further modified in any way the verification of the\nsignature will fail.\n\nA signature is created using the private key of the signer, and verified with\nthe corresponding public key. For example, to verify Jakes signature you would\nuse Jake's public key to see that the work indeed came from him and hasn't been\nmodified since.\n\nTo sign the above `file.txt`:\n\n```bash\ngpg output doc.sig --sign file.txt\n# To clearsign use:\ngpg --clearsign file.txt\n# For a detached signature use:\ngpg --output doc.sig --detach-sig file.txt\n```\n\nYou will be prompted for your passphrase.\n\nYou can either check the signature or check the signature and recover the\noriginal document.\n\n```bash\n# To only check:\ngpg --output doc --verify doc.sig\n# To verify and extract the document\ngpg --output doc --decrypt doc.sig\n```\n\n## Email Encryption\n\nEmail is inherently insecure, and email-based attacks remain one of the top\nvectors for data breaches. Encrypting your email protects your privacy by\nensuring that only the intended recipient can read it. Encrypting your emails\nwith PGP provides valuable security benefits but also has inherent limitations\nthat prevent it from being considered truly “secure communication” by modern\nstandards.\n\n- [Email Self-Defense](https://emailselfdefense.fsf.org/en/)\n\nWhat its Good for:\n\n- Confidentiality, it prevents unauthorized third parties (like email providers\n  or network eavesdroppers) from reading your email content.\n\n- Integrity and authenticity: Digital signatures verify that the email genuinely\n  came from the claimed sender and hasn't been altered in transit.\n\n- Long-term confidentiality: Encrypted emails stored on servers or devices\n  remain protected even if the storage is later compromised. With companies like\n  Gmail giving you a \"free\" account, that usually means that you are the product\n  and you should tread lightly.\n\n**To securely communicate with someone never use email, use a dedicated service\nsuch as Threema, Signal or Brair.** It's hard to recommend any messaging service\nat the moment, always do your own research and stay informed on the companies\npolicies. Signal has taken some heat for the way it has implemented it's\nMobileCoin. The biggest issue I've faced is getting other people to care or use\nthe same e2ee app.\n\nWith Thunderbird you can go to settings, Privacy and Security, and scroll to the\nbottom where it says \"End to End Encryption\", Click the Settings tab there,\nfinally click End-To-End Encryption on the left.\n\nFrom there, you can click `+ Add Key` next to your email address and either\ngenerate a new key through Thunderbird. If you use this, choose the Curve\nprotocol or whatever isn't RSA.\n\nOr import your own key which is definitely more secure since you're not trusting\nsomeone else with your private key:\n\n```bash\ngpg --export --armor sayls8@gmail.com > publickey.asc\n```\n\nThen select `+ Add Key` and choose import your own, this didn't work for me.\nWhat did work was to start composing an email and click on the `OpenPGP` button,\nGo to `Key Manager`, `File`, `Import Public Key from a File` and choose your\n`publickey.asc`. This way, only you have access to your private key.\n\n- [How e2ee with OpenPGP works in general](https://support.mozilla.org/en-US/kb/introduction-to-e2e-encryption#w_how-e2ee-with-openpgp-works-in-general)\n\n**Import your recipient's public key**\n\nWhen you start composing an email, you'll see that you need to resolve key\nissues if you don't already have the recipients public key. Click `Resolve`, and\neither Discover Public Keys Online... or Import Public Keys From File...\n\nThunderbird has the option to use the OpenPGP Key Manager to view or manage\npublic keys of your correspondents.\n\nIf you're sending encrypted emails to someone you'll need their public key,\nthere are a few methods of doing this just ensure you verify the Fingerprint\nwith the person your talking to.\n\nExporting your public key means creating a copy of the public part of your\ncryptographic key pair that you can share with others.\n\nFor example, say that Jake wants to send you his public key. First he has to\nexport his key:\n\n```bash\ngpg --output jake.gpg --export jake@proton.me\n```\n\nThe key is exported in binary format, to export in ASCII-armored format use:\n\n```bash\ngpg --armor --export jake@proton.me\n```\n\nNow, once he sends this to you, you'll need to import and validate it:\n\n```bash\ngpg --import jake.gpg\n```\n\nOnce the key is imported it should be validated. If you need to validate a key\nmanually, it is done by verifying the key's fingerprint and then signing the key\nto certify it as a valid key.\n\nCheck that it exists in your keychain:\n\n```bash\ngpg --list-keys\n```\n\nYou should see Jakes key in the above list.\n\nTo certify the key you need to edit it:\n\n```bash\ngpg --edit-key jake@proton.me\n# List the fingerprint\ngpg> fpr\n# once the fingerprint is verified with the owner, sign it\ngpg> sign\n# once signed, you can check the key to list signatures on it\ngpg> check\n```\n\n> ❗ NOTE: You can use PGP to encrypt any message and paste it into **any**\n> software and send it. As long as only you and your recipient are the only\n> people to have the private keys, you will be the only people able to decrypt\n> the messages. Implementing this correctly is a good way to stop government\n> mass surveillance.\n\n## Make your Public Key Highly Available\n\nYou should always make sure that you sign your public key before you publish it.\nWhen you distribute your public key, you're distributing the public components\nof your master and subkeys as well as the user IDs. If unsigned, this is a\nsecurity risk because it's possible for an attacker to tamper with it. The\npublic key can be modified by adding or substituting keys, or changing user IDs.\n\nSigning the keys provides a web of trust, only the corresponding public key can\nbe used to verify the signature and ensure it hasn't been modified. Since we are\nalready only using subkeys for public keys, they are automatically self-signed.\n\n```bash\ngpg --output ~/mygpg.key --armor --export your_email@address.com\n```\n\nYou can then send this file to the other party.\n\nYou can also use the GPG interface to upload your key to a key server:\n\n```bash\ngpg --list-keys your_email@address.com\n```\n\nCopy the key ID for the following command, remember its on the `pub` line after\nthe `/`.\n\n```bash\ngpg --send-keys --keyserver pgp.mit.edu key_id\n```\n\nThe key will be uploaded to the server and likely be distributed to other key\nservers around the world. This is why expiration dates are important, if your\nkey is lost or stolen, the damage window is limited to the expiration period.\nAlso remember, you can add more time even after the key has expired.\n\n### Example: Verifying Arch Linux Download\n\n<details>\n<summary>\n\n✔️ Click to Expand Example of verifying and signing the archlinux public key\n\n</summary>\n\nFirst, download both the arch `.iso` and `.sig` files.\n\nI tried a few different methods from <https://archlinux.org/download/#checksums>\nand the easiest by far was using Sequoia available in Nixpkgs as\n`pkgs.sequoia-sq`:\n\nDownload the archlinux public key:\n\n```bash\nsq network wkd search pierre@archlinux.org --output release-key.pgp\n\nFound 2 certificates related to the query:\n\n - 3E80CA1A8B89F69CBA57D98A76A5EF9054449A5C\n   - Pierre Schmitz <pierre@archlinux.org> (UNAUTHENTICATED)\n   - created 2022-10-31 09:11:51 UTC\n   - found via: WKD\n\n - 4AA4767BBC9C4B1D18AE28B77F2D434B9741E8AC\n   - Pierre Schmitz <pierre@archlinux.de> (UNAUTHENTICATED)\n   - created 2011-04-10 09:35:33 UTC\n   - found via: WKD\n\nHint: To extract a particular certificate from release-key.pgp, use any of:\n\n  $ sq cert export --keyring=release-key.pgp --cert=3E80CA1A8B89F69CBA57D98A76A5EF9054449A5C\n\n  $ sq cert export --keyring=release-key.pgp --cert=4AA4767BBC9C4B1D18AE28B77F2D434B9741E8AC\n```\n\nExport the chosen key to a `.pgp` file:\n\n```bash\nsq cert export --keyring=release-key.pgp --cert=3E80CA1A8B89F69CBA57D98A76A5EF9054449A5C > pierre-archlinux.pgp\n```\n\nImport into your keychain:\n\n```bash\n gpg --import pierre-archlinux.pgp\ngpg: key 0x76A5EF9054449A5C: 9 signatures not checked due to missing keys\ngpg: key 0x76A5EF9054449A5C: public key \"Pierre Schmitz <pierre@archlinux.org>\" imported\ngpg: Total number processed: 1\ngpg:               imported: 1\ngpg: marginals needed: 3  completes needed: 1  trust model: pgp\ngpg: depth: 0  valid:   3  signed:   0  trust: 0-, 0q, 0n, 0m, 0f, 3u\ngpg: next trustdb check due at 2026-08-23\n```\n\nNow, you should see `<pierre@archlinux.org>` and his keys when you run\n`gpg --list-keys`\n\nFinally, verify the signature:\n\n```bash\nsq verify --signer-file release-key.pgp --signature-file archlinux-2025.08.01-x86_64.iso.sig archlinux-2025.08.01-x86_64.iso\nAuthenticated signature made by 3E80CA1A8B89F69CBA57D98A76A5EF9054449A5C (Pierre Schmitz <pierre@archlinux.org>)\n\n1 authenticated signature.\n```\n\nThis shows that the signature was made by the key with the ID\n`3E80CA1A8B89F69CBA57D98A76A5EF9054449A5C` (Pierre Schmitz).\n\nGPG authenticated that the signature is valid and that the key used to sign is\ntrusted in our keyring.\n\n1 authenticated signature confirms the files integrity and authenticity.\n\nWe have successfully verified that the file was signed by Pierr's official Arch\nLinux key and has not been tampered with.\n\nSince the key has been verified we can now sign it. We will have to import our\nprimary key to do so since we are keeping it offline for safety.\n\n```bash\ngpg --import backup.gpg\n```\n\nList your keys to get the arch keyID:\n\n```bash\ngpg --list-keys\n# ... snip ...\npub   ed25519/0x76A5EF9054449A5C 2022-10-31 [SC] [expires: 2037-10-27]\n      Key fingerprint = 3E80 CA1A 8B89 F69C BA57  D98A 76A5 EF90 5444 9A5C\nuid                   [  full  ] Pierre Schmitz <pierre@archlinux.org>\nuid                   [  full  ] Pierre Schmitz <pierre@archlinux.de>\nsub   ed25519/0xD6D13C45BFCFBAFD 2022-10-31 [A] [expires: 2037-10-27]\nsub   cv25519/0x7F56ADE50CA3D899 2022-10-31 [E] [expires: 2037-10-27]\n```\n\nSign the key:\n\n```bash\ngpg --sign-key 0x76A5EF9054449A5C\n```\n\nNow you can Export and publish the new public key and send it to a keyserver:\n\n```bash\ngpg --export --armor 0x76A5EF9054449A5C > archlinux-signed.asc\ngpg --send-keys 0x76A5EF9054449A5C\n```\n\nThe more people that verify, sign, and re-export and publish their keys the\nbetter for the web of trust that gpg uses making the network more secure for\neveryone.\n\n### Edit your trust level of the key\n\n```bash\ngpg --edit-key pierre@archlinux.org\ngpg> trust\nPlease decide how far you trust this user to correctly verify other users' keys\n(by looking at passports, checking fingerprints from different sources, etc.)\n\n  1 = I don't know or won't say\n  2 = I do NOT trust\n  3 = I trust marginally\n  4 = I trust fully\n  5 = I trust ultimately\n  m = back to the main menu\n\nYour decision? 3\n# Output:\npub  ed25519/0x76A5EF9054449A5C\n     created: 2022-10-31  expires: 2037-10-27  usage: SC\n     trust: marginal      validity: full\n```\n\nYou can see that the trust is `marginal` and validity is `full`.\n\n</details>\n","number":[1,3,4],"sub_items":[],"path":"nix/gpg-agent.md","source_path":"nix/gpg-agent.md","parent_names":["Getting Started with the Nix Ecosystem","Cachix and the devour-flake"]}},{"Chapter":{"name":"Hardening Networking","content":"# Hardening Networking\n\n<details>\n<summary> Click to Expand Table of Contents</summary>\n\n<!-- toc -->\n\n</details>\n\n> Since networks and systems vary, some adjustments may cause unexpected issues,\n> especially around critical components like DNS or firewalls. Always review and\n> test changes in a controlled environment before applying them broadly.\n\n> Understand the trade-offs and tailor the settings to your threat model and\n> workflow. Take what’s useful, adapt as needed, and seek expert guidance for\n> more advanced scenarios.\n\n## Introduction\n\nEvery setup is unique, feel free to adapt or skip sections based on your needs.\nStart with the basics and build up as you gain confidence. The goal is\npractical, tested hardening tailored to you.\n\n### Safe Browsing / Privacy Enhancing Habits\n\n**Adopt Encrypted DNS and HTTPS Everywhere**\n\n- Configure your system and browsers to use DNS over HTTPS (DoH), DNS over TLS\n  (DoT), or DNSCrypt to prevent DNS leakage. Use HTTPS-Only mode in browsers to\n  encrypt all web traffic. Prefer browsers with strong privacy defaults or add\n  recommended extensions.\n\n- [Privacy Guides dnscrypt-proxy recommendation](https://www.privacyguides.org/en/dns/#dnscrypt-proxy)\n\n- Disable browser \"remember password\" and autofill features, clear cookies and\n  site data upon exit, and carefully vet suspicious URLs with tools like\n  [VirusTotal](https://www.virustotal.com/gui/home/url).\n\n**Limit Account Linking and Use Unique Credentials**\n\n- Create separate accounts with unique passwords instead of signing in with\n  Google, Facebook, or similar services to limit broad data exposure from\n  compromises.\n\n**Use Metadata Cleaning Tools**\n\n- Many files like images, PDFs, and office documents contain hidden metadata\n  information such as location data, device details, and more that can reveal\n  your identity or other sensitive information when you share files publicly.\n\n- To protect your privacy, always sanitize files by removing this metadata\n  before sharing. Tools like [mat2](https://0xacab.org/jvoisin/mat2) are\n  designed to strip metadata from a wide range of media files efficiently.\n  (`pkgs.mat2`). You just type `mat2 swappy-2025.png` for example and there will\n  then be a new `mat2 swappy-2025.cleaned.png` that can safely be shared.\n\n**Use Anonymous File-Sharing Tools**\n\n- For sensitive transfers, consiter tools like\n  [OnionShare](https://github.com/onionshare/onionshare) that provide anonymity\n  and security.(`pkgs.onionshare`)\n\n**Avoid Scanning Random QR Codes Without Verification**\n\n- Use QR code scanner apps that check for malicious content before loading\n  links.\n\n**Understand Your Threat Model**\n\n- Apply these basics universally, but tailor advanced hardening according to\n  your unique environment, connectivity needs, and risk profile.\n\n**Delete cookies and site data when the browser is closed**. (security not\nusability).\n\n**Use Strong, Unique Passwords and a Password Manager**\n\n- Avoid reused passwords by using reliable password managers like KeePassXC or\n  Bitwarden, both available on NixOS. Pair this with enabling two-factor\n  authentication **(2FA) wherever possible**.\n\n- It's advisable to only use the desktop version and not the browser extension\n  for a number of reasons. One is that you can store your passwords completely\n  offline and have complete ownership of them.\n\n```nix\nenvironment.systemPackages = [\n    pkgs.keepassxc\n    pkgs.kpcli     # KeePass CLI\n    # OR\n    pkgs.bitwarden-desktop\n    pkgs.bitwarden-cli\n];\n```\n\nWith KeePassXC, you can require 3 different authentication methods at the same\ntime. You can choose a password, a keyfile, and a security key where it won't\nopen unless all 3 are present giving you additional security. All 3 might not be\nnecessary but it's possible. It's also easy to migrate to KeePassXC, you can\nimport your vault from many different managers.\n\nKeepassXC also makes it easy to keep your complete password database offline\nwhich can significantly reduce the risk of a breach.\n\nWith Bitwarden, to enable 2 factor authentication, you need to log in with your\nmaster password through the web interface.\n\n- [PrivacyGuides Intro to Passwords](https://www.privacyguides.org/en/basics/passwords-overview/)\n\n---\n\n### Why Follow These Basics?\n\nThese recommended steps help protect your privacy and security while maintaining\nusability and minimizing system interruptions. They catch common threats like\nnetwork eavesdropping, password reuse, fingerprinting, and data leakage,\nproviding a solid foundation to build on.\n\nA vast majority of secure and privacy-focused browsers available for NixOS are\nbased on Firefox.\n\n> ❗ NOTE: Firefox does lack some security features available in Chrome and\n> sandbox escapes in Linux are relatively easy. People such as madaidan say to\n> never use Linux or Firefox period when you're worried about security and\n> privacy. I'm not personally going to jump to proprietary software with known\n> backdoors in a misguided attempt at increasing security/privacy.\n\n- [EU Hits Google with 3.5 Billion Antitrust](https://techstory.in/eu-hits-google-with-3-5-billion-antitrust-fine-over-adtech-practices/)\n\nThis [GrapheneOS article](https://grapheneos.org/usage#web-browsing), breaks\ndown why they use Chromium-based browsers and specifically mentions that it's\nnot recommended to use Firefox, especially on Linux because of the weak\nsandboxing.\n\nAs a Chromium-based browser, Brave has been growing on me. Brave uses\nrandomization rather than standardization for fingerprinting protection. If you\nrun Cover Your Tracks with Brave, it will show a randomized fingerprint.\n\n<details>\n<summary> ✔️ Click To Expand United States Patriot Act Overview </summary>\n\n[Section 215 USA Patriot Act](https://www.csis.org/analysis/fact-sheet-section-215-usa-patriot-act)\npermits the collection of \"Tangible Things\" or \"Business Records\", e.g., your\nphone records, medical records, etc. for an investigation to obtain foreign\nintelligence information. If it does relate to a US person it must be relevant\nto preventing terrorism or espionage, and not be based solely on activities\nprotected by the first amendment. \"Relevant\" is the key word here and it is at\nthe governments discretion meaning they sweep everything and sift it later.\nCriticized for violating American citizens Fourth Amendment protections against\nwarrantless search and seizure and proven to be ineffective.\n\n</details>\n\nWhat is \"normal\" and allowed today might be suppressed tomorrow, look at the UK\n[Online Safety Act](https://en.wikipedia.org/wiki/Online_Safety_Act_2023)\npurported to protect children, accused of banning privacy. This is because the\nonly way to verify age is to make everyone submit KYC with their drivers license\nor ID, completely taking away any anonymity of adults and children alike.\n\nAlso see\n[BBC 4chan refuses to pay fine](https://www.bbc.com/news/articles/cq68j5g2nr1o)\n\nThe mere existence of a surveillance state breeds fear and conformity and\nstifles free\nexpression.--[The Intercept](https://theintercept.com/2016/04/28/new-study-shows-mass-surveillance-breeds-meekness-fear-and-self-censorship/)\n\nThere are much more scary examples in\n[Privacy, The new Oil](https://thenewoil.org/en/guides/prologue/why/)\n\n## Protections from Surveillance in the U.S.\n\n<details>\n<summary> ✔️ Click to Expand U.S. Surveillance protections </summary>\n\n> ⚠️ A crucial caveat to keep in mind regarding surveillance protections in the\n> U.S., whether grounded in the Fourth Amendment, the First Amendment, or\n> statutory laws is that **these protections are not foolproof and have\n> repeatedly failed or been circumvented in practice**.\n\n- **Fourth Amendment Basics**: It demands reasonableness in searches and usually\n  requires a warrant. This means government agents cannot arbitrarily listen to\n  your private communications or search your digital data without judicial\n  approval\n\n- **Electronic Surveillance Challenges**: Courts have wrestled with how the\n  Fourth Amendment applies to modern communications. The Supreme Court has ruled\n  in some cases that pervasive or non-consensual electronic surveillance\n  violates reasonable expectations of privacy, but other rulings have allowed\n  broader state actions in national security contexts.\n\n- **The Third-Party Doctrine**: A major limitation arises from the \"third-party\n  doctrine,\" which holds that information voluntarily shared with third parties\n  (like phone companies or internet providers) has reduced Fourth Amendment\n  protections. This means data held by third parties may be subject to\n  government access without a warrant in some cases\n\n- **The First Amendment** guarantees free speech and the freedom to receive\n  information without government censorship or intimidation. Excessive or\n  secretive government surveillance can chill free speech by making people\n  afraid their communications are monitored, discouraging open expression and\n  participation in public discourse.\n  - Advocates argue that courts should recognize government surveillance not\n    only as a Fourth Amendment search issue but also as a First Amendment\n    violation where surveillance suppresses or chills constitutionally protected\n    expression.\n\nWhile the Fourth Amendment traditionally governs searches and surveillance\nlegality, the First Amendment frames the broader impact on free speech and\ndemocratic engagement. Invoking both provides a more comprehensive\nconstitutional shield against intrusive surveillance practices.\n\n</details>\n\n---\n\n### Choosing Secure/Private Browsers and Search Engines\n\n> \"The major problem with current systems is their inability to provide\n> effective isolation between various programs running on one machine. E.g. if\n> the user's Web browser gets compromised (due to a bug exploited by a malicious\n> web site), the OS is usually unable to protect other user's applications and\n> data from also being compromised.\" --Qubes arch-spec\n\nOn a hardened Linux system, the browser is most often the weakest link exposed\nto the internet, and so security, privacy, and anti-tracking features of\nbrowsers are now as important, or even more important than platform-level\nprotections.\n\n---\n\n### Fingerprinting\n\nThere are two main approaches to obfuscating your fingerprint:\n\n- **Standardization**: Make browsers standardized and therefore have the same\n  fingerprint to blend into a crowd. This is what Tor and Mullvad Browser do.\n  Best for anonymity; increases the crowd you blend into, but may decrease\n  usability (site breakage, CAPTCHAs); adversaries may still find subtle\n  differences.\n\n- **Randomization**: Randomize fingerprint metrics so it's not directly linkable\n  to you. Brave has this feature, if you run coveryourtracks with Brave you will\n  get a result of \"your browser has a randomized fingerprint\". This is good for\n  privacy but may be detectable by advanced scripts.\n\n---\n\n#### Firefox\n\nMy understanding here is evolving, Firefox on Linux may be very privacy friendly\nafter some tweaks, but is not necessarily a secure browser.\n\nFirefox's defaults are not privacy respecting or secure but allows a high level\nof customization to make it so. Firefox will be patched with security fixes\nsooner than any fork, and some forks are slow to apply the updates leaving a\nvulnerability open longer to exploit.\n\nThe Tor Uplift Project was a collaboration between the Tor Project and Mozilla\nto integrate key privacy and anti-fingerprinting features from the Tor Browser\ninto Firefox. This enables us to enable/disable a few settings and remove the\nneed for most add-ons.\n\nIf you use Firefox's ETP, RFP, and other protections provided by the ghacks or\nArkenfox scripts alongside uBlock configured to use dynamic filtering you can\naccomplish what it used to take 10 extensions to do.\n\nFirefox does implement Site Isolation with its Project Fission. This is much\nless mature than Chromes site isolation and often disabled by default on\ndifferent versions of Firefox. To ensure it's enabled, go to `about:config` and\ncheck that both `fission.autostart`, and `gfx.webrender.all` prefs are set to\n`true`.\n\nWith uBlock you can `Disable JavaScript` which functions similar to NoScript,\nenable numerous blocklists and more.\n\n- [uBlock Wiki](https://github.com/gorhill/uBlock/wiki)\n\nTo enable Enhanced Tracking Protection and FPP, go to\n`Settings -> Privacy & Security` -> `Enhanced Tracking Protection -> Custom`. If\nit causes breakage, while on the broken site, click the sheild next to the\nsearch bar. From there you can turn off ETP for **just that site**.\n\nOnce you select `Custom`, you'll see that among the options is to block\n`Known fingerprinters` as well as `Suspected fingerprinters`. The \"Known\nFingerprinters\" protection works by blocking scripts listed in\n[Disconnect's fingerprinting list](https://disconnect.me/trackerprotection#categories_of_trackers)\nFor most users they suggest using the above FPP to avoid breakage. To go further\nand enable RFP, go to `about:config` and set `privacy.resistFingerprinting` to\n`true`.\n\n- [Mozilla Resist Fingerprinting](https://support.mozilla.org/en-US/kb/resist-fingerprinting)\n\n- [Mozilla Project_Fission](https://wiki.mozilla.org/Project_Fission), Firefox's\n  implementation of Site Isolation.\n  - To ensure Site Isolation is enabled, in `about:config`, set\n    `fission.autostart`, and `gfx.webrender.all` prefs to `true`.(It's disabled\n    by default on android).\n\n---\n\n#### Tor Browser\n\n> ❗ NOTE: Tor is **not** the most secure browser, anonymity and security can\n> often be at odds with each other. Having the exact same browser as many other\n> people isn't the best security practice, but it is great for anonymity. Tor is\n> also based on Firefox Esr, which only receives patches for vulnerabilities\n> considered Critical or High which can be taken advantage of.\n\nTor is a modified version of Firefox specifically designed for use with Tor.\n\nTor routes your internet traffic through a global volunteer-operated network,\nmasking your IP address and activities from local observers, ISPs, websites, and\nsurveillance systems. This helps you protect personal information and maintain\nanonymity when browsing, communicating, or using online services.\n\nAdding browser plugins to Tor can de-anonymize you, don't do it. Tor is already\nbuilt with the necessary plugins and privacy protecting rules, so adding more is\nunnecessary and actually dangerous for your anonymity.\n\nA Tor exit node can easily see your traffic, and if you're not using HTTPS then\nit may be able to modify that traffic. Only use HTTPS when browsing the clear\nnet with Tor, this doesn't apply to onion services (`.onion`) as the traffic\nstays inside the Tor network all the way to the destination.\n\nYou can visit both the clear web and `.onion` sites on Tor. Whenever possible\nyou should utilize Onion Services (`.onion` addresses) so communications and web\nbrowsing stay within the Tor network. `.onion` URLS form a tunnel that is\nend-to-end encrypted using a random rendezvous point and incorporating\n[perfect forward secrecy (PFS)](https://en.wikipedia.org/wiki/Forward_secrecy).\n\nBridges are only necessary in countries that don't allow people to use Tor.\nUsing Bridges when they aren't needed takes resources away from people in\noppressive regimes that need, only use them if necessary. Read the guides, and\nuse Tails OS, or Whonix when it really matters.\n\n- [Whonix KVM on NixOS](https://saylesss88.github.io/nix/whonix_kvm.html)\n\nYou will see a lot of conflicting information about using Tor with a VPN. If you\nare in an area that blocks access to Tor or it is dangerous to use Tor, by all\nmeans use a trusted VPN.\n\n### TorPlusVPN\n\n- [Tor Project Wiki TorPlusVPN](https://gitlab.torproject.org/legacy/trac/-/wikis/doc/TorPlusVPN)\n\n- [Safely Connecting to Tor](https://www.privacyguides.org/en/advanced/tor-overview/#safely-connecting-to-tor)\n\n**Learn about Tor**\n\nI recommend starting with\n[Privacy Guides In Praise of Tor](https://www.privacyguides.org/articles/2025/04/30/in-praise-of-tor/#onion-sites-you-can-visit-using-the-tor-browser)\nand then reading their\n[Tor Overview](https://www.privacyguides.org/en/advanced/tor-overview/) they\nhave been the most informative resources I've come across yet.\n\nThe Electronic Frontier Foundation sponsors and helps fund Tor and so does the\nUnited States Government.\n\nIf you are fortunate to live outside of oppressive regimes with extreme\ncensorship, using Tor for every day, mundane activities is likely safe and won’t\nput you on any harmful “list.” Even if it did, you'd be in good company—these\nlists mostly contain great people working tirelessly to defend human rights and\nonline privacy worldwide.\n\nBy using Tor regularly for ordinary browsing, you help strengthen the network,\nmaking it more robust and anonymous for everyone. This collective support makes\nstaying private easier for activists, journalists, and anyone facing online\nsurveillance or censorship. The writer of the PrivacyGuides article mentions\nusing Tor when he needs to access Google Maps to protect his privacy\n\nSo, consider embracing Tor not only for sensitive browsing but also for daily\nroutine tasks. Every user adds valuable noise to the network, helping protect\nprivacy and freedom for all.\n\n**Tor is at risk, and needs our help**. Despite its strength and history, Tor\nisn't safe from the same attacks oppressive regimes and misinformed legislators\ndirect at encryption and many other privacy-enhancing\ntechnologies.--[How to Support Tor](https://www.privacyguides.org/articles/2025/04/30/in-praise-of-tor/#how-to-support-tor)\n\n- [Tor on NixOS](https://wiki.nixos.org/wiki/Tor)\n  - [Tor Browser User Manual](https://tb-manual.torproject.org/)\n\n  - [Tor staying-anonymous](https://support.torproject.org/faq/staying-anonymous/)\n\n  - [How to Use Tor](https://ssd.eff.org/module/how-to-use-tor)\n\n  - [Cool Graphic Showing Secure Connections with Tor](https://torproject.github.io/manual/secure-connections/)\n\n#### Mullvad-Browser\n\nRather than try to tweak a browser into fingerprinting submission, I recommend\nusing either Tor or Mullvad-Browser when fingerprintability is the highest\nissue. Both Tor and Mullvad-Browser were designed specifically for this purpose\nand you likely won't get as much out of tweaking another browser.\n\nMullvad-Browser is free and open-source and was developed by the Tor Project in\ncollaboration with Mullvad VPN.(Another Firefox Derivative). It is also the top\nrecommended browser from PrivacyGuides.\n\nIt is the Tor Browser without the Tor Network, allowing you to use the privacy\nfeatures Tor created along with a VPN if you so choose.\n\n- [Mullvad-Browser](https://mullvad.net/en/browser), is in Nixpkgs as:\n  `pkgs.mullvad-browser`\n\n## LibreWolf\n\n**LibreWolf** is an open-source fork of Firefox with a strong focus on privacy,\nsecurity, and user freedom. LibreWolf enables always HTTPS, includes\nuBlockOrigin, and only includes privacy focused search engines by default.\n\n### Metasearch Engines\n\n**Startpage**: Advertised as the world's most private search engine. \"Startpage\ndelivers Google search results via their proprietary personal data protection\ntechnology.\"\n\n- [Startpage](https://www.startpage.com/)\n\n- To add Startpage as a search engine, add\n  `https://www.startpage.com/sp/search?query=%s`.\n\n**SearXNG** an open-source, privacy-respecting metasearch engine that aggregates\nresults from various search services, such as Google, DuckDuckGo, etc. without\ntracking you or profiling your searches. You can add SearXNG to firefox by going\nto `about:preferences#search` and at the bottom click `Add`, URL will be\n`https://searx.be/search?q=%s`.\n\n> ❗️ NOTE: SearXNGs google results are not working as of 11-17-25 and haven't\n> for a while now leading to bad results being returned for most instances. It's\n> my understanding this is because Google is actively blocking automated\n> requests from SearXNG. Devs sometimes publish patches or workarounds, but\n> these are quickly blocked when Google changes their back-end.\n\n> ❗️ NOTE: The above searx is the default and doesn't give many relevant\n> results. To get relevant results find a\n> [public instance](https://searx.space/) with a good rating from your area and\n> add the `search?q=%s` to the end of it. For example, I'm using\n> `https://priv.au/search?q=%s`.\n\nSearx is a bit different, you can choose which search engine you want for your\ncurrent search with `!ddg search term` to use duckduckgo for example.\n\nExample LibreWolf config implementing many of the STIG recommendations:\n\n<details>\n<summary> ✔️ Click to expand LibreWolf Example </summary>\n\n```nix\n# librewolf.nix\n{pkgs, lib, config, ...}: let\n  cfg = config.custom.librewolf;\nin {\n  options.custom.librewolf = {\n    enable = lib.mkOption {\n      type = lib.types.bool;\n      default = true;\n      description = \"Enable the LibreWolf Module\";\n    };\n  };\n\n  config = lib.mkIf cfg.enable {\n    programs.librewolf = {\n      enable = true;\n      policies = {\n        # A bit annoying\n        DontCheckDefaultBrowser = true;\n        # Pocket is insecure according to DoD\n        DisablePocket = true;\n        # No imperative updates\n        DisableAppUpdate = true;\n      };\n      settings = {\n        # // SV-16925 - DTBF030\n        \"security.enable_tls\" = true;\n        # // SV-16925 - DTBF030\n        \"security.tls.version.min\" = 2;\n        # // SV-16925 - DTBF030\n        \"security.tls.version.max\" = 4;\n\n        # // SV-111841 - DTBF210\n        \"privacy.trackingprotection.fingerprinting.enabled\" = true;\n\n        # // V-252881 - Retaining Data Upon Shutdown\n        \"browser.sessionstore.privacy_level\" = 0;\n\n        # // SV-251573 - Customizing the New Tab Page\n        \"browser.newtabpage.activity-stream.enabled\" = false;\n        \"browser.newtabpage.activity-stream.feeds.section.topstories\" = false;\n        \"browser.newtabpage.activity-stream.showSponsored\" = false;\n        \"browser.newtabpage.activity-stream.feeds.snippets\" = false;\n\n        # // V-251580 - Disabling Feedback Reporting\n        \"browser.chrome.toolbar_tips\" = false;\n        \"browser.selfsupport.url\" = \"\";\n        \"extensions.abuseReport.enabled\" = false;\n        \"extensions.abuseReport.url\" = \"\";\n\n        # // V-251558 - Controlling Data Submission\n        \"datareporting.policy.dataSubmissionEnabled\" = false;\n        \"datareporting.healthreport.uploadEnabled\" = false;\n        \"datareporting.policy.firstRunURL\" = \"\";\n        \"datareporting.policy.notifications.firstRunURL\" = \"\";\n        \"datareporting.policy.requiredURL\" = \"\";\n\n        # // V-252909 - Disabling Firefox Studies\n        \"app.shield.optoutstudies.enabled\" = false;\n        \"app.normandy.enabled\" = false;\n        \"app.normandy.api_url\" = \"\";\n\n        # // V-252908 - Disabling Pocket\n        \"extensions.pocket.enabled\" = false;\n\n        # // V-251555 - Preventing Improper Script Execution\n        \"dom.disable_window_flip\" = true;\n\n        # // V-251554 - Restricting Window Movement and Resizing\n        \"dom.disable_window_move_resize\" = true;\n\n        # // V-251551 - Disabling Form Fill Assistance\n        \"browser.formfill.enable\" = false;\n\n        # // V-251550 - Blocking Unauthorized MIME Types\n        \"plugin.disable_full_page_plugin_for_types\" = \"application/pdf,application/fdf,application/xfdf,application/lso,application/lss,application/iqy,application/rqy,application/lsl,application/xlk,application/xls,application/xlt,application/pot,application/pps,application/ppt,application/dos,application/dot,application/wks,application/bat,application/ps,application/eps,application/wch,application/wcm,application/wb1,application/wb3,application/rtf,application/doc,application/mdb,application/mde,application/wbk,application/ad,application/adp\";\n      };\n    };\n    xdg.desktopEntries.librewolf = {\n      name = \"LibreWolf\";\n      exec = \"${pkgs.librewolf}/bin/librewolf\";\n    };\n    xdg.mimeApps = {\n      enable = true;\n      defaultApplications = {\n        \"text/html\" = \"librewolf.desktop\";\n        \"x-scheme-handler/http\" = \"librewolf.desktop\";\n        \"x-scheme-handler/https\" = \"librewolf.desktop\";\n        \"x-scheme-handler/about\" = \"librewolf.desktop\";\n        \"x-scheme-handler/unknown\" = \"librewolf.desktop\";\n      };\n    };\n  };\n}\n```\n\nAnd enable it in your `home.nix` or equivalent with:\n\n```nix\n# home.nix\ncustom.librewolf.enable = true;\n```\n\nThe `xdg` settings at the end make LibreWolf the defaults for what is listed.\n\nThanks to `JosefKatic` for putting the above STIG settings in NixOS format.\n\nAlso, go to\n[accounts.firefox](https://accounts.firefox.com/settings#data-collection) and\nturn off \"Allow Mozilla accounts to send technical and interaction data to\nMozilla\". Also set 2-fa in\n[Security Settings](https://accounts.firefox.com/settings#security)\n\nI always set `Max Protection` for DNS over HTTPS and personally set a custom\nresolver to `https://dns.quad9.net/dns-query`\n\n- Mullvad is also a good option:\n  [Mullvad no-logging-data-policy](https://mullvad.net/en/help/no-logging-data-policy)\n\nFirefox Relay is a pretty cool privacy tool too, it gives you temporary email\nand phone number aliases so you don't have to give out your real ones. There is\nan autofill option available also, but you can just click on the Relay button\nand generate a new alias and use it like your normal email.\n\n<details>\n<summary> ✔️ Alternative LibreWolf Configuration utilizing Arkenfox </summary>\n\n```nix\n{\n  pkgs,\n  lib,\n  config,\n  ...\n}: let\n  cfg = config.custom.librewolf;\nin {\n  options.custom.librewolf = {\n    enable = lib.mkOption {\n      type = lib.types.bool;\n      default = true;\n      description = \"Enable the LibreWolf Module\";\n    };\n  };\n\n  config = lib.mkIf cfg.enable {\n    programs.librewolf = {\n      enable = true;\n      policies = {\n        DontCheckDefaultBrowser = true;\n        DisablePocket = true;\n        DisableAppUpdate = true;\n      };\n      profiles.my-default = {\n        isDefault = true;\n        name = \"Default Profile\";\n        extraConfig = ''\n          ${builtins.readFile ./user.js}\n          \"general.autoScroll\" = true;\n          \"sidebar.verticalTabs\" = true;\n        '';\n\n        settings = {\n        };\n      };\n    };\n    xdg.desktopEntries.librewolf = {\n      name = \"LibreWolf\";\n      exec = \"${pkgs.librewolf}/bin/librewolf\";\n    };\n    xdg.mimeApps = {\n      enable = true;\n      defaultApplications = {\n        \"text/html\" = \"librewolf.desktop\";\n        \"x-scheme-handler/http\" = \"librewolf.desktop\";\n        \"x-scheme-handler/https\" = \"librewolf.desktop\";\n        \"x-scheme-handler/about\" = \"librewolf.desktop\";\n        \"x-scheme-handler/unknown\" = \"librewolf.desktop\";\n      };\n    };\n  };\n}\n```\n\nDownload the\n[Arkenfox user.js](https://github.com/arkenfox/user.js/blob/master/user.js) and\nreview it making sure that you agree with the settings. If you do, place it in\nthe same directory as your `librewolf.nix`.\n\nRead the [Arkenfox Wiki](https://github.com/arkenfox/user.js/wiki)\n\nThe `user.js` is full of comments and information, read it and adjust it for\nyour needs. The following enables RFP fingerprint protection:\n\n```js\n***/ user.js ***/\nuser_pref(\"privacy.resistFingerprinting\", true); // [FF41+]\nuser_pref(\"privacy.resistFingerprinting.pbmode\", true); // [FF114+]\n```\n\nAs you learn more, you can get more strict if you so choose.\n\nRebuild, launch LibreWolf, and check your `~/.librewolf/my-default/user.js`. It\nshould match the Arkenfox settings. Initially, only the `user.js` will be\nlisted, as you run LibreWolf other profile files and folders are created\ndynamically.\n\nIn LibreWolf type `Ctrl + Shift + J` and look for any errors.\n\nType `about:config` into the address bar and search a few of the settings that\nArkenfox changes, do they match?\n\nThe `user.js` is read **in order**, if there are 2 of the same setting, the last\none will be applied. Adding overrides to the settings attribute above places the\nchanges at the **beginning** of the `user.js` which isn't what we want. Placing\nthem after the `${builtins.readFile ./user.js}` in `extraConfig` amends them to\nthe **end** of the `user.js` allowing us to override the defaults.\n\nThe process is the same with Firefox but since Arkenfox strongly recommends\nUblock Origin and it is built into LibreWolf it makes sense to use the browser\nwith the stronger defaults.\n\n> ❗ NOTE: There is a home-manager module called `arkenfox-nixos` that is\n> supposed to make updates easier but IMO the documentation leaves you guessing\n> how to use it. As updates come in to Firefox/LibreWolf some of the settings\n> become unnecessary so it's important to keep an eye on both Firefox and\n> Arkenfox updates. Which both have RSS feeds that will alert you upon changes.\n\nI personally use [Feeder](https://feeder.co/) as my open-source RSS feed reader,\navailable in most app stores including F-Droid. It is listed on\n[PrivacyTools](https://www.privacytools.io/privacy-rss-feed-readers).\n\n- [Arkenfox Recent Commits RSS feed](https://github.com/arkenfox/user.js/commits/master.atom)\n\n- [Arkenfox Release Notes RSS](https://github.com/arkenfox/user.js/releases.atom)\n\n- [Firefox Nightly release notes](https://www.mozilla.org/en-US/firefox/nightly/notes/feed/)\n\n</details>\n\n</details>\n\n### Fingerprint Testing\n\nYou can test your browser to see how well you are protected from tracking and\nfingerprinting at [Cover Your Tracks](https://coveryourtracks.eff.org/).\n\nAlso check out, [Am I Unique](https://amiunique.org/fingerprint)\n\n> ⚠️ WARNING: Don't put too much weight into the results as people often check\n> their fingerprint, change one metric and check it again over and over skewing\n> the results. It is helpful for knowing the fingerprint values that trackers\n> track.\n\n- [Browser Fingerprinting Tor Forum](https://forum.torproject.org/t/browser-fingerprinting/1228/25)\n\n- [Madaidans Hot Take on Browser Tracking](https://madaidans-insecurities.github.io/browser-tracking.html)\n\n<details>\n<summary> ✔️ Click to Expand Script to wipe cache and generate new `machine-id` </summary>\n\n- [man page machine-id(5)](https://www.man7.org/linux/man-pages/man5/machine-id.5.html)\n\n- The following example is adapted from\n  [Firejail All About Tor](https://firejail.wordpress.com/all-about-tor/)\n  section, adapted for NixOS.\n\nSave the following script as `cleanup.sh`, change `Your-User` to your username:\n\n```bash\n#!/bin/sh -e\nUSER=\"Your-User\"\nHOME_DIR=\"/home/$USER\"\n# clear user cache directly as root\nsudo -u \"$USER\" rm -fr \"$HOME_DIR/.cache\"\n# generate a new machine-id\nrm -f /var/lib/machine-id\ndbus-uuidgen > /var/lib/machine-id\ncp /var/lib/machine-id /etc/machine-id\nchmod 444 /etc/machine-id\nexit 0\n```\n\nThe `~/.cache` directory is where most programs store runtime information:\nwebpages you visited, torrent trackers you connected to, and deleted emails.\nIt's a good idea to remove them at shutdown. --Firejail all-about-tor\n\nCheck `/etc/machine-id` & `~/.cache` before running the script:\n\n```bash\ncat /etc/machine-id\n# Output\n0b46feb27a20469da0ee62baaeb51c5c\nls ~/.cache\n```\n\n```bash\nchmod +x cleanup.sh\nsudo ./cleanup.sh\n```\n\nRecheck your `machine-id` and `~/.cache` directories, you should have a newly\ngenerated `machine-id` and minimal files in the `~/.cache` directory. The\nFirejail example shows a systemd unit that runs the above script at every\nshutdown but that may be overkill, I suggest running it occasionally to make it\nharder for sites to link your `machine-id` to you.\n\n</details>\n\nPrivacy protection doesn't need to be perfect to make a difference. The best\nprotection against tracking and fingerprinting available is to use Tor. Many\nadd-ons are redundant, do some research and avoid using an add-on for something\nthat can be accomplished with built-in settings.\n\n- [Surveillance Self-Defense How to: Use Tor](https://ssd.eff.org/module/how-to-use-tor)\n\nThere are more hardening parameters that can be set but this should be a good\nstarting point for a hardened version of LibreWolf. When testing with Cover your\ntracks, customized LibreWolf tested as having stronger tracking protection than\ndefault Mullvad-Browser and NoScript significantly cuts down the data available\nfor fingerprinting by disabling JavaScript.\n\n- The [Garuda Privacy-Guide](https://wiki.garudalinux.org/en/privacy-guide) has\n  good tips and recommendations for browser add-ons.\n\n### Virtual Private Networks (VPNs)\n\nA **VPN** (Virtual Private Network) encrypts your Internet connection and routes\nyour traffic through a VPN provider’s servers, masking your IP address from\nlocal network observers, ISPs, and websites. Using a VPN can prevent your ISP or\nlocal Wi-Fi owner from tracking what sites you visit (they only see a connection\nto the VPN), and can help circumvent some regional restrictions or filtering.\n\nHowever, VPNs simply shift your trust: Instead of your ISP seeing your activity,\nyour VPN provider can, so you must trust their privacy policies and\ninfrastructure. Quality and privacy protections vary widely from one VPN company\nto another.\n\nI see over and over again that Mullvad VPN is the best, I am in no way\naffiliated with them this is just what I hear. They allow you to pay with cash\ncompletely anonymously and keep very minimal metadata. Metadata is a big deal,\nthe US gov has admitted to killing people based solely on their metadata.\n\nYour ISP almost certainly does sketchy stuff with your data, personally I would\nrather trust a company like Mullvad whose whole reputation is based on their\ntrustworthiness, transparency, and data protection.\n\nYou can use a VPN with Tor, but it's not recommended by the Tor Project unless\nyou're an advanced user who knows how to configure both in a way that doesn't\ncompromise your privacy.\n\n**Popular VPNs on NixOS**\n\n- [Mullvad VPN](https://wiki.nixos.org/wiki/Mullvad_VPN) Mullvad VPN uses\n  WireGuard under the hood and only works if `systemd-resolvd` is enabled.\n\n- [WireGuard VPN](https://wiki.nixos.org/wiki/WireGuard), WireGuard is a\n  protocol, but also a VPN provider on NixOS.\n\n- [Tailscale](https://wiki.nixos.org/wiki/Tailscale)\n\n- [OpenVPN](https://wiki.nixos.org/wiki/OpenVPN), OpenVPN is both a protocol and\n  full-featured VPN provider on NixOS.\n\n### Setting up Tailscale\n\nI was surprised at how easy this actually was to set up. Either go to\n<https://www.tailscale.com> and/or download the app for either Android or IOS,\nsign up with your identity provider, and click `Start connecting devices ->`\n\n- [Tailscale quickstart](https://tailscale.com/kb/1017/install)\n\nTo add tailscale to NixOS:\n\n```nix\n# tailscale.nix\n{...}: {\n  services.tailscale.enable = true;\n  # Tell the firewall to implicitly trust packets routed over Tailscale:\n  networking.firewall.trustedInterfaces = [\"tailscale0\"];\n}\n```\n\nTailscale will automatically use the hostname of your device as the name of the\nnetwork. If you want to change it to something else:\n\n```bash\nsudo tailscale set --hostname=<name>\n# You can also give your account a nickname\nsudo tailscale set --nickname=<name>\n```\n\nThis allows you to refer to your network by `name` rather than IP address.\n\nTailscale uses [MagicDNS](https://tailscale.com/kb/1081/magicdns) which is\nenabled by default, and they recommend you keep it enabled.\n\nThe docs say that by default, devices in your tailnet prefer their local DNS\nsettings and only use the tailnet's DNS servers when needed. I had to completely\ndisable my Androids DNS settings for tailscale to access the internet through\nMagicDNS.\n\n```bash\nsudo tailscale set --accept-dns=false\n```\n\nTo connect to tailscale after rebuilding you can run:\n\n```bash\nsudo tailscale up\n```\n\nUse `nslookup` to review and debug DNS responses:\n\n```bash\nnslookup google.com\nServer:         127.0.0.1\nAddress:        127.0.0.1#53\n\nNon-authoritative answer:\nName:   google.com\nAddress: 142.251.40.206\nName:   google.com\nAddress: 2a00:1450:4001:827::200e\n```\n\n- The `127.0.0.1#53` indicate that instead of using the DNS server pushed by\n  your ISP, router, or Tailscale's MagicDNS, the system is sending all DNS\n  requests through the loopback device to `dnscrypt-proxy` in my case.\n\nGet the status of your connections to other Tailscale devices:\n\n```bash\ntailscale status\n1           2         3           4         5\n100.1.2.3   device-a  apenwarr@   linux     active; direct <ip-port>, tx 1116 rx 1124\n100.4.5.6   device-b  crawshaw@   macOS     active; relay <relay-server>, tx 1351 rx 4262\n100.7.8.9   device-c  danderson@  windows   idle; tx 1214 rx 50\n100.0.1.2   device-d  ross@       iOS       —\n```\n\n- [Tailscale Best Practices](https://tailscale.com/kb/1196/security-hardening)\n\n- [Tailscale CLI](https://tailscale.com/kb/1080/cli)\n\n- There is much more you can do with Tailscale, including integrating\n  Mullvad-VPN and using Exit Nodes.\n\n## Encrypted DNS\n\nDNS (Domain Name System) resolution is the process of translating a website's\ndomain name into its corresponding IP address. By default, this traffic isn't\nencrypted, which means anyone on the network, from your ISP to potential\nhackers, can see the websites you're trying to visit. **Encrypted DNS** uses\nprotocols to scramble this information, protecting your queries and responses\nfrom being intercepted and viewed by others.\n\n> ❗ NOTE: There are many other ways for someone monitoring your traffic to see\n> what domain you looked up via DNS that it's effectiveness is questionable\n> without also using Tor or a VPN. Encrypted DNS will not help you hide any of\n> your browsing activity.\n\nThere are 3 main types of DNS protection:\n\n- **DNS over HTTPS (DoH)**: Uses the HTTPS protocol to encrypt data between the\n  client and the resolver.\n\n- **DNS over TLS (DoT)**: Similar to (DoH), differs in the methods used for\n  encryption and delivery using a separate port from HTTPS.\n\n- **DNSCrypt**: Uses end-to-end encryption with the added benefit of being able\n  to prevent DNS spoofing attacks.\n\nUseful resources:\n\n<details>\n<summary> ✔️ Click to Expand DNS Resources </summary>\n\n- [NixOS Wiki Encrypted DNS](https://wiki.nixos.org/wiki/Encrypted_DNS)\n\n- [Domain Name System (DNS)](https://www.cloudflare.com/learning/dns/what-is-dns/)\n\n- [Wikipedia DNS over HTTPS (DoH)](https://en.wikipedia.org/wiki/DNS_over_HTTPS)\n\n- [Wikipedia DNS over TLS (DoT)](https://en.wikipedia.org/wiki/DNS_over_TLS)\n\n- [Cloudflare Dns Encryption Explained](https://blog.cloudflare.com/dns-encryption-explained/)\n\n- [NordVPN Encrypted Dns Traffic](https://nordvpn.com/blog/encrypted-dns-traffic/)\n\n**Hot Take**:\n\n- [Encrypted DNS is ineffective without a VPN or Tor by madaidan](https://madaidans-insecurities.github.io/encrypted-dns.html)\n\n</details>\n\nThe following sets up dnscrypt-proxy using DoH (DNS over HTTPS) with an oisd\nblocklist, they both come directly from the Wiki:\n\nAdd `oisd` to your flake inputs:\n\n```nix\n# flake.nix\ninputs = {\n    oisd = {\n      url = \"https://big.oisd.nl/domainswild\";\n      flake = false;\n    };\n};\n```\n\n> ❗ NOTE: The `oisd` blocklist is a plain text file that updates frequently.\n> This can cause `nh os switch` to fail with a `NarHash` mismatch error. To fix\n> this, you need to run `nix flake update` to refresh the blocklist and its hash\n> in your `flake.lock` file. After that, you can run your `nh` command again.\n\nAnd the import the following into your `configuration.nix`:\n\n```nix\n# dnscrypt-proxy.nix\n{\n  pkgs,\n  lib,\n  inputs,\n  ...\n}: let\n  blocklist_base = builtins.readFile inputs.oisd;\n  extraBlocklist = '''';\n  blocklist_txt = pkgs.writeText \"blocklist.txt\" ''\n    ${extraBlocklist}\n    ${blocklist_base}\n  '';\n  hasIPv6Internet = true;\n  StateDirectory = \"dnscrypt-proxy\";\nin {\n  networking = {\n    # Set DNS nameservers to the local host addresses for iPv4 (`127.0.0.1`) & iPv6 (::1)\n    nameservers = [\"127.0.0.1\" \"::1\"];\n    # If using dhcpcd\n    # dhcpcd.extraConfig = \"nohook resolv.conf\";\n    # If using NetworkManager\n    networkmanager.dns = \"none\";\n  };\n  services.resolved.enable = lib.mkForce false;\n  # See https://wiki.nixos.org/wiki/Encrypted_DNS\n  services.dnscrypt-proxy2 = {\n    enable = true;\n    # See https://github.com/DNSCrypt/dnscrypt-proxy/blob/master/dnscrypt-proxy/example-dnscrypt-proxy.toml\n    settings = {\n      # See https://github.com/DNSCrypt/dnscrypt-resolvers/blob/master/v3/public-resolvers.md\n      sources.public-resolvers = {\n        urls = [\n          \"https://raw.githubusercontent.com/DNSCrypt/dnscrypt-resolvers/master/v3/public-resolvers.md\"\n          \"https://download.dnscrypt.info/resolvers-list/v3/public-resolvers.md\"\n        ];\n        minisign_key = \"RWQf6LRCGA9i53mlYecO4IzT51TGPpvWucNSCh1CBM0QTaLn73Y7GFO3\";\n        cache_file = \"/var/lib/${StateDirectory}/public-resolvers.md\";\n      };\n     # sources.quad9-resolvers = {\n     #   urls = [\n     #     \"https://quad9.net/dnscrypt/quad9-resolvers.md\"\n     #     \"https://raw.githubusercontent.com/Quad9DNS/dnscrypt-settings/main/dnscrypt/quad9-resolvers.md\"\n     #   ];\n     #   minisign_key = \"RWTp2E4t64BrL651lEiDLNon+DqzPG4jhZ97pfdNkcq1VDdocLKvl5FW\";\n     #   cache_file = \"/var/cache/dnscrypt-proxy/quad9-resolvers.md\";\n     # };\n\n      # Use servers reachable over IPv6 -- Do not enable if you don't have IPv6 connectivity\n      ipv6_servers = hasIPv6Internet;\n      block_ipv6 = ! hasIPv6Internet;\n      blocked_names.blocked_names_file = blocklist_txt;\n      require_dnssec = true;\n      # Logs can get large very quickly...\n      require_nolog = false;\n      # This stops dns malware filtering, etc. if true\n      require_nofilter = false;\n      dnscrypt_servers = true;\n\n      # If you want, choose a specific set of servers that come from your sources.\n      # Here it's from https://github.com/DNSCrypt/dnscrypt-resolvers/blob/master/v3/public-resolvers.md\n      # If you don't specify any, dnscrypt-proxy will automatically rank servers\n      # that match your criteria and choose the best one.\n      # server_names = [ ... ];\n      # server_names = ['quad9-dnscrypt-ip6-filter-pri', 'quad9-dnscrypt-ip4-filter-pri', 'mullvad-adblock-d'];\n\n    };\n  };\n\n  systemd.services.dnscrypt-proxy2.serviceConfig.StateDirectory = StateDirectory;\n}\n```\n\n> ❗️ NOTE: Upon testing dnscrypt-proxy on Arch, it was able to route the browser\n> through the proxy, removing the need for Max Protection. I'm still currently\n> on Arch and plan to test this further ASAP. We test the above settings further\n> down, but I'm curious why the browser isn't routed correctly...\n\n- Above, we have a local DNS proxy that encrypts and forwards queries.\n\n```bash\n# You should see that dnscrypt-proxy chooses the Server with the lowest initial latency\nsudo systemctl status dnscrypt-proxy2\n# verify that dnscrypt-proxy is listening\nsudo ss -lnp | grep 53\n# Test a DNS query, if you get valid responses it's working\ndig @127.0.0.1 example.com +short\n# check the logs\nsudo journalctl -u dnscrypt-proxy2\n```\n\n`dnscrypt-proxy2` acts as your local DNS resolver listening on your machine\n(`127.0.0.1`) for IPv4 and `::1` for iPv6.\n\nThe system's DNS settings (`networking.nameservers`) point to localhost, so\n**all DNS queries** go to dnscrypt-proxy accept for your browser. Your browser\nhas to be configured separately with a local resolver in which I haven't figured\nout yet. I recommend setting your browsers DNS over HTTPS to strict with a\nrespected custom DNS resolver such as `https://dns.quad9.net/dns-query`.\n\n`inputs.oisd` refers to the flake input oisd blocklist, it prevents your device\nfrom connecting to unwanted or harmful domains.\n\n`dnscrypt-proxy2` then encrypts and forwards our DNS requests to third-party\npublic DNSCrypt or DoH servers.\n\n## MAC Randomization\n\nAll network cards have a unique identifier called a MAC address. They're stored\nin hardware and are used to assign an address to computers on the local network.\n\nThe MAC address is typically only traceable on the local network, it's not\npassively sent out beyond the local router making it more critical on untrusted,\npublic networks.\n\nLeak-proof MAC randomization is very difficult to implement:\n\n- [Leak-proof MAC Randomization Implementation Challenges](https://www.kicksecure.com/wiki/Dev/MAC#Leak-proof_MAC_Randomization_-_Technical_Implementation_Challenges)\n\nAndroid and iPhone already implement MAC Randomization by default.\n\nMAC Randomization enhances privacy by making it harder for third parties to\ntrack users across different networks.\n\nRandomizing MAC adresses obscures a device's unique hardware identity when\nscanning for or connecting to Wi-Fi, blocking passive tracking as well as\nlocation tracking across networks.\n\nIf you use NetworkManager you can set MAC randomization with:\n\n```nix\n    networking = {\n      networkmanager = {\n        enable = true;\n        wifi.scanRandMacAddress = true;\n        wifi.macAddress = \"random\";\n        plugins = [];\n      };\n```\n\nRight when I rebuilt, I got an alert from my router saying that a new device\njust connected to the network.\n\nThere is also a utility for viewing/manipulating the MAC address of network\ninterfaces, `pkgs.macchanger`. This is less reliable than the NetworkManager\nsetting.\n\n## Firewalls\n\nNixOS includes an integrated firewall based on iptables/nftables.\n\n<details>\n<summary> ✔️ Click to Expand Firewall Resources </summary>\n\n[Cloudflare What is a Firewall](https://www.cloudflare.com/learning/security/what-is-a-firewall/)\n\n[Beginners guide to nftables](https://linux-audit.com/networking/nftables/nftables-beginners-guide-to-traffic-filtering/)\n\n[Arch Wiki nftables](https://wiki.archlinux.org/title/Nftables)\n\n</details>\n\nThe following firewall setup is based on the dnscrypt setup above utilizing\nnftables.\n\nThis nftables firewall configuration is a strong recommended practice for\nenforcing encrypted DNS on your system by restricting all outbound DNS traffic\nto a local dnscrypt-proxy process. It greatly reduces DNS leak risks and\nenforces privacy by limiting DNS queries to trusted, encrypted upstream\nservers.(This was edited on 08-08-25) replace `<DNSCRYPT-UID>` with the UID\ngiven from the command `ps -o uid,user,pid,cmd -C dnscrypt-proxy`:\n\n```nix\n{ ... }: {\n  networking.nftables = {\n    enable = true;\n\n    ruleset = ''\n      table inet filter {\n        chain output {\n          type filter hook output priority 0; policy accept;\n\n          # Allow localhost DNS for dnscrypt-proxy2\n          ip daddr 127.0.0.1 udp dport 53 accept\n          ip6 daddr ::1 udp dport 53 accept\n          ip daddr 127.0.0.1 tcp dport 53 accept\n          ip6 daddr ::1 tcp dport 53 accept\n\n          # Allow dnscrypt-proxy2 to talk to upstream servers\n          # Replace <DNSCRYPT-UID> with:\n          # ps -o uid,user,pid,cmd -C dnscrypt-proxy\n          meta skuid <DNSCRYPT-UID> udp dport { 443, 853 } accept\n          meta skuid <DNSCRYPT-UID> tcp dport { 443, 853 } accept\n\n          # Block all other outbound DNS\n          udp dport { 53, 853 } drop\n          tcp dport { 53, 853 } drop\n        }\n      }\n    '';\n  };\n  networking.firewall = {\n    enable = true;\n    allowedTCPPorts = [\n      # Ports open for inbound connections.\n      # Limit these to reduce the attack surface.\n\n      22 # SSH – Keep open only if you need remote access.\n         # To change the SSH port in NixOS:\n         # services.openssh.ports = [ 2222 ];\n         # Update this list to match the new port.\n\n      # 53  # DNS – Only if running a public DNS server.\n      # 80  # HTTP – Only if hosting a website.\n      # 443 # HTTPS – Only if hosting a secure website.\n    ];\n    allowedUDPPorts = [\n      # Ports open for inbound UDP traffic.\n      # Most NixOS workstations won't need any here.\n\n      # 53 # DNS – Only if running a public DNS server.\n    ];\n  };\n}\n```\n\n<details>\n<summary> ✔️ Click to Expand Tip on changing the default SSH Port </summary>\n\n> ❗ TIP: Reduce SSH noise by changing the default port On most systems, SSH\n> listens on TCP port 22 — which means automated bots and scanners will hit it\n> constantly. While this doesn’t replace real security measures, moving SSH to a\n> different port drastically cuts down on drive-by brute-force attempts you’ll\n> see in your logs.\n>\n> In NixOS, change both the SSH daemon port and your firewall rule:\n>\n> ```nix\n>  # Example: Move SSH to port 2222\n>  networking.firewall.allowedTCPPorts = [ 2222 ];\n>  services.openssh.ports = [ 2222 ];\n> ```\n>\n> - After rebuilding, test from another terminal/session before closing your\n>   existing one:\n>\n> ```bash\n> ssh -p 2222 user@host\n> ```\n\n</details>\n\n`nft` is a cli tool used to set up, maintain and inspect packet filtering and\nclassification rules in the Linux kernel, in the nftables framework. The Linux\nkernel subsystem is known as nftables, and 'nf' stands for Netfilter.--`man nft`\n\n```bash\nsudo nft list ruleset\n```\n\n- Since we declare our firewall, we'll only use `nft` to inspect our ruleset.\n\n## NixOS Firewall vs `nftables` Ruleset\n\n`networking.nftables`: This section provides a raw `nftables` ruleset that gives\nyou granular, low-level control. The rules here are more specific and are meant\nto handle the intricate logic of the DNS proxy setup. They will be applied\ndirectly to the kernel's `nftables` subsystem and prevent DNS leaks.\n\n`networking.firewall`: This is a higher-level, simpler NixOS option that uses\n`iptables` rules to open ports for inbound traffic. The rules defined here\n(allowing port 22) is for incoming SSH connections to the machine, not for\noutbound traffic, so they do not interfere with the `nftables` rules that filter\nthe outgoing traffic. (Make sure to comment out or remove this if you don't SSH\ninto your machine).\n\nThe firewall ensures only authorized, local encrypted DNS proxy process can\nspeak DNS with the outside world, and that all other DNS requests from any other\nprocess are blocked unless they're to `127.0.0.1` (our local proxy). This is a\nrobust policy against both DNS leaks and local compromise.\n\n## Testing\n\nReview listening ports: After each rebuild, use `ss -tlpn`, `nmap` or `netstat`\nto see which services are accepting connections. Close or firewall anything\nunnecessary.\n\nYou can also test firewall DNS restrictions using `dig`:\n\n```bash\ndig @127.0.0.1 example.com  # Should work\n\ndig @8.8.8.8 example.com    # Should fail/time out for normal users\n```\n\n- This test is actually what alerted me of an improper configuration in the\n  above firewalls nftables rules allowing me to fix it. Initially the second\n  `dig` command gave results letting me know that the restrictions weren't being\n  applied correctly.\n\nSince we defined an `output` chain inside `table inet filter` with the line:\n\n```bash\ntype filter hook output priority 0; policy accept;\n```\n\nThis attaches the chain to the kernel’s OUTPUT hook, so all locally generated\npackets, including DNS queries are filtered by this chain.\n\nWithin this chain, the rules:\n\n- Explicitly allow DNS queries to localhost addresses (`127.0.0.1` and `::1`).\n\n- Allow the `dnscrypt-proxy` process (running with UID `62396`) to send DNS\n  queries on ports 443 and 853 (for DNS-over-HTTPS and DNS-over-TLS).\n\n- Drop all other outbound DNS traffic on ports `53` and `853`.\n\nBecause of this setup, dig queries to your local resolver at `127.0.0.1` pass,\nbut queries directly to public DNS servers like `8.8.8.8` are blocked for\nusers/processes other than the allowed DNS proxy.\n\n## OpenSnitch\n\n- [NixOS Wiki OpenSnitch](https://wiki.nixos.org/wiki/OpenSnitch)\n\n[Opensnitch](https://github.com/evilsocket/opensnitch) is an open-source\napplication firewall that focuses on monitoring and controlling outgoing network\nconnections on a per-application basis.\n\nThis can be used to block apps from accessing the internet that shouldn't need\nto (i.e., block telemetry and more). Opensnitch will report that the app has\nattempted to make an outbound internet connection and block it or allow it based\non the rules you set.\n\n### Resources\n\n<details>\n<summary> ✔️ Click to Expand Resources </summary>\n\n- [Cloudflare What is HTTPS](https://cloudflare.com/learning/ssl/what-is-https)\n\n- [Surveillance Self-Defence](https://ssd.eff.org/) has a lot of helpful info to\n  protect your privacy.\n\n- [What is Fingerprinting](https://ssd.eff.org/module/what-fingerprinting), more\n  than you realize is being tracked constantly.\n\n- [oisd.nl](https://oisd.nl/) the oisd website\n\n- For potentially dangerous file types like PDFs, office documents, or images,\n  especially those downloaded from untrusted sources such as torrents, consider\n  converting them to a safe PDF format with\n  [dangerzone](https://github.com/freedomofpress/dangerzone). Dangerzone not\n  only removes metadata but also applies robust sanitization to neutralize\n  malicious content.\n\n- [NixOS Wiki LibreWolf](https://wiki.nixos.org/wiki/Librewolf), the options in\n  the wiki make it less secure and aren't recommended settings to use. They\n  explicitly disable several of LibreWolf's default privacy-enhancing features,\n  such as fingerprinting resistance and clearing session data on shutdown.\n\n- [LibreWolf Features](https://librewolf.net/docs/features/) You still need to\n  enable DNS over HTTPS through privacy settings.\n\n- [SearXNG on NixOS](https://wiki.nixos.org/wiki/SearXNG)\n  - [Welcome to SearXNG](https://docs.searxng.org/)\n\n- [Firefox Hardening Guide](https://brainfucksec.github.io/firefox-hardening-guide)\n\n- [Firefox ghacks](https://www.ghacks.net/2015/08/18/a-comprehensive-list-of-firefox-privacy-and-security-settings/)\n\n- [Arkenfox](https://github.com/arkenfox/user.js)\n\n- [PrivacyTools.io](https://www.privacytools.io/private-browser)\n\n- [simeononsecurity Firefox-Privacy-Script](https://github.com/simeononsecurity/FireFox-Privacy-Script)\n\n- [brianfucksec firefox-hardening-Guide 2023](https://brainfucksec.github.io/firefox-hardening-guide)\n\n- [STIG Firefox Hardening](https://simeononsecurity.com/guides/enhance-firefox-security-configuring-guide/)\n\n> If you should trust the U.S. Governments recommendations is another story but\n> it can be good to compare and contrast with other trusted resources. You'll\n> have to think whether the CISA recommending that everyone uses Signal is solid\n> advice or guiding you towards a honeypot, I can't say for sure.\n\n- [Mozilla Firefox Security Technical Implementation Guide](https://stigviewer.com/stigs/mozilla_firefox)\n  The STIG for Mozilla Firefox (Security Technical Implementation Guide) is a\n  set of security configuration standards developed by the U.S. Department of\n  Defense. They are created by the Defense Information Systems Agency (DISA) to\n  secure and harden DoD information systems and software.\n\n- [Privacy, The New Oil (Why Privacy & Security Matter)](https://thenewoil.org/en/guides/prologue/why/)\n\n- [PrivacyGuides](https://www.privacyguides.org/en/)\n\n- [Firefox Relay](https://relay.firefox.com/accounts/profile/) can be used to\n  create email aliases that forward to your real email address. The paid plan\n  also lets you create phone number aliases that forward to your phone number.\n\n- [Zebra Crossing digital safety checklist](https://zebracrossing.narwhalacademy.org/)\n\n- [DataDetoxKit](https://datadetoxkit.org/en/privacy/essentials#step-1)\n\n- [DataDetox Degooglise](https://datadetoxkit.org/en/privacy/degooglise/)\n\n- [Tor Browser User Manual](https://tb-manual.torproject.org/)\n\n- [Tor Wiki](https://gitlab.torproject.org/tpo/team/-/wikis/home)\n\n- [Linux Network Administrators Guide](https://tldp.org/LDP/nag2/x-087-2-intro.html)\n\n</details>\n","number":[1,3,5],"sub_items":[],"path":"nix/hardening_networking.md","source_path":"nix/hardening_networking.md","parent_names":["Getting Started with the Nix Ecosystem","Cachix and the devour-flake"]}},{"Chapter":{"name":"Whonix KVM on NixOS","content":"# Whonix KVM on NixOS\n\n<details>\n<summary> Click to Expand Table of Contents</summary>\n\n<!-- toc -->\n\n</details>\n\n![Whonix Logo](../images/swappy-20250901-101339.cleaned.png)\n\n> ⚠️ WARNING: There is no general software that can guarantee absolute anonymity\n> or security; perfect security is a myth. Security is a continuous process, not\n> a one-time product. It also depends on time and resources: if an adversary has\n> enough of either, eventual compromise is probable. However, by layering\n> defenses and following best practices, we can make attacks costly and\n> time-consuming, deterring all but highly targeted adversaries.\n\nIt is highly recommended to harden your Host Machine as Type 2 hypervisors are\nonly as secure as their host. KVM is actually a type 1 hypervisor but relies on\nQEMU for emulation which is a Type 2 hypervisor. This actually makes it a sort\nof hybrid in between Type 1 and Type 2 but is in theory less secure than running\na Xen hypervisor (Type 1) on bare-metal.\n\nWhonix offers many benefits, including the convenience of running within your\ncurrent operating system without needing to reboot or use a separate Tails USB.\nIt provides similar strong anonymity protections by routing all traffic through\nTor in isolated virtual machines. The Whonix documentation is transparent about\nits limitations, which helps build trust and confidence in its security model.\n\n- [Whonix Compared to Tails](https://www.whonix.org/wiki/Comparison_with_Others)\n\n- Tails is great but they add an add blocker to Tor that makes every Tails user\n  unique from the rest of Tor Browser users reducing anonymity.\n\n> ⚠️ Never rely solely on the Virtual Machine to protect you, if your host OS\n> isn't secure a Virtual Machine won't protect you. If you have high threat\n> model, you may want to choose a Host with better support for AppArmor and\n> Selinux as they are highly limited on NixOS.\n\nThat being said, there is a lot you can do to harden NixOS...\n\n### Harden NixOS and set up GnuPG\n\n- [Hardening NixOS](https://saylesss88.github.io/nix/hardening_NixOS.html)\n\n- [Hardening Networking](https://saylesss88.github.io/nix/hardening_networking.html)\n\n- [GnuPG and gpg-agent on NixOS](https://saylesss88.github.io/nix/gpg-agent.html)\n\n### A Few Things to Consider when using Whonix\n\n- No activity conducted inside `Whonix-Workstation` can cause IP/DNS leaks so\n  long as `Whonix-Gateway` is left unchanged or only documented changes are made\n  like configuring bridges, establishing onion services and running updates.\n\n- Whonix does not and does not claim to protect users against advanced\n  adversaries such as nation state actors, if they target you, you will be\n  infected! If used correctly, Whonix can provide partial protection against\n  passive surveillance programs, it all depends on whether Tor can provide\n  adequate protection or not, which is not clear at this time.\n\n- You shouldn't use a VPN with Whonix and it is obvious that you're using Tor\n  because connections are made to known Tor Relays, which are publicly listed\n  and identifiable.\n\n> ⚠️It is impossible to Hide Tor use from the internet service provider (ISP).\n> It has been concluded this goal is difficult beyond practicality.\n> --[Whonix Hide Tor from your ISP](https://www.whonix.org/wiki/Hide_Tor_from_your_Internet_Service_Provider)\n\n- Millions of people use Tor daily for wholly legitimate reasons, particularly\n  to assert their privacy rights when faced with countless corporate /\n  government network observers and censors.\n\n- True anonymity is very difficult to successfully pull off and not something\n  that you can maintain for a long time.\n  - [Whonix Tips for remaining Anonymous](https://www.whonix.org/wiki/Tips_on_Remaining_Anonymous)\n\n## 🔑 Key Terms\n\nWhonix is an operating system based on Debian base (Kicksecure Hardened) and the\nTor network, which is designed for maximum anonymity and security. Whonix\nconsists of two Debian based VMs, the `Whonix-Gateway` and `Whonix-Workstation`.\n\nIn this case NixOS is the **Host Operating System**, NixOS runs the KVM kernel\nmodule, libvirtd service, and QEMU virtualization service which together enable\nhosting VMs. It is recommended to harden the host before moving on.\n\n**Guests** are the virtualized operating systems running inside the host's\nvirtual machines. In this case the Whonix VMs are the **Guest Machines**.\n\n`Whonix-Gateway` the first of 2 VMs runs Tor processes and forces all traffic\nthrough the Tor network using iptables.\n\n`Whonix-Workstation` the second VM, is responsible for running user applications\nsuch as the Tor Browser. The Whonix-Workstation is isolated from both the\nWhonix-Gateway and the Host OS, if an app misbehaves, it is contained within the\nisolated Whonix-Workstation. It is largely unaware of sensitive info and won't\nleak unless an advanced adversary is able to break out of the VM.\n\nThe primary goal of Whonix is to be safer than Tor alone and that no one can\nfind out the user's IP, location, or de-anonymize the user. It offers full\nspectrum anti-tracking protection that is much safer than VPNs. Whonix provides\nthis through security by isolation, no app is trusted.\n\n`Whonix Concept`: Whonix is an Isolating Proxy with an additional Transparent\nProxy, which can be optionally disabled. --Whonix Docs\n\nSince Whonix is based on Kicksecure which is based on Debian stable, you can\ntypically look up solutions in a Kicksecure, Debian, or Ubuntu forum.\n\n- The Whonix Team recommends KVM over VirtualBox for a number of\n  reasons:[Why choose KVM over VirtualBox](https://www.whonix.org/wiki/KVM#Why_Use_KVM_Over_VirtualBox?)\n\nIf you really want to use VirtualBox, I got it working off of this config:\n\nVirtualBox = Type 2 hypervisor\n\n<details>\n<summary> ✔️ Click to Expand VirtualBox Example </summary>\n\nChange `your-user` to your username\n\n```nix\n# vbox.nix\n{\n  config,\n  lib,\n  ...\n}: let\n  cfg = config.custom.virtualbox;\nin {\n  options.custom.virtualbox = {\n    enable = lib.mkEnableOption \"Enable VirtualBox\";\n  };\n\n  config = lib.mkIf cfg.enable {\n    virtualisation.virtualbox.host = {\n      enable = false;\n      # enableExtensionPack = true;\n    };\n\n    user.user.your-user.extraGroups = [\"vboxusers\"];\n\n    boot.kernelModules =\n      if config.hardware.cpu.amd.updateMicrocode\n      then [\"kvm-amd\"]\n      else [\"kvm-intel\"];\n  };\n}\n```\n\nEnable it with `custom.virtualbox.enable = true;`.\n\n- [Whonix VBox Download](https://www.whonix.org/wiki/VirtualBox)\n\nAfter rebuilding with virtualbox enabled and downloading the virtualbox whonix,\nopen VirtualBox and import the Whonix file.\n\nFix the error:: VirtualBox can't enable the AMD-V extension. Please disable the\nKVM kernel extension:\n\nIf both of these are active, they compete with each other:\n\n```bash\nsudo lsmod | grep -E 'kvm|vbox'\n```\n\nCheck the currently in use modules:\n\n```bash\nmodprobe -r kvm\n```\n\nDisable kvm and kvm_amd:\n\n```bash\nsudo rmmod kvm_amd\nsudo rmmod kvm\n# To re-enable them when necessary\n# sudo modprobe kvm\n# sudo modprobe kvm_amd\n```\n\n- [Quick fix](https://atetux.com/quick-fix-virtualbox-cant-enable-the-amd-v-extension)\n\nThere is an opposite viewpoint,\n[Why choose VirtualBox over KVM](https://www.whonix.org/wiki/Dev/VirtualBox#Why_use_VirtualBox_over_KVM?)\n\n</details>\n\n## Whonix-Gateway\n\nThe whonix-gateway is software designed to run Tor.\n\nThe Gateway acts as a firewall and is what is routing all your traffic through\nTor.\n\nYou will spend minimal time in the Gateway, it's mainly used for Tor\nconfiguration which is reserved for advanced users.\n\n### Whonix-Workstation\n\nAll user applications should only be launched from Whonix-Workstation to ensure\nthey utilize the Tor network. (Never launch the Tor browser or any other user\napp from Whonix-Gateway.)\n\nLeaky applications can't breakout of the Workstation, all network connections\nare forced to go through the Whonix-Gateway where they are torrified and routed\nto the internet.\n\n## Whonix KVM (Kernel Virtual Machine) on NixOS\n\n**KVM** (Kernel-based Virtual Machine) is a Linux kernel module that provides\nhardware-assisted virtualization.\n\nIt allows the Linux kernel to act as a hypervisor, enabling virtual machines\n(VMs) to run with near-native speeds by using CPU virtualization extensions\n(Intel VT-x or AMD-V).\n\nKVM itself doesn’t handle the entire VM lifecycle; it provides the core\nvirtualization infrastructure.\n\n**QEMU** (Quick Emulator) is an open-source user-space program that emulates\nhardware for virtual machines.\n\nWhen combined with KVM, QEMU uses hardware acceleration to run VMs much faster\nby offloading CPU virtualization to KVM.\n\nSo, QEMU provides the device emulation and VM management interface, while KVM\nprovides the fast virtualization engine within the kernel.\n\n**Install Qemu-KVM**:\n\n```nix\n{\n  config,\n  pkgs,\n  ...\n}: {\n  ##  QEMU-KVM\n  environment.systemPackages = with pkgs; [\n    qemu\n    # Optional\n    virt-viewer\n  ];\n\n  # Virt-Manager GUI\n  programs.virt-manager.enable = true;\n  virtualisation = {\n    # libvirtd daemon\n    libvirtd = {\n      enable = true;\n      qemu = {\n        # enables a TPM emulator\n        swtpm.enable = true;\n      };\n    };\n    # allow USB device to be forwarded\n    spiceUSBRedirection.enable = true;\n  };\n  # Spice protocol improves VM display and input responsiveness\n  services.spice-vdagentd.enable = true;\n}\n```\n\n---\n\nThe **libvirtd** is the primary daemon (service) in the libvirt virtualization\nmanagement system. It runs on your host machine and acts as the core management\ncomponent for virtual machines (VMs).\n\nAdd `libvirtd` & `kvm` to your users `extraGroups`:\n\n```nix\nusers.users = {\n    your-user = {\n        extraGroups = [\n            \"libvirtd\"\n            \"kvm\"\n        ];\n    };\n};\n```\n\nRestart `libvirtd`:\n\n```bash\nsudo systemctl restart libvirtd\n```\n\n---\n\n## Network Start\n\nEnsure KVM's / QEMU's default network is enabled and has started:\n\n```bash\nsudo virsh -c qemu:///system net-autostart default\n```\n\n```bash\nsudo virsh -c qemu:///system net-start default\n```\n\n---\n\n### Download Whonix (KVM) (stable)\n\n1. [Whonix (KVM) (stable) Download](https://www.whonix.org/download/libvirt/17.4.4.6/Whonix-Xfce-17.4.4.6.Intel_AMD64.qcow2.libvirt.xz)\n\n2. Go to [whoniix.org](https://www.whonix.org/wiki/KVM) to verify the signature.\n   Download the `OpenPGP Signature`, and the `Download Whonix OpenPGP Key`. Your\n   Downloads directory will look like this:\n\n```bash\n~/Downloads󰏫 ls\n╭───┬───────────────────────────────────────────────────────┬──────┬─────────┬───────────────╮\n│ # │                         name                          │ type │  size   │   modified    │\n├───┼───────────────────────────────────────────────────────┼──────┼─────────┼───────────────┤\n│ 0 │ Whonix-Xfce-17.4.4.6.Intel_AMD64.qcow2.libvirt.xz     │ file │  3.3 GB │ 2 minutes ago │\n│ 1 │ Whonix-Xfce-17.4.4.6.Intel_AMD64.qcow2.libvirt.xz.asc │ file │  1.0 kB │ a minute ago  │\n│ 2 │ derivative.asc                                        │ file │ 77.3 kB │ 3 minutes ago │\n╰───┴───────────────────────────────────────────────────────┴──────┴─────────┴───────────────╯\n```\n\nImport `derivative.asc`:\n\n```bash\ngpg --import derivative.asc\n```\n\nVerify the Public Key:\n\n```bash\ngpg --verify Whonix-Xfce-17.4.4.6.Intel_AMD64.qcow2.libvirt.xz.asc Whonix-Xfce-17.4.4.6.Intel_AMD64.qcow2.libvirt.xz\ngpg: Signature made Sun 10 Aug 2025 09:04:13 AM EDT\ngpg:                using RSA key 6E979B28A6F37C43BE30AFA1CB8D50BB77BB3C48\ngpg: Good signature from \"Patrick Schleizer <adrelanos@kicksecure.com>\" [unknown]\ngpg:                 aka \"Patrick Schleizer <adrelanos@riseup.net>\" [unknown]\ngpg:                 aka \"Patrick Schleizer <adrelanos@whonix.org>\" [unknown]\ngpg: WARNING: This key is not certified with a trusted signature!\ngpg:          There is no indication that the signature belongs to the owner.\nPrimary key fingerprint: 916B 8D99 C38E AF5E 8ADC  7A2A 8D66 066A 2EEA CCDA\n     Subkey fingerprint: 6E97 9B28 A6F3 7C43 BE30  AFA1 CB8D 50BB 77BB 3C48\n~/Downloads󰏫                                                                                                 09/04/2025 11:53:10 AM\n```\n\nNow `gpg --list-keys` will show Patrick Schleizer's Key.\n\nIt is good practice to sign your verified key and then push it to the public\nkeyserver to contribute to the web of trust but optional.\n\n3. [Decompress the Image](https://www.whonix.org/wiki/KVM#Decompress) and follow\n   the rest of the Whonix KVM install instructions from there.\n\nNixpkgs doesn't have the `xz-utils` package but it does have the `xz` package.\n\nNixpkgs also has `nixpkgs.safe-rm` if you wanted to follow the suggestions from\nWhonix.\n\n```bash\nnix-shell -p xz safe-rm\n```\n\n```bash\ntar -xvf Whonix*.libvirt.xz\n```\n\n---\n\n### Import the Whonix VM Templates\n\nThe following commands come directly from the\n[Whonix KVM Docs Importing Whonix VM Templates](https://www.whonix.org/wiki/KVM#Importing_Whonix_VM_Templates)\n\n1. Add the virtual networks. This step only needs to be done once and not with\n   every upgrade.\n\n```bash\nsudo virsh -c qemu:///system net-define Whonix_external*.xml\n```\n\n```bash\nsudo virsh -c qemu:///system net-define Whonix_internal*.xml\n```\n\n2. Activate the virtual networks:\n\n```bash\nsudo virsh -c qemu:///system net-autostart Whonix-External\n```\n\n```bash\nsudo virsh -c qemu:///system net-start Whonix-External\n```\n\n```bash\nsudo virsh -c qemu:///system net-autostart Whonix-Internal\n```\n\n```bash\nsudo virsh -c qemu:///system net-start Whonix-Internal\n```\n\n3. Import the Whonix Gateway and Workstation images:\n\n```bash\nsudo virsh -c qemu:///system define Whonix-Gateway*.xml\n```\n\n```bash\nsudo virsh -c qemu:///system define Whonix-Workstation*.xml\n```\n\nAfter the above steps, either copy or move the `qcow2` images to\n`/var/lib/libvirt/images`:\n\n> ❗ It's recommended to move the files into place, if you want to copy them you\n> need to use a special command FYI.\n\n```bash\nsudo mkdir -p /var/lib/libvirt/images\n```\n\n```bash\nsudo mv Whonix-Gateway*.qcow2 /var/lib/libvirt/images/Whonix-Gateway.qcow2\n```\n\n```bash\nsudo mv Whonix-Workstation*.qcow2 /var/lib/libvirt/images/Whonix-Workstation.qcow2\n```\n\n### Cleanup\n\n```bash\nsafe-rm Whonix*\n```\n\n```bash\nsafe-rm -r WHONIX*\n```\n\n### Launch virt-manager and start the VMs\n\n```bash\nvirt-manager\n```\n\nFrom here it will take a bit to load both VMs, you can click on one and go to\n`Edit`, `Virtual Machine Details` and from there you have some options to give\nthe VM more CPUs and memory.\n\nConsidering that the Whonix-Workstation is where all of the user applications\nwill be opened, it makes sense to give it more CPUs and memory.\n\nI've seen recommendations for a minimum of 4G of RAM for the Workstation and 2GB\nfor the Gateway.\n\n- Increase vCPU count for better performance\n\n- Enable XML editing in settings\n\n- Enable copy pasting by adding `<clipboard copypaste=\"yes\"/>`\n\n## Start Whonix-Gateway\n\n![Whonix Old Logo](../images/swappy-20250901-101351.cleaned.png)\n\nAlways start the Whonix-Gateway first.\n\nClick on Whonix-Gateway, press Play, and choose the default Persistent VM.\n\nTo view the gateway press `Open`.\n\nYou can use the \"System Maintenance Panel\" to `Check for Updates` and then\n`Install Updates`. This can also be used for user and password creation, the\ndefault user is `user` with a passwordless login.\n\nChange the password manually:\n\n```bash\nsudo passwd\nchangeme\n```\n\nChange the passwords and disable auto-login.\n\nRun a systemcheck if it wasn't run automatically. Click the Xfce Logo and go to\n`System`, `System Check`.\n\n- [Whonix Common CLI Commands](https://www.whonix.org/wiki/Common_CLI_Commands)\n\n## Whonix-Workstation\n\nWhonix-Workstation is another VM, designed to provide users with a secure and\nanonymous environment for running applications and performing online tasks.\n\nWhen you first launch `Whonix-Workstation`, choose the second option down or\nreboot, and then choose \"Persistent Mode Sysmaint Session\". From there, you can\ngo through the same steps as you did for the Gateway.\n\nWith the workstation, a security feature disables `sudo` for the default user.\nInstead of the `user` account, a separate `sysmaint` (system maintenance)\naccount is used for administrative tasks that require root privileges, such as\nupdates and package installations.\n\n- Change all user passwords and disable auto-login\n\nAfter you get your system updated and upgraded, you'll want to reboot the\nWorkstation and start it in the first Persistent mode available rather than the\n`sysmaint` mode.\n\nOnce Workstation is running and both VMs are updated and upgraded, check that\nyour IP address is a Tor IP:\n\n```bash\ncurl ip.me\n#\ncurl ip.me\n```\n\nEach consecutive time that you run `curl ip.me`, Tor establishes a new circuit\nand you will get a different IP returned each time for as many Tor nodes are\navailable. Not that you would want to but it's cool functionality giving us a\nvisual of the new circuit.\n\nStart Tor and check what you are fingerprinted as by typing `deviceinfo.me` into\nthe URL.\n\n#### Launching Tor Browser\n\nClick the Xfce logo and choose Tor Browser. On the first launch, you will need\nto update Tor by clicking in the top right corner.\n\nOr you can open the terminal and type:\n\n```bash\nupdate-torbrowser\n```\n\n- Every time you run the above command, the old browser will be killed, along\n  with your old browser profile, including bookmarks and passwords. If the\n  update suggests a downgrade from your current version don't do it, it is\n  likely a downgrade attack.\n\nMake sure you don't forget to go to the Settings, Privacy and Security, and set\nthe `Security Level` to `Safest` to disable JavaScript and more before exploring\nthe dark web.\n\nVisit `https://check.torproject.org`, you should see \"Congratulations. This\nbrowser is configured to use Tor.\"\n\nIf you need a place to start, check out `https://tor.taxi` by plugging that into\nthe URL. Always include the `https` yourself!\n\n> ❗ NOTE: Use HTTPS and TLS wherever possible, since Tor only encrypts traffic\n> as it travels through the network of three nodes. Traffic at Exit nodes is\n> vulnerable if unencrypted, because when it reaches the Exit node it is plain\n> text. Prefer the use of `.onion` services because they form a tunnel that is\n> encrypted end-to-end, using a random rendezvous point within the Tor network;\n> HTTPS isn't required within Onion services. Prefer the use of `.onion`\n> services because they form a tunnel that is encrypted end-to-end, using a\n> random rendezvous point within the Tor network; HTTPS isn't required within\n> Onion services.\n> --[All my traffic is encrypted by default?](https://www.whonix.org/wiki/Tor_Myths_and_Misconceptions#All_my_traffic_is_encrypted_by_default)\n\n## Live Mode\n\nTo get Whonix to perform more similarly to Tails you could run Whonix in Live\nMode. Live Mode is a privacy-focused mode where nothing is saved at shutdown,\nmaking it great for handling sensitive data.\n\n- [Live Mode](https://www.kicksecure.com/wiki/Live_Mode)\n\nSame process, reboot the Workstation and Choose\n`LIVE Mode | USER Session | disposable use`\n\n- [Anti Forensics Precautions](https://www.kicksecure.com/wiki/Anti-Forensics_Precautions)\n\n## Download and Verify Kicksecure KVM\n\n- [Kicksecure KVM wiki](https://www.kicksecure.com/wiki/KVM)\n\n1. [Download Kicksecure Xfce (KVM) (stable) (FREE!)](https://www.kicksecure.com/download/libvirt/17.4.4.6/Kicksecure-Xfce-17.4.4.6.Intel_AMD64.qcow2.libvirt.xz)\n\n2. [Download OpenPGP Signature](https://www.kicksecure.com/download/libvirt/17.4.4.6/Kicksecure-Xfce-17.4.4.6.Intel_AMD64.qcow2.libvirt.xz.asc)\n\n3. [Download Kicksecure OpenPGP Key](https://www.kicksecure.com/keys/derivative.asc)\n\n4. Import the `derivative.asc` file:\n\n```bash\ngpg --import derivative.asc\n```\n\n5. Make sure both files are done downloading and run the following to verify,\n   your file names might be slightly different:\n\n```bash\ngpg --verify Kicksecure-Xfce-17.4.4.6.Intel_AMD64.qcow2.libvirt.xz.asc Kicksecure-Xfce-17.4.4.6.Intel_AMD64.qcow2.libvirt.xz\ngpg: Signature made Sun 10 Aug 2025 07:32:52 AM EDT\ngpg:                using RSA key 6E979B28A6F37C43BE30AFA1CB8D50BB77BB3C48\ngpg: Good signature from \"Patrick Schleizer <adrelanos@kicksecure.com>\" [unknown]\ngpg:                 aka \"Patrick Schleizer <adrelanos@riseup.net>\" [unknown]\ngpg:                 aka \"Patrick Schleizer <adrelanos@whonix.org>\" [unknown]\ngpg: WARNING: This key is not certified with a trusted signature!\ngpg:          There is no indication that the signature belongs to the owner.\nPrimary key fingerprint: 916B 8D99 C38E AF5E 8ADC  7A2A 8D66 066A 2EEA CCDA\n     Subkey fingerprint: 6E97 9B28 A6F3 7C43 BE30  AFA1 CB8D 50BB 77BB 3C48\n```\n\n6. **Decompress**\n\n```bash\ntar -xvf Kicksecure*.libvirt.xz\n```\n\nDon't use `unxz`!\n\n### Resources\n\n- [Whonix Docs](https://www.whonix.org/wiki/Documentation)\n\n- [Whonix Overview](https://www.whonix.org/wiki/About)\n\n- [Whonix Technical Intro](https://www.whonix.org/wiki/Dev/Technical_Introduction)\n\n- [Kicksecure Computer Security Intro](https://www.kicksecure.com/wiki/Computer_Security_Introduction)\n\n- [Kicksecure Advanced Security Guide](https://www.kicksecure.com/wiki/Computer_Security_Introduction#Advanced_Security_Guide)\n\nk\n[System Hardening Checklist](https://www.kicksecure.com/wiki/System_Hardening_Checklist)\n","number":[1,3,6],"sub_items":[],"path":"nix/whonix_kvm.md","source_path":"nix/whonix_kvm.md","parent_names":["Getting Started with the Nix Ecosystem","Cachix and the devour-flake"]}},{"Chapter":{"name":"Running NixOS as a VM","content":"# Running NixOS in a VM with Maximum Isolation (Beginner Guide)\n\n<details>\n<summary> Click to Expand Table of Contents</summary>\n\n<!-- toc -->\n\n</details>\n\n![sp5](images/steampunk5.cleaned.png)\n\n## Why This Setup?\n\n- **Host** `secureblue` = Fedora Atomic with **SELinux enforcing**, **sVirt**,\n  **Secure Boot**, and hardened defaults.\n\n- **Guest**: NixOS in a VM → full declarative power, near zero risk to host.\n\n- **Isolation**: Mandatory Access Control (MAC) via SELinux + KVM + no direct\n  hardware access.\n\n---\n\n### 🔑 Key Terms\n\n> NOTE: Secureblue enables the `hardened_malloc` by default which causes\n> problems for many browsers and will cause screen flashing with Firefox and\n> others within the VM. See:\n\n- [secureblue standard_malloc](https://secureblue.dev/faq#standard-malloc)\n\n## Step 1: Install secureblue (Hardened Host)\n\n1. Download a [secureblue image](https://secureblue.dev/install)\n\n2. Use **Fedora Media Writer** (Flatpak):\n\n```bash\nflatpak install flathub org.fedoraproject.MediaWriter\n```\n\n3. Flash the secureblue image & enable Secure Boot in UEFI **before** install.\n   This is now possible with Fedora, when you boot into Fedora Media Writer (not\n   Ventoy or Rufus), you will be allowed to enroll the secure boot key with\n   secure boot pre-enabled.\n\n4. On first boot:\n\n```bash\nujust enroll-secureblue-secure-boot-key\n```\n\n- Reboot -> Enroll key in MOK manager with password: `secureblue`\n\n5. Post-install hardening See:\n   [post-install](https://secureblue.dev/post-install)\n\n6. Install virtualization stack:\n\n```bash\nujust install-libvirt-packages\n```\n\n- The above command enables `qemu`, `libvirt`, & `virt-manager` with SELinux\n  labels.\n\n- Read the [secureblue FAQ](https://secureblue.dev/faq) to learn the quirks of\n  an atomic fedora image.\n\nSecureblue recommends installing GUI apps with Flatpak, CLI apps with homebrew,\nand apps that require more system access to be layered with rpm-ostree. It takes\nsome getting used to but is very stable.\n\n- [secureblue how to install software](https://secureblue.dev/faq#software)\n\n---\n\n## Create NixOS VM (via virt-manager)\n\n1. Download: [NixOS Graphical ISO](https://nixos.org/download/)\n\n2. Open `virt-manager` -> File -> New Virtual Machine\n\n- Select ISO\n\n- CPU: `host-passthrough` (optional, for performance)\n\n- Do some research to find the ideal Memory and Storage for your system.\n\n3. Ensure SELinux is enabled (the default for secureblue) with: `getenforce`\n\n4. Ensure sVirt is enabled (the default) with `run0 ps -eZ | grep qemu`.\n\n```bash\nrun0 ps -eZ | grep qemu\n# Output\nsystem_u:system_r:svirt_t:s0:c383,c416 14793 ?   00:01:37 qemu-system-x86\n```\n\n5. Boot -> Follow graphical installer:\n\n- Enable LUKS\n\n- Create an admin user\n\n- Optionally skip desktop -> install your own after first boot.\n\nThe attack surface is reduced significantly when running NixOS within a hardened\nhosts VM. The VM operates on virtualized hardware, which is a powerful form of\nattack surface reduction.\n\nDevices like your host's Bluetooth adapter, Wi-Fi card, microphone, webcam, and\nUSB ports are not directly exposed to the guest operating system. The VM only\nsees virtual versions of these devices. If an exploit targets a vulnerability in\nthe Bluetooth stack within the VM, it compromises the VM environment, but it\ncannot typically reach and exploit the physical Bluetooth hardware on the host.\n\nYou can also choose not to pass through certain devices, like Bluetooth or\nwebcam to the VM at all, effectively disabling that attack vector. Since your\nhost likely already has these hardened features you may not need the additional\nfunctionality within the VM.\n\nIf something breaks, you have an option to rollback to the previous generation\nwith `rpm-ostree rollback`. The previous generation will be applied on next\nreboot. You can also just reboot and choose the previous generation through the\ngrub menu, this way it is temporary and will revert back on next reboot.\n\n---\n\n## 🔒 How Host MAC Secures the NixOS VM\n\nThe core security principle here is defense-in-depth, where the outer, hardened\nlayer (the host) compensates for potential weaknesses in the inner layer (the\nguest).\n\n1. MAC Confinement via SELinux and sVirt sVirt (Secure Virtualization): This is\n   a critical component running on the secureblue host. It automatically assigns\n   unique SELinux labels to all virtualization components.\n\n**QEMU Process Confinement**: The entire QEMU process that runs the NixOS VM is\nconfined by a specific SELinux type, typically `svirt_t`. This means:\n\nThe host's MAC policy strictly controls what the QEMU process can access and do\non the host system.\n\nIf an attacker were to achieve a \"VM breakout\" (a worst-case scenario where they\nescape the VM and try to interact with the host OS), their activity would still\nbe confined by the extremely strict rules of the `svirt_t` label. They would not\nbe able to arbitrarily read host files or compromise the host kernel.\n\n**Disk Image Confinement**: The VM's disk images are also labeled, typically as\nvirt_image_t, preventing other processes on the host from accessing or tampering\nwith them.\n\n2. **KVM and Host Hardening KVM**: KVM provides the low-level, hardware-assisted\n   virtualization. It is an extremely secure and audited hypervisor that creates\n   a strong barrier between the guest and the host kernel.\n\n**Secureblue Hardening**: The secureblue host is designed with SELinux\nenforcing, Secure Boot, a hardened kernel, and hardened_malloc by default, which\nminimizes the attack surface and ensures the integrity of the base operating\nsystem that's running the VM.\n\n3. **Isolation and Zero Host Risk Decoupling Security**: The security of the\n   host is completely decoupled from the security of the NixOS guest.\n\nAny compromise within the NixOS VM (e.g., a service vulnerability,\nmisconfiguration, or user error) will be contained by the host's isolation\nmechanisms (KVM + SELinux + sVirt). This containment means the host remains\nsecure (\"Zero host compromise\"), regardless of the NixOS VM's internal security\nsettings, including its lack of default MAC.\n\nIn short, the security boundary isn't the guest OS's (NixOS) configuration, but\nthe hypervisor and the host's MAC policy that enforces the complete isolation of\nthe VM\n\n## It's still recommended to harden the Guest VM (NixOS)\n\nHardening the NixOS guest VM adds an extra, independent layer of defense,\nhelping to protect the system beyond what the host provides.\n\n**Best Practices for Minimizing VM Device Exposure**\n\nTake a VM snapshot right after a fresh install. This snapshot acts as a clean\nrestore point. Many people safely test malware or potentially dangerous software\nby running it within the VM, then reverting to the snapshot afterward to wipe\nout any changes or infections caused by the malware.\n\nAvoid unnecessary device passthrough: Only pass through hardware devices (like\nUSB, GPU, or network interfaces) that are essential for your VM's operation. For\nexample, if a device isn't needed within the VM, do not passthrough the device\nto reduce attack surface.​\n\nUse virtual network segmentation: Instead of bridging physical network devices,\nopt for virtual network configurations like isolated networks, VLANs, or\ninternal networks that prevent VM-to-VM or VM-to-host communication unless\nexplicitly allowed.​\n\nImplement network filtering and firewall rules: Use libvirt nwfilter, iptables,\nor firewalld rules to restrict communications between VMs and external networks,\nor between guest VMs on the same host.​\n\n- [libvirt Firewall and network filtering](https://libvirt.org/firewall.html)\n\nUse virtual device models with minimal capabilities: Prefer virtio or similar\nparavirtualized devices that have a smaller attack surface. Avoid emulated\ndevices when not necessary.​\n\nDisable features like USB debugging, audio, or PnP devices: These can\npotentially be exploited or leak information if enabled unnecessarily.\n\n- It's still recommended to enable either the `graphene-hardened` or\n  `graphene-hardened-light` memory allocators on the NixOS guest machine as\n  well.\n\n```nix\n# configuration.nix\nenvironment.memoryAllocator.provider = \"graphene-hardened\";\n# OR for a more permissive and better performing allocator:\n# environment.memoryAllocator.provider = \"graphene-hardened-light\";\n```\n\n- Remember that certain programs won't run with the `hardened_malloc`. I have\n  read that you need to recompile Firefox for it to respect and work with the\n  `hardened_malloc`. I haven't attempted this as of yet and use Brave for now.\n\nContinue\n[hardening NixOS](https://saylesss88.github.io/nix/hardening_NixOS.html)\n\n> ❗️ NOTE: It’s generally recommended not to enable GPU drivers inside the VM\n> unless you are specifically doing GPU passthrough, as this often causes\n> stability and compatibility issues. GPU passthrough itself requires careful\n> configuration and dedicated hardware, and introduces additional attack\n> surfaces.\n\n> Regarding IPv6 networking, enabling it typically requires using a bridged\n> network setup rather than NAT, which connects the VM more directly to the\n> host's network. While bridged networking enables full IPv6 functionality, it\n> also reduces the network isolation between the VM and host, potentially\n> increasing security risks. For maximum isolation, consider carefully whether\n> you need IPv6 connectivity inside the VM and weigh that against your security\n> goals.\n\nI have been able to recover from quite a few missteps with Secureblue. I run a\nmini PC and attempted running `ujust update-firmware`, some systems allow you to\nupdate the firmware of a booted system. On reboot I got a message \"Something\nwent seriously wrong MOK is full\", it then forced a shutdown. I was familiar\nwith resetting the NVRAM by disassembling the PC and moving the red jumper from\nprongs 1 & 2 to prongs 2 & 3 with the power off for 10 seconds. I then moved the\njumper back to the default position and rebooted. The PC sounds like it's\nrevving up a few times and does a few reboots and allowed me to sign right back\nin and re-enroll the secure boot key.\n\n### Resources\n\n- [RedHat What is virtualization?](https://www.redhat.com/en/topics/virtualization/what-is-virtualization)\n\n- [virtualization & hypervisors](https://sumit-ghosh.com/posts/virtualization-hypervisors-explaining-qemu-kvm-libvirt/)\n\n- [Virtualization on Linux using the KVM/QEMU/Libvirt stack](https://bitgrounds.tech/posts/kvm-qemu-libvirt-virtualization/)\n","number":[1,3,7],"sub_items":[],"path":"nix/kvm.md","source_path":"nix/kvm.md","parent_names":["Getting Started with the Nix Ecosystem","Cachix and the devour-flake"]}}],"path":"nix/cachix_devour.md","source_path":"nix/cachix_devour.md","parent_names":["Getting Started with the Nix Ecosystem"]}},{"Chapter":{"name":"Version Control with Git","content":"# Version Control with Git\n\n<details>\n<summary> ✔️ Click to Expand Table of Contents</summary>\n\n<!-- toc -->\n\n</details>\n\n<!-- ![Git Logo](../images/git1.png) -->\n\n⚠️ **Important**: Never commit secrets (passwords, API keys, tokens, etc.) in\nplain text to your Git repository. If you plan to publish your NixOS\nconfiguration, always use a secrets management tool like sops-nix or agenix to\nkeep sensitive data safe. See the\n[Sops-Nix Guide](https://saylesss88.github.io/installation/enc/sops-nix.html)\nfor details.\n\nIt's also important to understand that **all files in the `/nix/store` are\nworld-readable by default** This has important security implications for anyone\nmanaging sensitive data on a NixOS system.\n\nWhat Does \"World-Readable\" Mean?\n\n- All files in /nix/store are readable by any user on the system.\n\n- This is by design, the nix store is intended to be shared, immutable store of\n  all packages and configuration files.\n\n- Permissions are typically set to `r-xr-xr-x`(read and execute for everyone)\n\n**Security Implications**\n\n- Never store secrets or sensitive data in plane text in the Nix store.\n\n- If you include secrets directly in your configuration, they will end up in the\n  `/nix/store` and be accessible to any user or process on the system.\n\n- This applies to files, environment variables, and any data embedded in\n  derivations.\n\n**Best Practices**\n\n- Always use a secrets management tool (like `sops-nix` or `agenix`) that\n  decrypts secrets at activation time and stores them outside the Nix store,\n  with restricted permissions.\n\n- Do not embed secrets directly in Nix expressions or configuration files that\n  will be build into the store.\n\n- Even hashed passwords can be vulnerable when stored in a public repository, be\n  conscious of what you store where.\n\n- If you’re unsure about what’s safe to share, start with a private repository.\n  This gives you time to learn about secrets management and review your\n  configuration before making anything public.\n\nFirst, I'll briefly explain some of the limitations of NixOS Rollbacks and then\nI'll go into how Git compliments them.\n\n## Limitations of NixOS Rollbacks\n\nNixOS is famous for its ability to roll back to previous system generations,\neither from the boot menu or with commands like `nixos-rebuild --rollback`.\n\nWhen you perform rollbacks in NixOS, whether from the boot menu or using\ncommands like `nixos-rebuild --rollback` only the contents and symlinks managed\nby the Nix store are affected. The rollback works by switching which system\ngeneration is active, atomically updating symlinks to point to the previous\nversion of all packages, `systemd` units and services stored in `/nix/store`.\n\nHowever, it’s important to understand what these rollbacks actually do and what\nthey don’t do. What NixOS Rollbacks Cover\n\n- System generations: When you rebuild your system, NixOS creates a new\n  “generation” that you can boot into or roll back to. This includes all\n  packages, services, and system configuration managed by Nix.\n\n- Quick recovery: If an upgrade breaks your system, you can easily select an\n  older generation at boot and get back to a working state\n\n**Key Limitations**:\n\n- **Configuration files are not reverted**: Rolling back only changes which\n  system generation is active, it does not revert your actual configuration\n  files (like `configuration.nix` or your flake files)\n\n- **User data and service data are not rolled back**: Only files managed by Nix\n  are affected. Databases, user files, and other persistent data remain\n  unchanged, which can cause problems if, for example, a service migrates its\n  database schema during an upgrade\n\n- **Manual changes persist**: Any manual edits to configuration files or system\n  state outside of Nix are not reverted by a rollback\n\n## How Git Helps\n\n<!-- ![Git Logo 2](../images/git3.png) -->\n\n- The [gh-cli](https://docs.github.com/en/github-cli/github-cli/quickstart),\n  simplifies quite a few things for working with GitHub from the command line.\n\n- **Tracks every configuration change**: By version-controlling your NixOS\n  configs with Git, you can easily see what changed, when, and why.\n\n- **True config rollback**: If a configuration change causes issues, you can use\n  `git checkout` or `git revert` to restore your config files to a previous good\n  state, then rebuild your system\n\n- **Safer experimentation**: You can confidently try new settings or upgrades,\n  knowing you can roll back both your system state (with NixOS generations) and\n  your config files (with Git).\n\n- **Collaboration and backup**: Git lets you share your setup, collaborate with\n  others, and restore your configuration if your machine is lost or damaged.\n\nIn summary: NixOS rollbacks are powerful for system state, but they don’t manage\nyour configuration file history. Git fills this gap, giving you full control and\ntraceability over your NixOS configs making your system both robust and truly\nreproducible. Version control is a fundamental tool for anyone working with\nNixOS, whether you’re customizing your desktop, managing servers, or sharing\nyour configuration with others. Git is the most popular version control system\nand is used by the NixOS community to track, share, and back up system\nconfigurations.\n\n**Why use Git with NixOS?**\n\n- **Track every change**: Git lets you record every modification to your\n  configuration files, so you can always see what changed, when, and why.\n\n- **Experiment safely**: Try new settings or packages without fear—if something\n  breaks, you can easily roll back to a previous working state.\n\n- **Sync across machines**: With Git, you can keep your NixOS setups in sync\n  between your laptop, desktop, or servers, and collaborate with others.\n\n- **Disaster recovery**: Accidentally delete your config? With Git, you can\n  restore it from your repository in minutes.\n\nInstalling Git on NixOS\n\nYou can install Git by adding it to your system packages in your\nconfiguration.nix or via Home Manager:\n\n## Git Tips\n\n<!-- ![Octocat](../images/octocat.png) -->\n\nIf you develop good git practices on your own repositories it will make it\neasier to contribute with others as well as get help from others.\n\n## Atomic Commits\n\n**Atomic commits** are a best practice in Git where each commit represents a\nsingle, focused, and complete change to the codebase. The main characteristics\nof atomic commits are:\n\n- **One purpose**: Each commit should address only one logical change or task.\n\n- **Complete**: The commit should leave the codebase in a working state.\n\n- **Descriptive**: The commit message should be able to clearly summarize the\n  change in a single sentence.\n\n**Why Atomic Commits Matter**\n\n- **Easier debugging**: You can use tools like `git bisect` to quickly find\n  which commit introduced a bug, since each commit is isolated.\n\n- **Simpler reverts**: You can revert without affecting unrelated changes.\n\n- **Better collaboration**: Code reviews and merges are more manageable when\n  changes are small and focused.\n\nWhen you lump together a bunch of changes into a single commit it can lead to\nquite a few undesirable consequences. They make it harder to track down bugs,\nit's more difficult to revert undesired changes without reverting desired ones,\nmake larger tickets harder to manage.\n\n**Every time a logical component is completed, commit it**. Smaller commits make\nit easier for other devs and yourself to understand the changes and roll them\nback if necessary. This also makes it easier to share your code with others to\nget help when needed and makes merge conflicts less frequent and complex.\n\n**Finish the component, then commit it**: There's really no reason to commit\nunfinished work, use `git stash` for unfinished work and `git commit` for when\nthe logical component is complete. Use common sense and break complex components\ninto logical chunks that can be finished quickly to allow yourself to commit\nmore often.\n\n**Write Good Commit Messages**: Begin with a summary of your changes, add a line\nof whitespace between the summary and the body of your message. Make it clear\nwhy this change was necessary. Use consistent language with generated messages\nfrom commands like `git merge` which is imperative and present tense\n(`<<change>>`, not `<<changed>>` or `<<changes>>`).\n\n### Tips for Keeping Commits Atomic with a Linear History\n\nSquashing limits the benefits of atomic commits as it combines them all into a\nsingle commit as if you didn't take the time to write them all out atomically.\n\n🧠 Why Rebasing Wins for Linear History\n\n- No Merge Bubbles: Rebasing avoids those extra merge commits that clutter\n  `git log --graph`. You get a clean, readable timeline.\n\n- Atomic Commit Integrity: Each commit stands alone and tells a story. Rebasing\n  preserves that narrative without diluting it with merge noise.\n\n- Better Blame & Bisect: Tools like git blame and git bisect work best when\n  history is linear and logical.\n\n- Time-Travel Simplicity: Cherry-picking or reverting is easier when commits\n  aren’t tangled in merge commits.\n\nBy default, when you run `git pull` git merges the commits into your local repo.\nTo change this to a rebase you can set the following:\n\n```bash\ngit config --global pull.rebase true\ngit config --global rebase.autoStash true\ngit config --global fetch.prune true  # auto delets remote-tracking branches that no longer exist\ngit config --global pull.ff only          # blocks merge pulls\n```\n\nNote: With pull.ff only pulls will fail if they would have had to merge. This\ncould happen if your local branch has diverged from the remote (e.g., someone\npushed new commits and you also committed locally) `git pull` will throw an\nerror like:\n\n```bash\nfatal: Not possible to fast-forward, aborting.\n```\n\n**How to fix it**\n\nYou basically do what Git won't auto-do:\n\n```bash\ngit fetch origin\ngit rebase origin/main\n```\n\nThis rewinds your local commits, applies remote commits, and replays yours on\ntop, keeping the history linear.\n\nIf you don't care about your local changes and want to discard them you can use\nthe following command:\n\n```bash\ngit reset --hard origin/main\n```\n\nThis just makes your branch identical to the remote, no rebase required. This\nprevents rogue merge commits, preserving atomic commits and linear logs.\n\nYou could set an alias for this with:\n\n```bash\ngit config --global alias.grs '!git fetch origin && git rebase origin/main'\n```\n\nTo check whether a setting is active or now you can use:\n\n```bash\ngit config --get rebase.autoStash\ntrue\n```\n\nTo set these options with home-manager:\n\n```nix\n# ... snip ...\n    extraConfig = lib.mkOption {\n      type = lib.types.attrs;\n      default = {\n        commit.gpgsign = true;\n        gpg.format = \"ssh\";\n        user.signingkey = \"/etc/ssh/ssh_host_ed25519_key.pub\";\n        extraConfig = {\n          pull = {\n            rebase = true;\n            ff = \"only\";\n        };\n        };\n        rebase = {\n          autoStash = true; # Auto stashes and unstashes local changes during rebase\n        };\n        fetch = {\n          prune = true; # Automatically deletes remote-tracking branches that no longer exist\n        };\n# ... snip ...\n```\n\n## Time Travel in Git\n\n<details>\n<summary> ✔️ Click to Expand Time Travel Section </summary>\n\n**View an old commit**:\n\n```bash\ngit checkout <commit_hash>\n```\n\nThis puts you in a \"detached HEAD\" state, letting you explore code as it was at\nthat commit. To return, checkout your branch again.\n\n**Go back and keep history (revert)**:\n\n```bash\ngit revert <commit_hash>\n```\n\n**Go back and rewrite history (reset)**:\n\n- Soft reset (keep changes staged):\n\n```bash\ngit reset --soft <commit_hash>\n```\n\n- Mixed reset (keep changes in working directory):\n\n```bash\ngit reset <commit_hash>\n```\n\n- Hard reset (discard all changes after the commit):\n\n```bash\ngit reset --hard <commit_hash>\n```\n\nUse the above command with caution, it can delete commits from history.\n\n- Relative time travel:\n\n```bash\ngit reset --hard HEAD@{5.minutes.ago}\n```\n\nor\n\n```bash\ngit reset --hard HEAD@{yesterday}\n```\n\n**Create a branch from the past**:\n\n```bash\ngit checkout -b <new-brach> <commit_hash>\n```\n\nThis starts a new branch from any previous commit, preserving current changes.\n\n</details>\n\nSome repositories have guidelines, such as Nixpkgs:\n\n<details>\n<summary> ✔️ Click to Expand Nixpkgs Commit Conventions </summary>\n\n**Commit conventions**\n\n- Create a commit for each logical unit.\n\n- Check for unnecessary whitespace with `git diff --check` before committing.\n\n- If you have commits pkg-name: oh, forgot to insert whitespace: squash commits\n  in this case. Use `git rebase -i`. See Squashing Commits for additional\n  information.\n\n- For consistency, there should not be a period at the end of the commit\n  message's summary line (the first line of the commit message).\n\n- When adding yourself as maintainer in the same pull request, make a separate\n  commit with the message maintainers: `add <handle>`. Add the commit before\n  those making changes to the package or module. See Nixpkgs Maintainers for\n  details.\n\n  Make sure you read about any commit conventions specific to the area you're\n  touching. See: Commit conventions for changes to `pkgs`. Commit conventions\n  for changes to `lib`. Commit conventions for changes to `nixos`. Commit\n  conventions for changes to `doc`, the Nixpkgs manual.\n\n**Writing good commit messages**\n\nIn addition to writing properly formatted commit messages, it's important to\ninclude relevant information so other developers can later understand why a\nchange was made. While this information usually can be found by digging code,\nmailing list/Discourse archives, pull request discussions or upstream changes,\nit may require a lot of work.\n\nPackage version upgrades usually allow for simpler commit messages, including\nattribute name, old and new version, as well as a reference to the relevant\nrelease notes/changelog. Every once in a while a package upgrade requires more\nextensive changes, and that subsequently warrants a more verbose message.\n\nPull requests should not be squash merged in order to keep complete commit\nmessages and GPG signatures intact and must not be when the change doesn't make\nsense as a single commit.\n\n</details>\n\nA **Git workflow** is a recipe or recommendation for how to use Git to\naccomplish work in a consistent and productive manner. Having a defined workflow\nlets you leverage Git effectively and consistently. This is especially important\nwhen working on a team.\n\n**Origin** is the _default name_ (alias) for the **remote repository** that your\n**local repository** is connected to, usually the one you cloned from.\n\n**Remote Repositories** are versions of your project that are hosted on the\ninternet or network somewhere.\n\n- When you run `git push origin main`, you're telling Git to push your changes\n  to the remote repo called `origin`.\n\n- You can see which URL `origin` points to with `git remote -v`.\n\n- You can have multiple remotes (like `origin`, `upstream`, etc.) each pointing\n  to a different remote repo. Each of which is generally either read-only or\n  read/write for you. Collaborating involves managing these remotes and pushing\n  and pulling data to and from them when you need to share work.\n\n> ❗ You can have a remote repo on your local machine. The word \"remote\" doesn't\n> imply that the repository is somewhere else, only that it's elsewhere.\n\n- The name `origin` is just a convention, it's not special. It is automatically\n  set when you clone a repo.\n\n<!-- ![git local remote](../images/git_local-remote.png) -->\n\n**Local** is your local copy of the repository, git tracks the differences\nbetween **local** and **remote** which is a repo hosted elsewhere (e.g., GitHub\nGitLab etc.)\n\nThe **Upstream** in Git typically refers to the original repository from which\nyour local repository or fork was derived. The **Upstream** is the remote repo\nthat serves as the main source of truth, often the original project you forked\nfrom. You typically fetch changes from upstream to update your local repo with\nthe latest updates from the original project, but you don't push to upstream\nunless you have write access.\n\n### A Basic Git Workflow\n\n<!-- ![Git logo 3](../images/git2.png) -->\n\n1. Initialize your Repository:\n\nIf you haven't already created a Git repo in your NixOS config directory (for\nexample, in your flake or `/etc/nixos`):\n\n```bash\ncd ~/flake\ngit init\ngit add .\ngit commit -m \"Initial commit: NixOS Configuration\"\n```\n\nTaking this initial snapshot with Git is a best practice—it captures the exact\nstate of your working configuration before you make any changes.\n\n- The command `git add .` stages all files in the directory (and its\n  subdirectories) for commit, meaning Git will keep track of them in your\n  project history.\n\n- The command `git commit -m \"message\"` then saves a snapshot of these staged\n  files, along with your descriptive message, into the repository.\n  - Think of a commit as a \"save point\" in your project. You can always go back\n    to this point if you need to, making it easy to experiment or recover from\n    mistakes. This two-step process, staging with `git add` and saving with\n    `git commit` is at the heart of how Git tracks and manages changes over\n    time.\n\n<!-- ![git commit add](../images/git-add-commit.png) -->\n\n2. Make and Track Changes:\n\nNow that you've saved a snapshot of your working configuration, you're free to\nexperiment and try new things, even if they might break your setup.\n\nSuppose you want to try a new desktop environment, like Xfce. You edit your\n`configuration.nix` to add:\n\n```nix\nservices.xserver.desktopManager.xfce.enable = true;\n```\n\nYou run:\n\n```bash\nsudo nixos-rebuild switch # if configuration.nix is in /etc/nixos/\n```\n\nBut something goes wrong: the system boots, but your desktop is broken or won't\nstart. You decide to roll back using the boot menu or:\n\n```bash\nsudo nixos-rebuild switch --rollback\n```\n\n**What happens?**\n\n- Your system reverts to the previous working generation in `/nix/store`\n\n- But: Your `configuration.nix` file is still changed, it still has the line\n  enabling Xfce. If you rebuild again, you'll get the same broken system,\n  because your config itself wasn't rolled back.\n\n**How does Git Help on Failure?**\n\nGit gives you quite a few options and ways to inspect what has been done.\n\n- Use `git status` to see what's changed, and `git checkout -- <file>` to\n  restore any file to its last committed state.\n\n- Review your changes with `git diff` to see exactly what you modified before\n  deciding whether to keep or revert those changes.\n\n- Reset everything with `git reset --hard HEAD`, this will discard all local\n  changes and return to your last commit.\n\nWith Git you can simply run:\n\n```bash\ngit checkout HEAD~1 configuration.nix\n# or, if you committed before the change:\ngit revert <commit-hash>\n```\n\nShow the full hash of the latest commit:\n\n```bash\ngit rev-parse HEAD\nf53fef375d89496c0174e70ce94993d43335098e\n```\n\nShort hash:\n\n```bash\ngit log --pretty=format:'%h' -n 1\nf53fef3\ngit revert f53fef3\n```\n\nShow a list of Recent commits:\n\n```bash\ngit log\n# a list of all commits, with hashes, author, date, and message\ngit log --oneline\ngit log --oneline\nf53fef3 (HEAD -> main) thunar\nb34ea22 thunar\n801cbcf thunar\n5e72ba5 sops\n8b67c59 sops\n1a353cb sops\n```\n\nYou can copy the commit hash from any of these and use it in commands like\n`git checkout <hash>` or `git revert <hash>`.\n\n**Commit successful experiments**\n\n- If your changes work, stage, and commit them:\n\n```bash\ngit add .\n# or more specifically the file you changed or created\ngit add configuration.nix\ngit commit -m \"Describe the new feature or fix\"\n```\n\n### Basic Branching\n\nWith Git you're always on a branch and the default branch is `master`. Many\nchange it to `main` because of the suggestion Git gives you. I think people are\ntoo easily offended these days, just keep this in mind that `main` and `master`\nrefer to the main development branch.\n\nYou can get a listing of your current branches with:\n\n```bash\ngit branch\n* (no branch)\n  main\n```\n\nThe `*` is next to the current branch and is where the `HEAD` is currently\npointing. It says `(no branch)` because I'm currently in detached `HEAD` where\n`HEAD` points to no branch. The reason for this is because I've been trying out\nJujutsu VCS and that's JJ's default setting, a detached `HEAD`.\n\nGit actually gives you a warning about working in a detached `HEAD`:\n\n```bash\nYou are in 'detached HEAD' state. You can make experimental\nchanges and commit them, and you can discard any commits you make\nin this state without impacting any branch by switching back.\n\nIf you want to create a new branch to retain commits you create,\nyou can do so now (using 'git switch -c <new-branch-name>') or\nlater (using 'git branch <new-branch-name> <commit-id>').\n\nSee 'git help switch' for details.\n```\n\nTo attach the `HEAD` (i.e., have the pointer pointing to a branch), use the\n`git checkout` command\n\n```bash\ngit checkout main\nSwitched to branch 'main'\n```\n\n```bash\ngit branch\n* main\n# Ensure that you have the latest \"tip\" from the remote repository `origin`\ngit fetch origin main\nFrom github.com:sayls8/flake\n * branch            main       -> FETCH_HEAD\n```\n\nAlthough we're working on our own repo and there is basically no chance of our\nlocal branch diverging from our remote, it's still good to get in the practice\nof getting everything in sync before merging or rebasing etc.\n\n`git fetch` doesn't update `main`, it just updates your references. To update\n`main` you would use `git pull origin/main` or `git rebase origin/main`\n\nYou can inspect your upstream branches with the following command:\n\n```bash\ngit remote show origin\n* remote origin\n  Fetch URL: git@github.com:saylesss88/flake.git\n  Push  URL: git@github.com:saylesss88/flake.git\n  HEAD branch: main\n  Remote branch:\n    main tracked\n  Local ref configured for 'git push':\n    main pushes to main (fast-forwardable)\n```\n\n`* branch     main      -> FETCH_HEAD`: This line signifies that the `main`\nbranch from the remote repository (likely `origin`) was successfully fetched,\nand the commit ID of its current tip (its latest commit) is now stored in your\nlocal `FETCH_HEAD` reference.\n\nNow that we know our local `main` is up to date with our remote `origin/main` we\ncan safely create a new feature branch:\n\n```bash\ngit checkout -b feature/prose_wrap\nSwitched to a new branch 'feature/prose_wrap'\n```\n\nRight now the branch `feature/prose_wrap` is exactly the same as `main` and we\ncan safely make changes without affecting `main`. We can try crazy or even\n\"dangerous\" things and always be able to revert to a working state with\n`git checkout main`.\n\nIf our crazy idea works out, we can then merge our feature branch into `main`.\n\nOk the feature works, I've added and committed the change. Now it's time to\npoint the `HEAD` to `main` and then either merge or rebase the feature branch\ninto `main`:\n\n```bash\ngit checkout main\ngit fetch origin main\ngit merge feature/prose_wrap\nUpdating c8bd54c..b281f79\nFast-forward\n home/editors/helix/default.nix | 69 +++++++++++++++++++++++++++++++--------------------------------------\n 1 file changed, 31 insertions(+), 38 deletions(-)\n```\n\n- \"fast-forward\" means that our `feature/prose_wrap` branch was directly ahead\n  of the last commit on `main`. When you merge one commit with another commit\n  that can be reached by following the first commits history, remember the\n  feature branch is exactly the same as `main` until I made another commit. If\n  the branches diverged more and the history can't be followed, Git will perform\n  a 3-way merge where it creates a new \"merge commit\" that combines the 2\n  changes.\n\nIf you have a bunch of branches and forget which have been merged yet use:\n\n```bash\ngit branch --merged\nfeature/prose_wrap\n* main\n# OR to see branches that haven't been merged use:\ngit branch --no-merged\n```\n\nIt's now safe to delete the feature branch:\n\n```bash\ngit branch -d feature/prose_wrap\nDeleted branch feature/prose_wrap (was b281f79)\n```\n\n> ❗ TIP: If your feature branch has a lot of sloppy commits that won't be of\n> much benefit to anyone, squash them first then merge. The workflow would look\n> something like this:\n>\n> ```bash\n>  # Make sure you're on the main branch\n>  git checkout main\n>\n>  # Merge the feature branch with squash\n>  git merge --squash feature/prose_wrap\n> ```\n>\n> - This combines all the commits in your branch and adds them to your `main`\n>   staging area, it doesn't move HEAD or create a merge commit for you. To\n>   apply the changes into one big commit, finalize it with:\n>\n> ```bash\n>  git commit -m \"Add prose wrapping feature\"\n> ```\n>\n> This is often referred to as the \"squash commit\".\n\nBranching means to diverge from the main line of development and continue to do\nwork without risking messing up your main branch. There are a few commits on\nyour main branch so to visualize this it would look something like this, image\nis from [Pro Git](https://git-scm.com/book/en/v2):\n\n<!-- ![Git Branch 1](../images/git-branch3.png) -->\n\n## Nix flake update example with branches\n\nLet's say you haven't ran `nix flake update` in a while and you don't want to\nintroduce errors to your working configuration. To do so we can first, make sure\nwe don't lose any changes on our main branch:\n\n```bash\ngit add .\ngit commit -m \"Staging changes before switching branches\"\n# I always like to make sure the configuration will build before pushing to git\nsudo nixos-rebuild switch --flake .\n# If everything builds and looks correct\ngit push origin main\n```\n\nOR, if you have incomplete changes that you don't want to commit yet you can\nstash them with `git stash`:\n\n```bash\ngit status\nOn branch main\nYour branch is ahead of 'origin/main' by 1 commit.\n  (use \"git push\" to publish your local commits)\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n        modified:   home/git.nix\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n```\n\nNow we want to switch branches, without committing the incomplete changes to\n`git.nix`:\n\n```bash\ngit stash\nSaved working directory and index state WIP on main: 0e46d6b git: lol alias\n\ngit status\nOn branch main\nYour branch is ahead of 'origin/main' by 1 commit.\n  (use \"git push\" to publish your local commits)\n\nnothing to commit, working tree clean\n```\n\n> ❗ `git stash` is equivalent to `git stash push`\n\nTo see which stashes you have stored, use `git sash list`:\n\n```bash\ngit stash list\nstash@{0}: WIP on main: 0e46d6b git: lol alias\n```\n\nTo apply the most recent stash:\n\n```bash\ngit stash apply\ngit add home/git.nix\nOn branch main\nYour branch is ahead of 'origin/main' by 1 commit.\n  (use \"git push\" to publish your local commits)\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n        modified:   home/git.nix\n\n# or for multiple stashes\ngit stash apply stash@{2}\n```\n\nRunning `git stash apply` applies the changes that were in your stash but\ndoesn't automatically restage them, to apply the changes and stage them in one\ncommand:\n\n```bash\ngit stash apply --index\n```\n\nNow let's create our branch so we can safely update:\n\n```bash\ngit checkout -b update-test\nSwitched to a new branch 'update-test'\n```\n\n`-b` is to switch to the branch that was just created\n\nSome may prefer a more descriptive branch name such as: `update/flake-inputs`, I\nkept it short for the example. Or if your company uses an issue tracker,\nincluding the ticket number in the branch name can be helpful:\n`update/123-flake-inputs`\n\nThe above command is equivalent to:\n\n```bash\ngit branch update-test\ngit checkout update-test\n```\n\n~~Now our branches would look something like this, note how both branches\ncurrently point to the same commit:~~ I discovered that Git Book has pretty\nrestrictive licensing and will eventually find a replacement.\n\n<!-- ![Git Branch 2](../images/git-branch2.png) -->\n\nNow, lets run our update:\n\n```bash\nnix flake update\nsudo nixos-rebuild test --flake .\n# If everything looks ok let's try applying the changes\nsudo nixos-rebuild switch --flake .\n# And if everything looks ok:\ngit add .\ngit commit -m \"feat: Updated all flake inputs\"\ngit push origin update-test\n```\n\n> ❗ This is the same workflow for commiting a PR. After you first fork and\n> clone the repo you want to work on, you then create a new feature branch and\n> push to that branch on your fork. This allows you to create a PR comparing\n> your changes to their existing configuration.\n\n~~At this point our graph would look similar to the following~~:\n\n<!-- ![Git Branch 3](../images/git-branch1.png) -->\n\nIf we are satisfied, we can switch back to our `main` branch and merge\n`update-test` into it:\n\n```bash\ngit checkout main\ngit merge origin/update-test\ngit branch -D update-test\nsudo nixos-rebuild test --flake .\nsudo nixos-rebuild switch --flake .\n```\n\nIt's good practice to delete a branch after you've merged and are done with it.\n\n## Rebasing Branches\n\nTo combine two seperate branches into one unified history you typically use\n`git merge` or `git rebase`.\n\n`git merge` takes two commit pointers and finds a common base commit between\nthem, it then creates a \"merge commit\" that combines the changes.\n\n`git rebase` is used to move a sequence of commits to a new base commit.\n\n<!-- ![Git rebase](../images/rebase.png) -->\n\n## Configure Git Declaratively\n\nThe following example is the `git.nix` from the hydenix project it shows some\ncustom options and a way to manage everything from a single location:\n\n```nix\n# git.nix from hydenix: declarative Git configuration for Home Manager\n{ lib, config, ... }:\n\nlet\n  cfg = config.hydenix.hm.git;\nin\n{\n\n  options.hydenix.hm.git = {\n    enable = lib.mkOption {\n      type = lib.types.bool;\n      default = config.hydenix.hm.enable;\n      description = \"Enable git module\";\n    };\n\n    name = lib.mkOption {\n      type = lib.types.nullOr lib.types.str;\n      default = null;\n      description = \"Git user name\";\n    };\n\n    email = lib.mkOption {\n      type = lib.types.nullOr lib.types.str;\n      default = null;\n      description = \"Git user email\";\n    };\n  };\n\n  config = lib.mkIf cfg.enable {\n\n    programs.git = {\n      enable = true;\n      userName = cfg.name;\n      userEmail = cfg.email;\n      extraConfig = {\n        init.defaultBranch = \"main\";\n        pull.rebase = false;\n      };\n    };\n  };\n}\n```\n\n> ❗ You can easily change the name of the option, everything after `config.` is\n> custom. So you could change it to for example, `config.custom.git` and you\n> would enable it with `custom.git.enable = true;` in your `home.nix` or\n> equivalent.\n\nThen he has a `hm/default.nix` with the following to enable it.\n\n```nix\n#...snip...\n\n # hydenix home-manager options go here\n  hydenix.hm = {\n    #! Important options\n    enable = true;\n      git = {\n        enable = true; # enable git module\n        name = null; # git user name eg \"John Doe\"\n        email = null; # git user email eg \"john.doe@example.com\"\n      };\n    }\n\n    # ... snip ...\n```\n\nYou can enable git, and set your git username as well as git email right here.\n\n### Resources\n\n- [GitCommitBestPractices](https://gist.github.com/luismts/495d982e8c5b1a0ced4a57cf3d93cf60)\n\n- [ProGit](https://git-scm.com/book/en/v2)\n\n- [Oh shit Git](https://ohshitgit.com/)\n","number":[1,4],"sub_items":[],"path":"vcs/git.md","source_path":"vcs/git.md","parent_names":["Getting Started with the Nix Ecosystem"]}},{"Chapter":{"name":"Version Control with JJ","content":"# Version Control with JJ\n\n<details>\n<summary> ✔️ Click to Expand Table of Contents</summary>\n\n<!-- toc -->\n\n</details>\n\n![JJ Logo](../images/jujutsu.png)\n\n<div style=\"font-size: 0.8em; margin-top: 10px;\">\n  **Image Source:** This image is from the [Jujutsu VCS repository](https://github.com/jj-vcs/jj) and is licensed under the Apache 2.0 License.\n</div>\n\n⚠️ **Security Reminder**: Never commit secrets (passwords, API keys, tokens,\netc.) in plain text to your Git repository. If you plan to publish your NixOS\nconfiguration, always use a secrets management tool like `sops-nix` or `agenix`\nto keep sensitive data safe. See the\n[Sops-Nix Guide](https://saylesss88.github.io/installation/enc/sops-nix.html)\nfor details.\n\n## Getting Started\n\nJujutsu (jj) is a modern, Git-compatible version control system designed to\nsimplify and improve the developer experience. It offers a new approach to\ndistributed version control, focusing on a more intuitive workflow, powerful\nundo capabilities, and a branchless model that reduces common pitfalls of Git.\n\n**Recommended resources**:\n\n- [Steve's Jujutsu Tutorial](https://steveklabnik.github.io/jujutsu-tutorial/)\n  (most up to date). Steve does an excellent job explaining the ins and outs of\n  Jujutsu.\n\n- [zerowidth jj-tips-and-tricks](https://zerowidth.com/2025/jj-tips-and-tricks/)\n\n- Official:\n\n```bash\njj help -k tutorial\n```\n\n- Every time you run a `jj` command, it examines the working copy and takes a\n  snapshot.\n\n- Command help:\n\n```bash\njj <command> --help\njj git init --help\njj git push --help\n```\n\n## 🔑 Key Concepts\n\n<details>\n<summary> ✔️ Click to Expand Key Concepts </summary>\n\n1. Working Copy as Commit\n\n- In JJ your working copy is always a real commit. Any changes you make are\n  automatically recorded in this working commit. The working copy is always\n  (`@`) and the Parent commit is always `(@-)` keep this in mind.\n\n- There is **no staging area** (index) as in Git. You do not need to run\n  `git add` or `git commit` for every change. Modifications are always tracked\n  in the current commit.\n\n2. Branchless Workflow and Bookmarks\n\n- JJ does not have the concept of a \"current branch.\" Instead, use bookmarks,\n  which are named pointers to specific commits.\n\n- Bookmarks do not move automatically. Commands like `jj new` and `jj commit`\n  move the working copy, but the bookmark stays were it was. Use\n  `jj bookmark move` to move bookmarks. (e.g., `jj bookmark move main`). You can\n  also use `jj bookmark set main -r @` to explicitly set the main bookmark to\n  point at the working copy commit.\n\n- Only commits referenced by bookmarks are pushed to remotes, preventing\n  accidental sharing of unfinished work.\n\n3. Automatic Tracking and Simpler Workflow\n\n- Adding or removing files is automatically tracked, no need for explicit `add`\n  or `rm` commands.\n\n- The working copy acts as a live snapshot of your workspace. Commands first\n  sync filesystem changes into this commit, then perform the requested\n  operation, and finally update the working copy if needed.\n\n4. Operation Log and Undo\n\n- JJ records every operation (commits, merges, rebases, etc.) in an **operation\n  log**. Inspect it with: `jj op log`\n\n- You can view and undo any previous operation, not just the most recent one,\n  making it easy to recover from mistakes, a feature not present in Git’s core\n  CLI.\n\n5. First-Class Conflict Handling\n\nConflicts happen when JJ can't figure out how to merge different changes made to\nthe same file.\n\n- Conflicts are stored inside commits, not just in the working directory. You\n  can resolve them at any time, not just during a merge or rebase.\n\n- Conflict markers are inserted directly into files, and JJ can reconstruct the\n  conflict state from these markers. You can resolve conflicts by editing the\n  files or using `jj resolve`.\n\n6. Revsets and Filesets\n\n- **Revsets**: JJ's powerful query language for selecting sets of commits,\n  inspired by Mercurial. For example, `jj log -r \"author(alice) & file(*.py)\"`\n  lists all commits by Alice that touch Python files.\n\n- **Filesets**:JJ supports a functional language for selecting sets of files,\n  allowing advanced file-based queries and operations.\n\n| Feature              | Git                      | Jujutsu (jj)                                |\n| :------------------- | :----------------------- | :------------------------------------------ |\n| Staging Area         | Yes (git add/index)      | No, working copy is always a commit         |\n| Commit Workflow      | Stage → Commit           | All changes auto-recorded in working commit |\n| Branches             | Central to workflow      | Optional, bookmarks used for sharing        |\n| Undo/Redo            | Limited, complex         | Easy, operation log for undo                |\n| Conflict Handling    | Manual, can be confusing | Conflicts tracked in commits, easier to fix |\n| Integration with Git | Native                   | Fully compatible, can switch back anytime   |\n\n7. Anonymous branches: In Git a branch is a pointer to a commit that needs a\n   name.\n\nIf you haven't taken the time to deep dive Git, it may be a good time to learn\nabout a new way of doing Version Control that is actually less complex and\neasier to mentally map out in my opinion.\n\nJujutsu is a new front-end to Git, and it's a new design for distributed version\ncontrol. --jj init\n\nYou can use jujutsu (jj) with existing Git repositories with one command.\n`jj git init --colocate` or `jj git init --git-repo /path/to/git_repository`.\nThe native repository format for jj is still a work in progress so people\ntypically use a `git` repository for backend.\n\nUnlike `git`, `jj` has no index \"staging area\". It treats the working copy as an\nactual commit. When you make changes to files, these changes are automatically\nrecorded to the working commit. There's no need to explicitly stage changes\nbecause they are already part of the commit that represents your current working\nstate.\n\n</details>\n\n**Simplified Workflow**\n\nCheck where you're at, JJ doesn't care about commits without descriptions but\nGit and GitHub do:\n\n```bash\njj st\nWorking copy  (@) now at: zuknrzrx 8a20bfa7 (empty) (no description set)\nParent commit (@-)      : yzppulzo bdd64e8d main | (empty) \"Enable Rofi and update nu func for jj\"\n```\n\nWe can see that the Working copy is `(empty)` and has `(no description set)`,\nlets give it a description:\n\n```bash\njj desc -m \"My feature\"\n# ...edit files...\n# Check where we're at again\njj st\nWorking copy changes:\nM home/jj.nix\nWorking copy  (@) : zuknrzrx bcd3d965 My feature\nParent commit (@-): yzppulzo bdd64e8d main | (empty) \"Enable Rofi and update nu func for jj\"\n\n# Tell JJ which branch we're interested in\njj bookmark set main\n# Push this change to main\njj git push\nChanges to push to origin:\n  Move forward bookmark main from bdd64e8d6ea5 to bcd3d96567f8\nremote: Resolving deltas: 100% (3/3), completed with 3 local objects.\nWarning: The working-copy commit in workspace 'default' became immutable, so a new commit has been created on top of it.\nWorking copy  (@) now at: ktlywzlx 8e88ddbe (empty) (no description set)\nParent commit (@-)      : zuknrzrx bcd3d965 main | My feature\n```\n\n## What is the Jujutsu Working Copy\n\n<details>\n<summary> ✔️ Click To Expand Working Copy Description </summary>\n\nThe **working copy** in Jujutsu is an actual **commit** that represents the\ncurrent state of the files you're working on. Unlike Git, where the working copy\nis separate from commits and changes must be explicitly staged and committed, in\nJJ the working copy is a live commit that automatically records changes as you\nmodify files.\n\nAdding or removing files in the working copy implicitly tracks or untracks them\nwithout needing explicit commands like `git add`\n\nThe working copy commit acts as a snapshot of your current workspace. When you\nrun commands, Jujutsu first syncs the filesystem changes into this commit, then\nperforms the requested operation, and finally updates the working copy if needed\n\nTo finalize your current changes and start a new set of changes, you use the\n`jj new` command, which creates a new working-copy commit on top of the current\none. This replaces the traditional Git workflow of staging and committing\nchanges separately.\n\nConflicts in the working copy are represented by inserting conflict markers\ndirectly into the files. Jujutsu tracks the conflicting parts and can\nreconstruct the conflict state from these markers. You resolve conflicts by\nediting these markers and then committing the resolution in the working copy\n\n- This means that you don't need to worry about making a change, running\n  `git add .`, running `git commit -m \"commit message\"` because it's already\n  done for you. This is handy with flakes by preventing a \"dirty working tree\"\n  and can instantly be rebuilt after making a change.\n\n</details>\n\n## Example JJ Module\n\n<details>\n<summary> ✔️ Click to Expand JJ home-manager module example </summary>\n\n- For `lazygit` fans, Nixpkgs has `lazyjj`. I've seen that it's recommended to\n  use jj with `meld`. I'll share my `jj.nix` here for an example:\n\n- I got a lot of the aliases and such from the\n  [zerowidth](https://zerowidth.com/2025/jj-tips-and-tricks/) post, this has\n  been a game changer:\n\n```nix\n{\n  lib,\n  config,\n  pkgs,\n  # userVars ? {},\n  #\n  #\n  #\n  ...\n}: let\n  cfg = config.custom.jj;\nin {\n  options.custom.jj = {\n    enable = lib.mkOption {\n      type = lib.types.bool;\n      default = true;\n      description = \"Enable the Jujutsu (jj) module\";\n    };\n\n    userName = lib.mkOption {\n      type = lib.types.nullOr lib.types.str;\n      default = \"sayls8\";\n      description = \"Jujutsu user name\";\n    };\n\n    userEmail = lib.mkOption {\n      type = lib.types.nullOr lib.types.str;\n      default = \"sayls8@proton.me\";\n      description = \"Jujutsu user email\";\n    };\n\n    packages = lib.mkOption {\n      type = lib.types.listOf lib.types.package;\n      default = with pkgs; [lazyjj meld];\n      description = \"Additional Jujutsu-related packages to install\";\n    };\n\n    settings = lib.mkOption {\n      type = lib.types.attrs;\n      default = {\n        ui = {\n          # default-command = \"log-recent\";\n          default-command = [\"status\" \"--no-pager\"];\n          diff-editor = \"gitpatch\";\n          # diff-editor = [\"nvim\" \"-c\" \"DiffEditor\" \"$left\" \"$right\" \"$output\"];\n          # diff-formatter = [\"meld\" \"$left\" \"$right\"];\n          merge-editor = \":builtin\";\n          conflict-marker-style = \"diff\";\n        };\n        git = {\n          # remove the need for `--allow-new` when pushing new bookmarks\n          auto-local-bookmark = true;\n          push-new-bookmarks = true;\n        };\n        revset-aliases = {\n          \"closest_bookmark(to)\" = \"heads(::to & bookmarks())\";\n          \"immutable_heads()\" = \"builtin_immutable_heads() | remote_bookmarks()\";\n          # The following command is incorrect, TODO\n          # \"default()\" = \"coalesce(trunk(),root())::present(@) | ancestors(visible_heads() & recent(), 2)\";\n          \"recent()\" = \"committer_date(after:'1 month ago')\";\n          trunk = \"main@origin\";\n        };\n        template-aliases = {\n          \"format_short_change_id(id)\" = \"id.shortest()\";\n        };\n        merge-tools.gitpatch = {\n          program = \"sh\";\n          edit-args = [\n            \"-c\"\n            ''\n              set -eu\n              rm -f \"$right/JJ-INSTRUCTIONS\"\n              git -C \"$left\" init -q\n              git -C \"$left\" add -A\n              git -C \"$left\" commit -q -m baseline --allow-empty\n              mv \"$left/.git\" \"$right\"\n              git -C \"$right\" add --intent-to-add -A\n              git -C \"$right\" add -p\n              git -C \"$right\" diff-index --quiet --cached HEAD && { echo \"No changes done, aborting split.\"; exit 1; }\n              git -C \"$right\" commit -q -m split\n              git -C \"$right\" restore . # undo changes in modified files\n              git -C \"$right\" reset .   # undo --intent-to-add\n              git -C \"$right\" clean -q -df # remove untracked files\n            ''\n          ];\n        };\n        aliases = {\n          c = [\"commit\"];\n          ci = [\"commit\" \"--interactive\"];\n          e = [\"edit\"];\n          i = [\"git\" \"init\" \"--colocate\"];\n          tug = [\"bookmark\" \"move\" \"--from\" \"closest_bookmark(@-)\" \"--to\" \"@-\"];\n          log-recent = [\"log\" \"-r\" \"default() & recent()\"];\n          nb = [\"bookmark\" \"create\" \"-r\" \"@-\"]; # new bookmark\n          upmain = [\"bookmark\" \"set\" \"main\"];\n          squash-desc = [\"squash\" \"::@\" \"-d\" \"@\"];\n          rebase-main = [\"rebase\" \"-d\" \"main\"];\n          amend = [\"describe\" \"-m\"];\n          pushall = [\"git\" \"push\" \"--all\"];\n          push = [\"git\" \"push\" \"--allow-new\"];\n          pull = [\"git\" \"fetch\"];\n          dmain = [\"diff\" \"-r\" \"main\"];\n          l = [\"log\" \"-T\" \"builtin_log_compact\"];\n          lf = [\"log\" \"-r\" \"all()\"];\n          r = [\"rebase\"];\n          s = [\"squash\"];\n          si = [\"squash\" \"--interactive\"];\n        };\n        revsets = {\n          # log = \"main@origin\";\n          # log = \"master@origin\";\n        };\n      };\n      description = \"Jujutsu configuration settings\";\n    };\n  };\n\n  config = lib.mkIf cfg.enable {\n    home.packages = cfg.packages;\n\n    programs.jujutsu = {\n      enable = true;\n      settings = lib.mergeAttrs cfg.settings {\n        user = {\n          name = cfg.userName;\n          email = cfg.userEmail;\n        };\n      };\n    };\n  };\n}\n```\n\nIn my `home.nix` I have this to enable it:\n\n```nix\ncustom = {\n    jj = {\n        enable = true;\n        userName = \"sayls8\";\n        userEmail = \"sayls8@proton.me\";\n        packages = \"\";\n    };\n};\n```\n\n</details>\n\nThe `custom.jj` module allows me to override the username, email, packages, and\nwhether jj is enabled from a single, centralized place within my Nix\nconfiguration. So only if jj is enabled, `lazyjj` and `meld` will be installed.\n\nWith the above `gitpatch` setup, say you did more work than you want to commit\nwhich is common with jj since it automatically tracks everything. I can now run:\n\n```bash\njj commit -i\n```\n\nAnd an interactive diff will come up allowing you to choose what to include in\nthe current commit. This also works for `jj split -i` and `jj squash -i`.\n\nExample, using `jj commit -i`:\n\n![jj commit -i](../images/jj-gitpatch.png)\n\nYou can also use the `jj tug` command to make pushing to a remote more\nstraightforward. Since JJ's bookmarks don't automatically move as they do with\nGit, you can use `jj tug` after you've made a few commits to move the bookmark\nthat is closest to the parent commit of your current position to your current\ncommit:\n\n```bash\njj tug\njj git push\n```\n\nThe `tug` alias works for both the squash and edit workflows. After running\n`jj tug`, `jj git push` should work. If you get an error saying no bookmarks to\nmove, you can run `jj new` and then run `jj tug`, this happens when the bookmark\nis already at the parent commit.\n\n```nix\n# jj.nix\nmb = [\"bookmark\" \"set\" \"-r\" \"@\"];\n```\n\nAnother option would be to run `jj mb main` before running `jj git push` in this\nsituation, but you will have to describe the commit first.\n\n## Issues I've Noticed\n\n![jj tree](../images/jj2.png)\n\nI have run into a few issues, such as every flake command reloading every single\ninput every time. **What I mean by this is what you see when you run a flake\ncommand for the first time, it adds all of your flakes inputs.** I believe the\nfix for this is deleting and regenerating your `flake.lock`. The same thing can\nhappen when you move your flake from one location to another.\n\nJJ doesn't seem to automatically track completely new files, running\n`git add /file/path.nix` enables JJ to start tracking the new file.\n\nThat said, I recommend doing just that after running something like\n`jj git init --colocate`. Delete your `flake.lock` and run `nix flake update`,\n`nix flake lock --recreate-lock-file` still works but is being depreciated.\n\nSometimes the auto staging doesn't pick up the changes in your configuration so\nrebuilding changes nothing, this has been more rare but happens occasionally.\n\nOne of the most fundamental differences between Jujutsu and Git is how pushing\nworks. If you’re coming from Git, it’s important to understand this shift so you\ndon’t get tripped up by “nothing happened” warnings or missing changes on your\nremote.\n\n- In Git, you're always \"on\" a branch (e.g., `main`).\n\n- When you make a commit, the branch pointer automatically moves forward.\n\n- `git push` pushes the current branch's new commits to the remote.\n\n- If you forget to switch branches, you might accidentally push to the wrong\n  place, but you rarely have to think about \"moving\" the branch pointer\n  yourself.\n\n**The JJ Push Model**\n\n- JJ has no concept of a \"currrent branch\"\n\n- Bookmarks **do not** move automatically. When you make a new commit, the\n  bookmark (e.g., `main`) stays where it was. You must explicitly move it to\n  your new commit with `jj bookmark set main` (or create a new one).\n\n- JJ only pushes commits that are referenced by bookmarks. If your latest work\n  isn't pointed to by a bookmark, `jj git push` will do nothing and warn you.\n  This is to prevent accidental pushes and gives you more control over what gets\n  shared.\n\n**Typical JJ Push Workflow**\n\n1. Check out where your working copy and Parent commit are, you will notice that\n   jj highlights the minimal amount of characters needed to reference this\n   change:\n\n```bash\njj st\nWorking copy changes:\nM README.md\nWorking copy  (@) : mnkrokmt 7f0558f8 say hello and goodbye\nParent commit (@-): ywyvxrts 986d16f5 main | test3\n```\n\n- We can see that `ywy` is the `main` branch so lets create our change on top of\n  that. We can also see that it's (`@-`), and this is actually what `main` will\n  always be. Once I understood this everything came together.\n\n```bash\njj new @-\nWorking copy  (@) now at: kxwrsmmu bc7e8144 (empty) (no description set)\nParent commit (@-)      : ywyvxrts 986d16f5 main | test3\nAdded 0 files, modified 1 files, removed 0 files\njj desc @ -m \"Add a devShell\"\nWorking copy  (@) now at: kxwrsmmu eacafd73 (empty) Add a devShell\nParent commit (@-)      : ywyvxrts 986d16f5 main | test3\n```\n\nBeing more explicit about your commands ensures both you and jj know where\neverything should go. (i.e. `jj desc @ -m` explicitly describes `@`, the working\ncopy.) This will save you some headaches.\n\nOur new change, the Working copy is now built off of `main`. The working copy\nwill always be (`@`).\n\nMake some changes\n\n```bash\njj st\nWorking copy changes:\nA dev/flake.lock\nA dev/flake.nix\nWorking copy  (@) : kxwrsmmu 42b011cd Add a devShell\nParent commit (@-): ywyvxrts 986d16f5 main | test3\n```\n\nNow I'm done, and since we built this change on top of `main` the following\ncommand will tell jj we know what we want to push:\n\n```bash\njj bookmark set main\njj git push\n```\n\nIf you forget to move a bookmark, JJ will warn you and nothing will be pushed.\nThis is a safety feature, not a bug. That's what the `mb` alias does, moves the\nbookmark to the working copy.\n\n```nix\n# home-manager alias (move bookmark)\nmb = [\"bookmark\" \"set\" \"-r\" \"@\"];\n```\n\nIf you really have problems, `jj git push --change @` explicitly pushes the\nworking copy.\n\nThis is a bit different than Git and takes some getting used to but you don't\nneed to move the bookmark after every commit, just when you want to push. I know\nI've made the mistake of pushing to the wrong branch before this should prevent\nthat.\n\n## Here's an example of using JJ in an existing Git repo\n\nSay I have my configuration flake in the `~/flakes/` directory that is an\nexisting Git repository. To use JJ as the front-end I could do something like:\n\n```bash\ncd ~/flakes\njj git init --colocate\nDone importing changes from the underlying Git repo.\nSetting the revset alias `trunk()` to `main@origin`\nInitialized repo in \".\"\n```\n\n- By default, JJ defines `trunk()` as the main development branch of your remote\n  repository. This is usually set to `main@origin`, but could be named something\n  else. This means that whenever you use `trunk()` in JJ commands, it will\n  resolve to the latest commit on `main@origin`. This makes it easier to refer\n  to the main branch in scripts and commands without hardcoding the branch name.\n\n**Bookmarks** in jj are named pointers to specific revisions, similar to\nbranches in Git. When you first run `jj git init --colocate` in a git repo, you\nwill likely get a Hint saying \"Run the following command to keep local bookmarks\nupdated on future pulls\".:\n\n```bash\njj bookmark list\ntrack main@origin\n\njj st\nThe working copy has no changes.\nWorking copy  (@) : qzxomtxq 925eca75 (empty) (no description set)\nParent commit (@-): qnpnrklz bf291074 main | notes\n```\n\nThis shows that running `jj git init --colocate` automatically started tracking\n`main` in this case. If it doesn't, use `jj bookmark track main@origin`.\n\nI'll create a simple change in the `README.md`:\n\n```bash\njj st\nWorking copy changes:\nM README.md\nWorking copy  (@) : qzxomtxq b963dff0 (no description set)\nParent commit (@-): qnpnrklz bf291074 main | notes\n```\n\nWe can see that the working copy now contains a modified file `M README.md` and\nhas no description set. Lets give it a description before pushing to github.\n\n```bash\njj desc @ -m \"Added to README\"\njj bookmark set main -r @\nMoved 1 bookmarks to pxwnopqo 1e6e08a2 main* | Added to README\n```\n\n`jj bookmark set main -r @` moves the `main` bookmark to the current revision\n(the working copy), which is the explicit, recommended way to update bookmarks\nin JJ. Without this step, your bookmark will continue to point at the old\ncommit, not your latest work. This is a major difference from Git.\n\nAnd finally push to GitHub:\n\n```bash\njj git push\nChanges to push to origin:\n  Move forward bookmark main from bf291074125e to e2a75e45237b\nremote: Resolving deltas: 100% (1/1), completed with 1 local object.\nWarning: The working-copy commit in workspace 'default' became immutable, so a new commit has been created on top of it.\nWorking copy  (@) now at: pxwnopqo 8311444b (empty) (no description set)\nParent commit (@-)      : qzxomtxq e2a75e45 main | Added to README\n```\n\n---\n\n## Create a Repo without an existing Git Repo\n\n**Or** to do this in a directory that isn't already a git repo you can do\nsomething like:\n\n```bash\ncargo new hello-world --vcs=none\ncd hello-world\njj git init\nInitialized repo in \".\"\n```\n\n---\n\n### JJ and Git Side by Side\n\nOr for example, with Git if you wanted to move to a different branch before\nrunning `nix flake update` to see if it introduced errors before merging with\nyour main branch, you could do something like:\n\n```bash\ngit checkout -b update-test\n\nnix flake update\n\nsudo nixos-rebuild test --flake .\n```\n\nIf you're satisfied you can merge:\n\n```bash\ngit checkout main\ngit add . # Stage the change\ngit commit -m \"update\"\ngit merge update-test\ngit branch -D update-test\nsudo nixos-rebuild switch --flake .\n```\n\nWith JJ a similar workflow could be:\n\n1. Run `jj st` to see what you have:\n\n```bash\njj st\nThe working copy has no changes.\nWorking copy  (@) : ttkstzzn 3f55c42c (empty) (no description set)\nParent commit (@-): wppknozq e3558ef5 main@origin | jj diff\n```\n\nIf you don't have a description set for the working copy set it now.\n\n```bash\njj desc @ -m \"enable vim\"\njj st\nThe working copy has no changes.\nWorking copy  (@) : ttkstzzn 63fda123 (empty) enable vim\nParent commit (@-): wppknozq e3558ef5 main@origin | jj diff\n```\n\n2. Start from the working copy (which is mutable). The working copy in JJ is\n   itself a commit that you can edit and squash changes into. Since `main` is\n   immutable, you can create your new change by working on top of the working\n   copy commit.\n\nCreate a new change off of the working copy:\n\n```bash\njj new @\n```\n\n3. Make your edits:\n\n```bash\njj st\nWorking copy changes:\nM home/editors/vim.nix\nWorking copy  (@) : qrsxltmt 494b5f18 (no description set)\nParent commit (@-): wytnnnto a07e775c (empty) enable vim\n```\n\n4. Squash your changes into the new change:\n\n```bash\njj squash\nThe working copy has no changes.\nWorking copy  (@) : tmlwppnu ba06bb99 (empty) (no description set)\nParent commit (@-): wytnnnto 52928ed9 enable vim\n```\n\nThis moves your working copy changes into the new commit you just created.\n\n5. Describe the new change, this might feel weird but the `jj squash` command\n   created a new commit that you have to describe again:\n\n```bash\njj desc @ -m \"Enabled Vim\"\nWorking copy  (@) : tmlwppnu 5c1569c3 (empty) Enabled Vim\nParent commit (@-): wytnnnto 52928ed9 enable vim\n```\n\n6. Set the bookmark to the Parent commit that was squashed into:\n\n```bash\njj bookmark set wyt\n```\n\n7. Finally Push to the remote repository:\n\n```bash\njj git push --allow-new\nChanges to push to origin:\n  Add bookmark wyt to 5c1569c35b22\nremote: Resolving deltas: 100% (4/4), completed with 4 local objects.\nremote:\nremote: Create a pull request for 'wyt' on GitHub by visiting:\nremote:      https://github.com/sayls8/flake/pull/new/wyt\nremote:\n```\n\nThis command does the following:\n\n- Uploads your bookmark and the associated commit to the remote repository\n  (e.g., GitHub).\n\n- If the bookmark is new (not present on the remote), `--allow-new` tells JJ\n  it’s okay to create it remotely.\n\n- After pushing, GitHub (or your code host) will usually suggest creating a pull\n  request for your new branch/bookmark, allowing you or your collaborators to\n  review and merge the change into main.\n\n**Merging your Change into `main`**\n\nOption 1. Go to the URL suggested in the output, visit in this case:\n\n```bash\nhttps://github.com/sayls8/flake/pull/new/wyt\n```\n\n- Click Create PR\n\n- Click Merge PR if it shows it can merge cleanly.\n\nOption 2.\n\n1. Switch to `main` (if not already there):\n\n```bash\njj bookmark set main\n```\n\n2. Create a new change that combines the new change with `main`:\n\n```bash\njj new tml wyt -m \"Merge: enable vim\"\n```\n\nThis creates a new commit with both `tml` and `wyt` as parents, which is how JJ\nhandles merges (since `jj merge` depreciated). JJ merges are additive and\nhistory-preserving by design especially for folks used to Git's fast-forward and\nsquash options.\n\n---\n\n### Summary\n\n- With `jj` you're creating a new commit rather than a new branch.\n\n- Amending vs. Squashing: Git's `git commit --amend` updates the last commit.\n  `jj squash` combines the current commit with its parent, effectively doing the\n  same thing in terms of history.\n\n- Merging: Git's merge command is explicit. In `jj`, the concept is similar, but\n  since there's no branch, you're \"merging\" by moving your working commit to\n  include these changes.\n\n- No need to delete branches: Since there are no branches in `jj`, there's no\n  equivalent to `git branch -D` to clean up. Instead commits that are no longer\n  needed can be \"abandoned\" with `jj abandon` if you want to clean up your\n  commit graph.\n\n- `jj describe` without a flag just opens `$EDITOR` where you can write your\n  commit message save and exit.\n\n- In `git`, we finish a set of changes to our code by committing, but in `jj` we\n  start new work by creating a change, and _then_ make changes to our code. It's\n  more useful to write an initial description of your intended changes, and then\n  refine it as you work, than it is creating a commit message after the fact.\n\n- I have heard that jj can struggle with big repositories such as Nixpkgs and\n  have noticed some issues here and there when using with NixOS. I'm hoping that\n  as the project matures, it gets better on this front.\n\n---\n\n## The 2 main JJ Workflows\n\n### The Squash Workflow\n\nThis workflow is the most similar to Git and Git's index.\n\nThe workflow:\n\n1. Describe the work we want to do with `jj desc -m \"message\"`\n\n2. We create a new empty change on top of that one with `jj new`\n\n3. When we are done with a feature, we run `jj squash` to move the changes from\n   `@` into the change we described in step 1. `@` is where your working copy is\n   positioned currently.\n\nFor example, let's say we just ran `jj git init --colocate` in our configuration\nFlake directory making it a `jj` repo as well using git for backend.\n\n```bash\ncd flake\njj git init --colocate\njj log\n@  lnmmxwko sayls8@proton.me 2025-06-27 10:14:57 1eac6aa0\n│  (empty) (no description set)\n○  qnknltto sayls8@proton.me 2025-06-27 09:04:08 git_head() 5358483a\n│  (empty) jj\n```\n\nThe above log output shows that running `jj git init` creates an empty working\ncommit (`@`) on top of the `git_head()`\n\n```bash\njj desc -m \"Switch from nixVim to NVF\"\njj new  # Create a new empty change\njj log\n@  nmnmznmm sayls8@proton.me 2025-06-27 10:16:30 52dd7ee0\n│  (empty) (no description set)\n○  lnmmxwko sayls8@proton.me 2025-06-27 10:16:24 git_head() 3e8f9f3a\n│  (empty) Switch from nixVim to NVF\n○  qnknltto sayls8@proton.me 2025-06-27 09:04:08 5358483a\n│  (empty) jj\n```\n\nThe above log shows that running `jj desc` changes the current (`@`) commits\ndescription, and then `jj new` creates a new empty commit on top of it, moving\n(`@`) to this new empty commit.\n\nThe \"Switch from nixVim to NVF\" commit is now the parent of (`@`).\n\nNow, we'd make the necessary changes and to add them to the commit we just\ndescribed in the previous steps.\n\nThe changes are automatically \"staged\" so theres no need to `git add` them, so\nwe just make the changes and squash them.\n\n```bash\njj squash  # Squash the commit into its parent commit (i.e., our named commit)\njj log\n@  zsxsolsq sayls8@proton.me 2025-06-27 10:18:01 2c35d83f\n│  (empty) (no description set)\n○  lnmmxwko sayls8@proton.me 2025-06-27 10:18:01 git_head() 485eaee9\n│  (empty) Switch from nixVim to NVF\n```\n\nThis shows `jj squashes` effect, it merges the changes from the current (`@`)\ncommit into its parent. The (`@`) then moves to this modified parent, and a new\nempty commit is created on top, ready for the next set of changes.\n\n```bash\nsudo nixos-rebuild switch --flake .\n```\n\nWe're still in the nameless commit and can either continue working or run\n`jj desc -m \"\"` again describing our new change, then `jj new` and `jj squash`\nit's pretty simple. The nameless commit is used as an adhoc staging area.\n\nWhen you are ready to push, it's important to know where your working copy\ncurrently is and if it's attached to a bookmark. It's common for `jj new` to\ndetach the head, all you have to do is tell JJ which branch to attach to, then\npush:\n\n```bash\njj st\nWorking copy changes:\nM hosts/magic/configuration.nix\nM hosts/magic/container.nix\nWorking copy  (@) : youptvvn 988e6fc9 (no description set)\nParent commit (@-): qlwqromx 4bb754fa mdbook container\n```\n\nThe above output means that the working copy has modifications (`M`) in two\nfiles. And these changes are not yet committed.\n\n```bash\njj bookmark set main\njj git push\n```\n\n---\n\n### The Edit Workflow\n\nThis workflow adds a few new commands `jj edit`, and `jj next`.\n\nHere's the workflow:\n\n1. Create a new change to work on the new feature with `jj new`\n\n2. If everything works exactly as planned, we're done.\n\n3. If we realize we want to break this big change up into multiple smaller ones,\n   we do it by making a new change before the current one, swapping to it, and\n   making the necessary change.\n\n4. Lastly, we go back to the main change.\n\nThe squash workflow leaves `@` at an empty undescribed change, with this\nworkflow, `@` will often be on the existing change.\n\nIf `@` wasn't at an empty change, we would start this workflow with:\n\n```bash\njj new -m \"Switch from NVF to nixVim\"\n```\n\nsince our `@` is already at an empty change, we'll just describe it and get\nstarted:\n\nFor this example, lets say we want to revert back to nixVim:\n\n```bash\njj desc -m \"Switch from NVF to nixVim\"\njj log\n@  zsxsolsq sayls8@proton.me 2025-06-27 10:18:47 606abaa7\n│  (empty) Switch from NVF to nixVim\n○  lnmmxwko sayls8@proton.me 2025-06-27 10:18:01 git_head() 485eaee9\n│  (empty) Switch from nixVim to NVF\n○  qnknltto sayls8@proton.me 2025-06-27 09:04:08 5358483a\n│  (empty) jj\n```\n\nAgain, this shows `jj desc` renaming the current empty `@` commit.\n\nWe make the changes, and it's pretty straightforward so we're done, every change\nis automatically staged so we can just run `sudo nixos-rebuild switch --flake .`\nnow to apply the changes.\n\nIf we wanted to make more changes that aren't described we can use `jj new -B`\nwhich is similar to `git add -a`.\n\n```bash\njj new -B @ -m \"Adding LSP to nixVim\"\nRebased 1 descendant commits\nWorking copy  (@) now at: lpnxxxpo bf929946 (empty) Adding LSP to nixVim\nParent commit (@-)      : lnmmxwko 485eaee9 (empty) Switch from nixVim to NVF\n```\n\nThe `-B` tells jj to create the new change _before_ the current one and it\ncreates a rebase. We created a change before the one we're on, it automatically\nrebased our original change. This operation will _always_ succeed with jj, we\nwill have our working copy at the commit we've just inserted.\n\nYou can see below that `@` moved down one commit:\n\n```bash\njj log\n○  zsxsolsq sayls8@proton.me 2025-06-27 10:22:03 ad0713b6\n│  (empty) Switch from NVF to nixVim\n@  lpnxxxpo sayls8@proton.me 2025-06-27 10:22:03 bf929946\n│  (empty) Adding LSP to nixVim\n○  lnmmxwko sayls8@proton.me 2025-06-27 10:18:01 git_head() 485eaee9\n│  (empty) Switch from nixVim to NVF\n○  qnknltto sayls8@proton.me 2025-06-27 09:04:08 5358483a\n│  (empty) jj\n○  qnknltto sayls8@proton.me 2025-06-27 09:04:08 git_head()\n```\n\nThe \"Adding LSP to nixVim\" commit is directly above \"Switch from nixVim to NVF\"\n(the old `git_head()`)\n\nThe \"Switch from NVF to nixVim\" commit (which was your `@` before `jj new -B`)\nis now above \"Adding LSP to nixVim\" in the log output, meaning \"Adding LSP to\nnixVim\" is its new parent.\n\n`@` has moved to \"Adding LSP to nixVim\"\n\n`jj log` example output\n\n---\n\n## Operation Log and Undo\n\nJJ records every operation (commits, merges, rebases, etc.) in an operation log.\nYou can view and undo previous operations, making it easy to recover from\nmistakes, a feature not present in Git’s core CLI\n\n```bash\njj op log\n@  fbf6e626df22 jr@magic 15 minutes ago, lasted 9 milliseconds\n│  new empty commit\n│  args: jj new -B @ -m 'Adding LSP to nixVim'\n○  bde40b7c17cf jr@magic 19 minutes ago, lasted 8 milliseconds\n│  describe commit 2c35d83f75031dc582bf28b64d4af1c218177f90\n│  args: jj desc -m 'Switch from NVF to nixVim'\n○  3a2bfe1c0b0a jr@magic 19 minutes ago, lasted 8 milliseconds\n│  squash commits into 3e8f9f3a6a58fef86906e16e9b4375afb43e73e3\n│  args: jj squash\n○  80abcb58dcb6 jr@magic 21 minutes ago, lasted 8 milliseconds\n│  new empty commit\n│  args: jj new\n○  8c80314cbcd7 jr@magic 21 minutes ago, lasted 8 milliseconds\n│  describe commit 1eac6aa0b88ba014785ee9c1c2ad6e2abc6206e9\n│  args: jj desc -m 'Switch from nixVim to NVF'\n○  44b5789cb4d1 jr@magic 22 minutes ago, lasted 6 milliseconds\n│  track remote bookmark main@origin\n│  args: jj bookmark track main@origin\n○  dbefee04aa85 jr@magic 23 minutes ago, lasted 4 milliseconds\n│  import git head\n│  args: jj git init --git-repo .\n```\n\n```bash\njj op undo <operation-id>\n# or\njj op restore <operation-id>\n```\n\n---\n\n## Conflict Resolution\n\nIn JJ, conflicts live inside commits and can be resolved at any time, not just\nduring a merge. This makes rebasing and history editing safer and more flexible\n\nJJ treats conflicts as first-class citizens: conflicts can exist inside commits,\nnot just in the working directory. This means if a merge or rebase introduces a\nconflict, the conflicted state is saved in the commit itself, and you can\nresolve it at any time there’s no need to resolve conflicts immediately or use\n“`--continue`” commands as in Git\n\nHere's how it works:\n\nWhen you check out or create a commit with conflicts, JJ materializes the\nconflicts as markers in your files (similar to Git's conflict markers)\n\nYou can resolve conflicts by editing the files to remove the markers, or by\nusing:\n\n```bash\njj resolve\n```\n\n---\n\n## Revsets\n\n[Jujutsu Revsets](https://jj-vcs.github.io/jj/latest/revsets/)\n\nJJ includes a powerful query language for selecting commits. For example:\n\n```bash\njj log -r \"author(alice) & file(*.py)\"\n```\n\nThis command lists all commits by Alice that touch Python files.\n\n## Filesets\n\n[Jujutsu Filesets](https://jj-vcs.github.io/jj/latest/filesets/)\n\nJujutsu supports a functional language for selecting a set of files. Expressions\nin this language are called \"filesets\" (the idea comes from Mercurial). The\nlanguage consists of file patterns, operators, and functions. --JJ Docs\n\n## Summary\n\nJujutsu (jj) offers a streamlined, branchless, and undo-friendly approach to\nversion control, fully compatible with Git but designed to be easier to use and\nreason about. Its workflows, operation log, and conflict handling provide a\nsafer and more flexible environment for managing code changes, making it a\ncompelling alternative for both new and experienced developers.\n\n---\n\n### Resources\n\n- [steves_jj_tutorial](https://steveklabnik.github.io/jujutsu-tutorial/)\n\n- [jj_github](https://github.com/jj-vcs/jj)\n\n- [official_tutorial](https://jj-vcs.github.io/jj/latest/tutorial/)\n\n- [jj_init](https://v5.chriskrycho.com/essays/jj-init/)\n","number":[1,5],"sub_items":[],"path":"vcs/jujutsu.md","source_path":"vcs/jujutsu.md","parent_names":["Getting Started with the Nix Ecosystem"]}}],"path":"Getting_Started_with_Nix_1.md","source_path":"Getting_Started_with_Nix_1.md","parent_names":[]}},{"Chapter":{"name":"Installation","content":"# Installation Guides\n\nThis section provides detailed guides for installing NixOS. You'll choose\nbetween an **unencrypted** or **encrypted** base setup. After your core\ninstallation, you can explore adding optional features like `sops` for encrypted\nsecrets, `lanzaboote` for Secure Boot, or `impermanence` for a stateless system.\n\n---\n\n## 1. Unencrypted Disko Btrfs Subvol Installation\n\n- **Guide:**\n  [Minimal Btrfs-Subvol Install with Disko and Flakes](https://saylesss88.github.io/installation/unencrypted/unencrypted.html)\n\n- **Best for:**\n\n  - Users who want a straightforward and quick setup.\n\n  - [Unencrypted Impermanence](https://saylesss88.github.io/installation/unencrypted/impermanence.html)\n\n  - You can still add Lanzaboote and sops secrets after the install for a more\n    secure system. To get the full benefits of Lanzaboote it is recommended to\n    use full disk encryption.\n\n---\n\n## 2. Encrypted Disko Btrfs Subvol Installation\n\n- **Encrypted Install Guide:**\n  [Encrypted Install](https://saylesss88.github.io/installation/enc/enc_install.html)\n\n- [Encrypted Impermanence](https://saylesss88.github.io/installation/enc/encrypted_impermanence.html)\n\n- **Important Considerations:**\n\n  - [Secure Boot with Lanzaboote](https://saylesss88.github.io/enc/lanzaboote.html)\n    For the full benefit of Secure Boot (with Lanzaboote), it's highly\n    recommended to have a second stage of protection, such as an encrypted disk.\n\n  - [Adding Sops](https://saylesss88.github.io/enc/sops-nix.html) You can easily\n    add `sops` (for managing encrypted secrets) to your configuration _after_\n    the initial encrypted installation and reboot. This can simplify the initial\n    setup process. However, always remember the core goal of using encrypted\n    secrets: **never commit unencrypted or even hashed sensitive data directly\n    into your Git repository.** With modern equipment brute force attacks are a\n    real threat.\n\n---\n\n## 3. Post-Installation Security & Features\n\nOnce your base NixOS system is installed, consider these powerful additions:\n\n- **`sops-nix`:** For managing encrypted secrets directly within your NixOS\n  configuration, ensuring sensitive data is never stored in plain text.\n\n- **`lanzaboote`:** For enabling Secure Boot, verifying the integrity of your\n  boot chain (requires UEFI and custom keys).\n\n- **`impermanence`:** For setting up a stateless NixOS system, where the root\n  filesystem reverts to a clean state on every reboot.\n","number":[2],"sub_items":[{"Chapter":{"name":"Unencrypted Setups","content":"# Unencrypted Setups\n\n# Minimal BTRFS-Subvol Install with Disko and Flakes\n\n<details>\n<summary> ✔️ Click to Expand Table of Contents</summary>\n\n<!-- toc -->\n\n</details>\n\nFigure 1: **BTRFS Logo**: Image of the BTRFS logo. Sourced from the\n[BTRFS repo](https://github.com/btrfs) ![BTRFS logo](../../images/btrfs1.png)\n\n## Why I Chose BTRFS\n\nI chose BTRFS because I was already familiar with it from using it with Arch\nLinux and I found it to be very easy to use. From what I've read, there are\nlicensing issues between the Linux Kernel and ZFS which means that ZFS is not\npart of the Linux Kernel; it's maintained by the OpenZFS project and available\nas a separate kernel module. This can cause issues and make you think more about\nyour filesystem than I personally want to at this point.\n\n<details>\n<summary> ✔️ Click for BTRFS Subvolume Overview </summary>\n\nA **Btrfs subvolume** is essentially a distinct section within a Btrfs\nfilesystem that maintains its own set of files and directories, along with a\nseparate inode numbering system. Unlike block-level partitions (such as LVM\nlogical volumes), Btrfs subvolumes operate at the file level and are based on\nfile extents.\n\n**Extents** in Btrfs are contiguous blocks of data on disk that store the actual\ncontents of files. When files are created or modified, Btrfs manages these\nextents efficiently, allowing features like deduplication and snapshots.\nMultiple subvolumes can reference the same extents, meaning that identical data\nis not duplicated on disk, which saves space and improves performance.\n\nA **snapshot** in Btrfs is a special kind of subvolume that starts with the same\ncontent as another subvolume at the time the snapshot is taken. Snapshots are\ntypically writable by default, so you can make changes in the snapshot without\naffecting the original subvolume. This is possible because Btrfs tracks changes\nat the extent level, only creating new extents when files are modified (a\ntechnique called copy-on-write).\n\nSubvolumes in Btrfs behave much like regular directories from a user’s\nperspective, but they support additional operations such as renaming, moving,\nand nesting (placing subvolumes within other subvolumes). There are no\nrestrictions on nesting, though it can affect how snapshots are created and\nmanaged. Each subvolume is assigned a unique and unchangeable numeric ID\n(subvolid or rootid).\n\nYou can access a Btrfs subvolume in two main ways:\n\n- As a normal directory within the filesystem.\n\n- By mounting it directly as if it were a separate filesystem, using the subvol\n  or subvolid mount options. When mounted this way, you only see the contents of\n  that subvolume, similar to how a bind mount works.\n\nWhen a new Btrfs filesystem is created, it starts with a \"top-level\" subvolume\n(with an internal ID of 5). This subvolume is always present and cannot be\ndeleted or replaced, and it is the default mount point unless changed with btrfs\nsubvolume set-default.\n\nSubvolumes can also have storage quotas set using Btrfs’s quota groups , but\notherwise, they all draw from the same underlying storage pool. Thanks to\nfeatures like deduplication and snapshots, subvolumes can share data efficiently\nat the extent level.While ZFS is a solid choice and offers some benefits over\nBTRFS, I recommend looking into it before making your own decision.\n\n</details>\n\nIf you have a ton of RAM you could most likely skip the minimal install and just\nset your system up as needed or just use\n[tmpfs as root](https://elis.nu/blog/2020/05/nixos-tmpfs-as-root/)\n\n## Getting Started with Disko\n\nDisko allows you to declaratively partition and format your disks, and then\nmount them to your system. I recommend checking out the\n[README](https://github.com/nix-community/disko/tree/master?tab=readme-ov-file)\nas it is a **disk destroyer** if used incorrectly.\n\nWe will mainly be following the\n[disko quickstart guide](https://github.com/nix-community/disko/blob/master/docs/quickstart.md)\n\nFigure 2: **Disko Logo**: Image of the logo for Disko, the NixOS declarative\ndisk partitioning tool. Sourced from the\n[Disko project](https://github.com/nix-community/disko)\n![disko logo](../images/disko1.png)\n\n1. Get the\n   [Nixos Minimal ISO](https://channels.nixos.org/nixos-25.05/latest-nixos-minimal-x86_64-linux.iso)\n   Get it on a usb stick, I use Ventoy with Ventoy2Disk.sh. The following is the\n   link to the\n   [Ventoy TarBall](https://sourceforge.net/projects/ventoy/files/v1.1.05/ventoy-1.1.05-linux.tar.gz/download)\n   download, untar it with `tar -xzf ventoy-1.1.05-linux.tar.gz`, and make it\n   executable with `chmod +x Ventoy2Disk.sh`, and finally execute it with\n   `sudo ./Ventoy2Disk.sh` Follow the prompts to finish the install.\n\nYou'll have to run it on for the USB drive you're trying to use, you can do that\nby unplugging the USB stick and running `lsblk`, then plug it in again and run:\n\n```bash\nlsblk -f\nNAME          FSTYPE      FSVER LABEL   UUID                                 FSAVAIL FSUSE% MOUNTPOINTS\nsda\n└─sda1        vfat        FAT32 MYUSB   46E8-9304\nsdb           vfat        FAT12         F054-697D                               1.4M     0% /run/media/jr/F054-697D\nnvme0n1\n├─nvme0n1p1   vfat        FAT32         BCD8-8C51                               1.8G    12% /boot\n```\n\n- `sdb` is a USB plugin for a mouse. `sda` is the USB stick that I want to\n  target here:\n\n```bash\nsudo ./Ventoy2Disk.sh -i /dev/sda\n# Or to force overwrite an existing Ventoy entry\nsudo ./Ventoy2Disk.sh -I /dev/sda\n```\n\n2. The minimal installer uses `wpa_supplicant` instead of NetworkManager, to\n   enable networking run the following:\n\n```bash\nsudo systemctl start wpa_supplicant\nwpa_cli\n```\n\n```bash\n> add_network\n0\n\n> set_network 0 ssid \"myhomenetwork\"\nOK\n\n> set_network 0 psk \"mypassword\"\nOK\n\n> enable_network 0\nOK\n```\n\nTo exit type `quit`, then check your connection with `ping google.com`.\n\nAnother option is to do the following, so either the above method or the below\nmethod after starting `wpa_supplicant`:\n\n```bash\n# Alternative for quick setup (less interactive, but often faster)\nsudo wpa_passphrase \"myhomenetwork\" \"mypassword\" >> /etc/wpa_supplicant/wpa_supplicant-wlan0.conf\nsudo systemctl restart wpa_supplicant@wlan0.service\n```\n\n3. Get your Disk Name with `lsblk`\n\nThe output should be something like:\n\n```bash\nNAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS\nnvme0n1     259:0    0   1,8T  0 disk\n```\n\n4. Copy the disk configuration to your machine. You can choose one from the\n   [examples directory](https://github.com/nix-community/disko/tree/master/example).\n\n- **Option A**: (Simpler for new users) I also created a starter repo containing\n  much of what's needed. If you choose this option follow the `README.md`\n  included with the repo.\n\n```bash\ncd ~\ngit clone https://github.com/saylesss88/my-flake.git\n```\n\n> Make sure to change line 7 in `disk-config.nix` to what you got from step 3\n> `device = \"/dev/nvme0n1\";`\n\n- **Option B**: (More flexible, more manual steps) Skip cloning the repo above\n  and for the btrfs-subvolume default layout, run the following:\n\n```bash\ncd /tmp\ncurl https://raw.githubusercontent.com/nix-community/disko/refs/heads/master/example/btrfs-subvolumes.nix -o /tmp/disk-config.nix\n```\n\n5. Make Necessary changes, I set mine up for impermanence with the following:\n\n```bash\nnano /tmp/disk-config.nix\n```\n\n```nix\n{\n  disko.devices = {\n    disk = {\n      main = {\n        type = \"disk\";\n        device = \"/dev/nvme0n1\";\n        content = {\n          type = \"gpt\";\n          partitions = {\n            ESP = {\n              priority = 1;\n              name = \"ESP\";\n              start = \"1M\";\n              end = \"512M\";\n              type = \"EF00\";\n              content = {\n                type = \"filesystem\";\n                format = \"vfat\";\n                mountpoint = \"/boot\";\n                mountOptions = [\"umask=0077\"];\n              };\n            };\n            root = {\n              size = \"100%\";\n              content = {\n                type = \"btrfs\";\n                extraArgs = [\"-f\"]; # Override existing partition\n                # Subvolumes must set a mountpoint in order to be mounted,\n                # unless their parent is mounted\n                subvolumes = {\n                  # Subvolume name is different from mountpoint\n                  \"/root\" = {\n                    mountpoint = \"/\";\n                    mountOptions = [\"subvol=root\" \"compress=zstd\" \"noatime\"];\n                  };\n                  # Subvolume name is the same as the mountpoint\n                  \"/home\" = {\n                    mountOptions = [\"subvol=home\" \"compress=zstd\" \"noatime\"];\n                    mountpoint = \"/home\";\n                  };\n                  # Sub(sub)volume doesn't need a mountpoint as its parent is mounted\n                  \"/home/user\" = {};\n                  # Parent is not mounted so the mountpoint must be set\n                  \"/nix\" = {\n                    mountOptions = [\n                      \"subvol=nix\"\n                      \"compress=zstd\"\n                      \"noatime\"\n                    ];\n                    mountpoint = \"/nix\";\n                  };\n                  \"/nix/persist\" = {\n                    mountpoint = \"/nix/persist\";\n                    mountOptions = [\"subvol=persist\" \"compress=zstd\" \"noatime\"];\n                  };\n                  \"/log\" = {\n                    mountpoint = \"/var/log\";\n                    mountOptions = [\"subvol=log\" \"compress=zstd\" \"noatime\"];\n                  };\n                  \"/lib\" = {\n                    mountpoint = \"/var/lib\";\n                    mountOptions = [\"subvol=lib\" \"compress=zstd\" \"noatime\"];\n                  };\n                  # This subvolume will be created but not mounted\n                  \"/test\" = {};\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n  fileSystems.\"/nix/persist\".neededForBoot = true;\n  fileSystems.\"/var/log\".neededForBoot = true;\n  fileSystems.\"/var/lib\".neededForBoot = true;\n}\n```\n\n- For `/tmp` on RAM use something like the following. I've found that having\n  disko manage swaps causes unnecessary issues. Using zram follows the ephemeral\n  route:\n\n> ```nix\n> {\n>   lib,\n>   config,\n>   ...\n> }: let\n>   cfg = config.custom.zram;\n> in {\n>   options.custom.zram = {\n>     enable = lib.mkEnableOption \"Enable utils module\";\n>   };\n>\n>   config = lib.mkIf cfg.enable {\n>     zramSwap = {\n>       enable = true;\n>       # one of \"lzo\", \"lz4\", \"zstd\"\n>       algorithm = \"zstd\";\n>        priority = 5;\n>        memoryPercent = 50;\n>     };\n>   };\n> }\n> ```\n>\n> And in your `configuration.nix` you would add:\n>\n> ```nix\n> # configuration.nix\n> custom = {\n>     zram.enable = true;\n> };\n> ```\n\nAfter adding the above module, you can see it with:\n\n```bash\nswapon --show\nNAME       TYPE      SIZE USED PRIO\n/dev/zram0 partition 7.5G   0B    5\n```\n\n6.  Run disko to partition, format and mount your disks. **Warning** this will\n    wipe **EVERYTHING** on your disk. Disko doesn't work with dual boot.\n\n```bash\nsudo nix --experimental-features \"nix-command flakes\" run github:nix-community/disko/latest -- --mode destroy,format,mount /tmp/disk-config.nix\n```\n\nCheck it with the following:\n\n```bash\nmount | grep /mnt\n```\n\nThe output for an `nvme0n1` disk would be similar to the following:\n\n```bash\n#... snip ...\n/dev/nvme0n1p2 on /mnt type btrfs (rw,noatime,compress=zstd:3,ssd,discard=async,space_cache=v2,subvolid=285,subvol=/root)\n/dev/nvme0n1p2 on /mnt/persist type btrfs (rw,noatime,compress=zstd:3,ssd,discard=async,space_cache=v2,subvolid=261,subvol=/persist)\n/dev/nvme0n1p2 on /mnt/etc type btrfs (rw,noatime,compress=zstd:3,ssd,discard=async,space_cache=v2,subvolid=261,subvol=/persist)\n/dev/nvme0n1p2 on /mnt/nix type btrfs (rw,noatime,compress=zstd:3,ssd,discard=async,space_cache=v2,subvolid=260,subvol=/nix)\n/dev/nvme0n1p2 on /mnt/var/lib type btrfs (rw,noatime,compress=zstd:3,ssd,discard=async,space_cache=v2,subvolid=258,subvol=/lib)\n/dev/nvme0n1p2 on /mnt/var/log type btrfs (rw,noatime,compress=zstd:3,ssd,discard=async,space_cache=v2,subvolid=259,subvol=/log)\n/dev/nvme0n1p2 on /mnt/nix/store type btrfs (ro,noatime,compress=zstd:3,ssd,discard=async,space_cache=v2,subvolid=260,subvol=/nix)\n# ... snip ...\n```\n\n7. Generate necessary files, here we use `--no-filesystems` because disko\n   handles the `fileSystems` attribute for us.\n\n```bash\nnixos-generate-config --no-filesystems --root /mnt\n```\n\nIt may be helpful to add a couple things to your `configuration.nix` now,\nrebuild and then move on. Such as, your hostname, git, an editor of your choice.\nAfter your additions run `sudo nixos-rebuild switch` to apply the changes. If\nyou do this, you can skip the `nix-shell -p` command coming up.\n\n```bash\nsudo mv /tmp/disk-config.nix /mnt/etc/nixos\n```\n\n### Setting a Flake for your minimal Install\n\n8. Create the flake in your home directory, then move it to `/mnt/etc/nixos`.\n   This avoids needing to use `sudo` for every command while in the\n   `/mnt/etc/nixos` directory.\n\n```bash\ncd ~\nmkdir flake && cd flake\nnix-shell -p git yazi helix\nexport NIX_CONFIG='experimental-features = nix-command flakes'\nexport EDITOR='hx'\nhx flake.nix\n```\n\n> You'll change `hostname = nixpkgs.lib.nixosSystem` to your chosen hostname,\n> (e.g. `magic = nixpkgs.lib.nixosSystem`). This will be the same as your\n> `networking.hostName = \"magic\";` in your `configuration.nix` that we will set\n> up shortly.\n\n```nix\n# flake.nix\n{\n  description = \"NixOS configuration\";\n\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n    disko.url = \"github:nix-community/disko/latest\";\n    disko.inputs.nixpkgs.follows = \"nixpkgs\";\n    # impermanence.url = \"github:nix-community/impermanence\";\n  };\n\n  outputs = inputs@{ nixpkgs, ... }: {\n    nixosConfigurations = {\n      # Change `my-hostname` to match `networking.hostName`\n      my-hostname = nixpkgs.lib.nixosSystem {\n        system = \"x86_64-linux\";\n        modules = [\n          ./configuration.nix\n          inputs.disko.nixosModules.disko\n          # inputs.impermanence.nixosModules.impermanence\n        ];\n      };\n    };\n  };\n}\n```\n\nMove all the files into your flake:\n\n```bash\ncd /mnt/etc/nixos/\nsudo mv disk-config.nix hardware-configuration.nix configuration.nix ~/flake\n```\n\n9. Edit `configuration.nix` with what is required, the following is required, I\n   clone my original flake repo and move the pieces into place but it's fairly\n   easy to just type it all out:\n\n- Bootloader, (e.g., `boot.loader.systemd-boot.enable = true;`)\n\n- User, the example uses `username` change this to your chosen username. If you\n  don't set your hostname it will be `nixos`.\n\n- Networking, `networking.networkmanager.enable = true;`\n\n- `hardware-configuration.nix` & `disk-config.nix` for this setup\n\n- `initialHashedPassword`: Run `mkpasswd --method=yescrypt`, then enter your\n  desired password. Example output,\n\n```bash\nmkpasswd --method=yescrypt > /tmp/pass.txt\n```\n\n- You can check the quality with `pwscore`:\n\n```bash\nnix-shell -p libpwquality\n\npwscore\nvery-secure-password\n100\n```\n\nread the hashed password into the file with `:r /tmp/pass.txt` and move it into\nplace.\n\n```nix\n# configuration.nix\n{\n  config,\n  lib,\n  pkgs,\n  inputs,\n  ...\n}: {\n  imports = [\n    # Include the results of the hardware scan.\n    ./hardware-configuration.nix\n    ./disk-config.nix\n  ];\n\n  networking.hostName = \"my-hostname\"; # This will match the `hostname` of your flake\n\n  networking.networkmanager.enable = true;\n\n  boot.loader.systemd-boot.enable = true; # (for UEFI systems only)\n  # List packages installed in system profile.\n  # You can use https://search.nixos.org/ to find more packages (and options).\n  environment.systemPackages = with pkgs; [\n    vim # Do not forget to add an editor to edit configuration.nix! The Nano editor is also installed by default.\n    #   wget\n    git\n  ];\n\n  time.timeZone = \"America/New_York\";\n\n# Change `nixos` to your chosen username, change the group to match\n  users.users.nixos = {\n    isNormalUser = true;\n    extraGroups = [ \"wheel\" \"networkmanager\" ]; # Add \"wheel\" for sudo access\n    initialHashedPassword = \"COPY_YOUR_MKPASSWD_OUTPUT_HERE\"; # <-- This is where it goes!\n    # home = \"/home/nixos\"; # Optional: Disko typically handles home subvolumes\n  };\n  # Create a matching group\n  users.groups.nixos = {};\n\n  console.keyMap = \"us\";\n\n  nixpkgs.config.allowUnfree = true;\n\n  system.stateVersion = \"25.05\";\n}\n```\n\nShred `pass.txt`:\n\n```bash\nshred /tmp/pass.txt\nrm /tmp/pass.txt\n```\n\n10. Move the flake to `/mnt/etc/nixos` and run `nixos-install`:\n\n```bash\nsudo mv ~/flake /mnt/etc/nixos/\nsudo nixos-install --flake /mnt/etc/nixos/flake .#hostname\n# if the above command doesn't work try this:\nsudo nixos-install --flake /mnt/etc/nixos/flake#hostname\n```\n\n- You will be prompted to enter a new password if everything succeeds.\n\n- If everything checks out, reboot the system and you should be prompted to\n  enter your `user` and `password` to login to a shell to get started.\n\n- The flake will be placed at `/etc/nixos/flake`, I choose to move it to my home\n  directory. Since the file was first in `/etc` you'll need to adjust the\n  permissions with something like `sudo chown nixos:nixos ~/flake`. This is\n  based off of the example above where we created both a `nixos` user and group.\n\n- You can check the layout of your btrfs system with:\n\n```bash\nsudo btrfs subvolume list /\n```\n\n- You may notice some `old_roots` in the output, which are snapshots, which are\n  likely created before system upgrades or reboots for rollback purposes. They\n  can be deleted or rolled back as needed.\n\n- [BTRFS Subvolumes](https://btrfs.readthedocs.io/en/latest/Subvolumes.html)\n\n- To continue following along and set up impermanence\n  [Click Here](https://saylesss88.github.io/installation/unencrypted/impermanence.html)\n","number":[2,1],"sub_items":[],"path":"installation/unencrypted/unencrypted.md","source_path":"installation/unencrypted/unencrypted.md","parent_names":["Installation"]}},{"Chapter":{"name":"Unencrypted Impermanence","content":"# Unencrypted BTRFS Impermanence with Flakes\n\n<details>\n<summary> ✔️ Click to Expand Table of Contents</summary>\n\n<!-- toc -->\n\n</details>\n\nFigure 1: **Impermanence Logo**: Image of the Impermanence logo. Sourced from\nthe\n\n[Impermanence repo](https://github.com/nix-community/impermanence)\n\n![Impermanence Logo](../../images/Impermanence.png)\n\nThis guide is for an unencrypted setup, there are a few links at the end for\nencrypted setups. This guide follows the previous\n[minimal install guide](https://saylesss88.github.io/nix/impermanence.html) but\nyou should be able to adjust it carefully to meet your needs.\n\nThis section details how to set up impermanence on your NixOS system using BTRFS\nsubvolumes. With impermanence, your operating system's root filesystem will\nreset to a pristine state on each reboot, while designated directories and files\nremain persistent. This provides a highly reliable and rollback-friendly system.\n\nIn NixOS, \"state\" is any data or condition of the system that isn't defined in\nyour declarative configuration. The impermanence approach aims to make this\nstate temporary (ephemeral) or easily resettable, so your system always matches\nyour configuration and can recover from unwanted changes or corruption.\n\n## Impermanence: The Concept and Its BTRFS Implementation\n\nIn a traditional Linux system, most of this state is stored on the disk and\npersists indefinitely unless manually deleted or modified. However, this can\nlead to configuration drift, where the system accumulates changes (e.g., log\nfiles, temporary files, or unintended configuration tweaks) that make it harder\nto reproduce or maintain.\n\nImpermanence, in the context of operating systems, refers to a setup where the\nmajority of the system's root filesystem (`/`) is reset to a pristine state on\nevery reboot. This means any changes made to the system (e.g., installing new\npackages, modifying system files outside of configuration management, creating\ntemporary files) are discarded upon shutdown or reboot.\n\n### What Does Impermanence Do?\n\nImpermanence is a NixOS approach that makes the system stateless (or nearly\nstateless) by wiping the root filesystem (`/`) on each boot, ensuring a clean,\npredictable starting point. Only explicitly designated data (persistent state)\nis preserved across reboots, typically stored in specific locations like the\n`/nix/persist` subvolume. This is possible because NixOS can boot with only the\n`/boot`, and `/nix` directories. This achieves:\n\n1. Clean Root Filesystem:\n\n- The root subvolume is deleted and recreated on each boot, erasing transient\n  state (e.g., temporary files, runtime data).\n\n- This ensures the system starts fresh, reducing clutter and making it behave\n  closer to a declarative system defined by your NixOS configuration.\n\n2. Selective Persistence:\n\n- Critical state (e.g., user files, logs, system configuration) is preserved in\n  designated persistent subvolumes (e.g., `/nix/persist`, `/var/log`,\n  `/var/lib`) or files.\n\n- You control exactly what state persists by configuring\n  `environment.persistence.\"/nix/persist\"` or other mechanisms.\n\n- ❗ The understanding around persisting `/var/lib/nixos` seems to be evolving.\n  See,[The importance of persisting `/var/lib/nixos`](https://github.com/nix-community/impermanence/issues/178)\n  See also\n  [necessary system state](https://github.com/NixOS/nixpkgs/pull/273384)\n\n3. Reproducibility and Security:\n\n- By wiping transient state, impermanence prevents unintended changes from\n  accumulating, making the system more reproducible.\n\n- It enhances security by ensuring sensitive temporary data (e.g., `/tmp`,\n  runtime credentials) is erased on reboot.\n\n### Getting Started\n\n1. Add impermanence to your `flake.nix`. You will change the `hostname` in the\n   flake to match your `networking.hostName`.\n\n```nix\n# flake.nix\n{\n  description = \"NixOS configuration\";\n\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n    disko.url = \"github:nix-community/disko/latest\";\n    disko.inputs.nixpkgs.follows = \"nixpkgs\";\n    impermanence.url = \"github:nix-community/impermanence\";\n  };\n\n  outputs = inputs@{ nixpkgs, ... }: {\n    nixosConfigurations = {\n      hostname = nixpkgs.lib.nixosSystem {\n        system = \"x86_64-linux\";\n        modules = [\n          ./configuration.nix\n          inputs.disko.nixosModules.disko\n          inputs.impermanence.nixosModules.impermanence\n        ];\n      };\n    };\n  };\n}\n```\n\n2. Discover where your root subvolume is located with `findmnt`:\n\nBefore configuring impermanence, it's crucial to know the device path and\nsubvolume path of your main BTRFS partition where the root filesystem (`/`) is\nlocated. This information is needed for the mount command within the\nimpermanence script.\n\n```bash\nfindmnt /\nTARGET   SOURCE         FSTYPE OPTIONS\n/        /dev/disk/by-partlabel/disk-main-root[/root]\n                        btrfs  rw,noatime,compress=zstd:3,ssd,discard=async,space_cache=v2,subvolid=275,sub\n```\n\nFrom the SOURCE column, note the full path, including the device (e.g.,\n`/dev/disk/by-partlabel/disk-main-root`) and the subvolume in brackets (e.g.,\n`[/root]`). You will use the device path in the next step\n\n`/dev/disk/by-partlabel/disk-main-root` is a symlink to the actual device path\n(e.g. `/dev/nvme0n1p2`), but using the partlabel is generally more robust for\nscripts.\n\n3. Create an `impermanence.nix`:\n\nNow, create a new file named `impermanence.nix` in your configuration directory\n(i.e. your flake directory). This file will contain all the specific settings\nfor your impermanent setup, including BTRFS subvolume management and persistent\ndata locations. Since this file is right next to your `configuration.nix`,\nyou'll just add an `imports = [ ./impermanence.nix ]` to your\n`configuration.nix` apply it to your configuration.\n\n```nix\n{lib, ...}: {\n  #  Reset root subvolume on boot\n  boot.initrd.postResumeCommands = lib.mkAfter ''\n    mkdir /btrfs_tmp\n      mount /dev/disk/by-partlabel/disk-main-root /btrfs_tmp # CONFIRM THIS IS CORRECT FROM findmnt\n      if [[ -e /btrfs_tmp/root ]]; then\n        mkdir -p /btrfs_tmp/old_roots\n        timestamp=$(date --date=\"@$(stat -c %Y /btrfs_tmp/root)\" \"+%Y-%m-%-d_%H:%M:%S\")\n        mv /btrfs_tmp/root \"/btrfs_tmp/old_roots/$timestamp\"\n      fi\n\n      delete_subvolume_recursively() {\n        IFS=$'\\n'\n        for i in $(btrfs subvolume list -o \"$1\" | cut -f 9- -d ' '); do\n          delete_subvolume_recursively \"/btrfs_tmp/$i\"\n        done\n        btrfs subvolume delete \"$1\"\n      }\n\n      for i in $(find /btrfs_tmp/old_roots/ -maxdepth 1 -mtime +30); do\n        delete_subvolume_recursively \"$i\"\n      done\n\n      btrfs subvolume create /btrfs_tmp/root\n      umount /btrfs_tmp\n  '';\n\n  # Use /persist as the persistence root, matching Disko's mountpoint\n  environment.persistence.\"/nix/persist\" = {\n    hideMounts = true;\n    directories = [\n      \"/etc\" # System configuration (Keep this here for persistence via bind-mount)\n      \"/var/spool\" # Mail queues, cron jobs\n      \"/srv\" # Web server data, etc.\n      \"/root\"\n    ];\n    files = [\n    ];\n  };\n}\n```\n\nWith btrfs subvolumes since each directory is its own subvolume, when the root\nis wiped on reboot the subvolumes are untouched.\n\n### Applying Your Impermanence Configuration\n\nOnce you have completed all the steps and created or modified the necessary\nfiles (`flake.nix`, `impermanence.nix`), you need to apply these changes to your\nNixOS system.\n\n1. Navigate to your NixOS configuration directory (where your `flake.nix` is\n   located).\n\n```bash\ncd /path/to/your/flake\n```\n\n2. Rebuild and Switch: Execute the `nixos-rebuild switch` command. This command\n   will:\n\n- Evaluate your `flake.nix` and the modules it imports (including your new\n  `impermanence.nix`).\n\n- Build a new NixOS system closure based on your updated configuration.\n\n- Activate the new system configuration, making it the current running system.\n\n> ❗ **NOTE:** On the first rebuild after setting up impermanence, you may find\n> that you're not in the password database or cannot log in/sudo. This occurs\n> because the initial state of your new ephemeral root filesystem, including\n> `/etc` (where user passwords are stored), is fresh. It has to do with the\n> timing of when `environment.persistence` takes effect during the first boot.\n>\n> To avoid this password issue, **before** your first `nixos-rebuild switch` for\n> impermanence, run:\n>\n> ```bash\n> sudo mkdir -p /nix/persist/etc # Ensure the target directory exists\n> sudo cp -a /etc/* /nix/persist/etc\n> ```\n>\n> - This copies your _current_ `/etc` directory contents (including existing\n>   user passwords) into your persistent storage.\n> - **Crucially:** You must also ensure that `/etc` is explicitly included in\n>   your `environment.persistence.\"/nix/persist\".directories` list in your\n>   `impermanence.nix` like we did above, (or main configuration). This\n>   configures NixOS to persistently bind-mount `/nix/persist/etc` over `/etc`\n>   on every subsequent boot.\n>\n> Once these steps are done and you reboot, your user passwords should function\n> correctly, and future rebuilds will not present this problem.\n\n```bash\nsudo nixos-rebuild switch --flake .#hostname # Replace 'hostname' with your actual system hostname\n```\n\n3. Perform an Impermanence Test (Before Reboot):\n\n- Before you reboot, create a temporary directory and file in a non-persistent\n  location. Since you haven't explicitly added `/imperm_test` to your\n  `environment.persistence.\"/nix/persist\"` directories, this file should not\n  survive a reboot.\n\n```bash\nmkdir /imperm_test\necho \"This should be Gone after Reboot\" | sudo tee /imperm_test/testfile\nls -l /imperm_test/testfile # Verify the file exists\ncat /imperm_test/testfile # Verify content\n```\n\n4. Reboot Your System: For the impermanence setup to take full effect and for\n   your root filesystem to be reset for the first time, you must reboot your\n   machine.\n\n```bash\nsudo reboot\n```\n\n5. Verify Impermanence (After Reboot):\n\n- After the system has rebooted, check if the test directory and file still\n  exist:\n\n```bash\nls -l /imperm_test/testfile\n```\n\nYou should see an output like `ls: cannot access '/imperm_test/testfile'`: No\nsuch file or directory. This confirms that the `/imperm_test` directory and its\ncontents were indeed ephemeral and were removed during the reboot process,\nindicating your impermanence setup is working correctly!\n\nYour system should now come up with a fresh root filesystem, and only the data\nspecified in your `environment.persistence.\"/nix/persist\"` configuration will be\npersistent.\n\n## Recovery with `nixos-enter` and chroot\n\nThis is if you followed the minimal_install guide, it will need to be changed\nfor a different disk layout.\n\n[Chroot](https://en.wikipedia.org/wiki/Chroot) is an operation that changes the\napparent root directory for the current running process and their children. A\nprogram that is run in such a modified environment cannot access files and\ncommands outside that environmental directory tree. This modified environment is\ncalled a chroot jail. --NixOS wiki\n\n`nixos-enter` allows you to access a NixOS installation from a NixOS rescue\nsystem. To use, setup `/mnt` as described in the\n[installation manual](https://nixos.org/manual/nixos/stable/#sec-installation)\n\n🛠️ Recovery: Chroot into Your NixOS Btrfs+Impermanence System\n\nTake note of your layout from commands like:\n\n```bash\nsudo fdisk -l\nlsblk\nsudo btrfs subvol list /\n```\n\nAlso inspect your `disk-config.nix` to ensure you refer to the correct `subvol=`\nnames.\n\nIf you need to repair your system (e.g., forgot root password, fix a broken\nconfig, etc.), follow these steps to chroot into your NixOS install:\n\n1. Boot a Live ISO\n\n   Boot from a NixOS (or any recent Linux) live USB.\n\n   Open a terminal and become root:\n\n```bash\nsudo -i\n```\n\n2. Identify Your Devices\n\nYour main disk is `/dev/nvme0n1`\n\n- EFI partition: `/dev/nvme0n1p1` (mounted at /boot)\n\n- Root partition: `/dev/nvme0n1p2` (Btrfs, with subvolumes)\n\n3. Mount the Btrfs Root Subvolume\n\nFirst, mount the Btrfs partition somewhere temporary (not as / yet):\n\n```bash\nmount -o subvol=root,compress=zstd,noatime /dev/nvme0n1p2 /mnt\n```\n\n4. Mount Other Subvolumes\n\nNow mount your other subvolumes as defined in your `disko.nix`:\n\n```bash\n# Mount Other Subvolumes\n# (Ensure /mnt directories are created for each *mountpoint*)\n\n# Home\nmkdir -p /mnt/home\nmount -o subvol=home,compress=zstd,noatime /dev/nvme0n1p2 /mnt/home\n\n# IMPORTANT: No separate mount for /mnt/home/user, as it's a nested subvolume\n# and handled by the /home mount.\n\n# Nix store\nmkdir -p /mnt/nix\nmount -o subvol=nix,compress=zstd,noatime /dev/nvme0n1p2 /mnt/nix\n\n# Nix persist\nmkdir -p /mnt/nix/persist\n# CRITICAL: Based our disko.nix, the subvolume name is 'persist', not 'nix/persist'\nmount -o subvol=persist,compress=zstd,noatime /dev/nvme0n1p2 /mnt/nix/persist\n\n# /var/log\nmkdir -p /mnt/var/log\nmount -o subvol=log,compress=zstd,noatime /dev/nvme0n1p2 /mnt/var/log\n\n# /var/lib\nmkdir -p /mnt/var/lib\n# Confirmed: The subvolume named 'lib' is mounted to /var/lib\nmount -o subvol=lib,compress=zstd,noatime /dev/nvme0n1p2 /mnt/var/lib\n```\n\nNote: If you get \"subvolume not found,\" check the subvolume names with\n`btrfs subvol list /mnt`.\n\n5. Mount the EFI Partition\n\n```bash\nmkdir -p /mnt/boot mount /dev/nvme0n1p1 /mnt/boot\n```\n\n6. (Optional) Mount Virtual Filesystems\n\n```bash\nmount --bind /dev /mnt/dev mount --bind /proc /mnt/proc mount --bind /sys\n/mnt/sys mount --bind /run /mnt/run\n```\n\n7. Chroot\n\n```bash\nchroot /mnt /run/current-system/sw/bin/bash\n```\n\nor, if using a non-NixOS live system:\n\n```bash\nnixos-enter\n```\n\n(You may need to install nixos-enter with nix-shell -p nixos-enter.) 8. You’re\nIn!\n\nYou can now run `nixos-rebuild`, reset passwords, or fix configs as needed. 🔎\n\n📓 Notes\n\n- Adjust `compress=zstd,noatime` if your config uses different mount options.\n\n- For impermanence, make sure to mount all persistent subvolumes you need.\n\n- If you use swap, you may want to enable it too (e.g., `swapon /dev/zram0` if\n  relevant).\n\nYou can now recover, repair, or maintain your NixOS system as needed!\n\n#### Related Material\n\n- [Change root (chroot)](https://wiki.nixos.org/wiki/Change_root)\n\n- [nixos-enter](https://www.mankier.com/8/nixos-enter)\n\n- [erase your darlings](https://grahamc.com/blog/erase-your-darlings/)\n\n- [Guide for Btrfs with LUKS](https://haseebmajid.dev/posts/2024-07-30-how-i-setup-btrfs-and-luks-on-nixos-using-disko/)\n\n- [notashelf impermanence](https://notashelf.dev/posts/impermanence)\n\n- [NixOS wiki Impermanence](https://wiki.nixos.org/wiki/Impermanence)\n\n- [nix-community impermanence module](https://github.com/nix-community/impermanence)\n","number":[2,2],"sub_items":[],"path":"installation/unencrypted/impermanence.md","source_path":"installation/unencrypted/impermanence.md","parent_names":["Installation"]}}],"path":"installation/index.md","source_path":"installation/README.md","parent_names":[]}},{"Chapter":{"name":"Encrypted Setups","content":"# Encrypted Setups\n\n<details>\n<summary> ✔️ Click to Expand Table of Contents</summary>\n\n<!-- toc -->\n\n</details>\n\nNixOS supports file systems that are encrypted using LUKS (Linux Unified Key\nSetup). This guide walks you through an encrypted NixOS installation using Disko\nfor disk management and Btrfs for subvolumes. It is designed for users who want\nfull disk encryption and a modern filesystem layout. If you prefer an\nunencrypted setup, you can skip the LUKS and encryption steps, but this guide\nfocuses on security and flexibility.\n\n- For Unencrypted layout\n  [Click Here](https://saylesss88.github.io/installation/unencrypted/unencrypted.html)\n\nIf you choose to set up impermanence, ensure it matches your install. Encrypted\nSetup with Encrypted Impermanence and Unencrypted Setup with Unencrypted\nImpermanence.\n\n> ❗ NOTE: This is a bit convoluted, there are a few paths you can follow. If\n> you choose to use the starter repo (<https://github.com/saylesss88/my-flake>)\n> just follow the included README and use this for reference.\n\n## What does LUKS Encryption Protect?\n\nIt's important to understand what disk encryption protects and what it doesn't\nprotect so you don't have any misconceptions about how safe your data is.\n\n- [NixOS Wiki FDE](https://wiki.nixos.org/wiki/Full_Disk_Encryption)\n\n- [Arch Wiki Data-at-rest encryption](https://wiki.archlinux.org/title/Data-at-rest_encryption)\n\n- [Authenticated Booot and DE on Linux](https://0pointer.net/blog/authenticated-boot-and-disk-encryption-on-linux.html)\n\n- [Bypassing FDE with TPM2 Unlock](https://oddlama.org/blog/bypassing-disk-encryption-with-tpm2-unlock/)\n\n**What LUKS Protects**:\n\n- **Data Confidentiality at Rest**: LUKS encrypts entire block devices (such as\n  disk partitions or whole drives), ensuring that all data stored on the\n  encrypted device is unreadable without the correct decryption key or\n  passphrase. This protects sensitive information from unauthorized access if\n  the device is lost, stolen, or physically accessed by an attacker.\n\n- **Physical Security**: If someone gains physical possession of your device\n  (for example, by stealing your laptop or removing a hard drive), LUKS ensures\n  the data remains inaccessible and appears as random, meaningless bytes without\n  the correct credentials.\n\n- **Protection Against Offline Attacks**: LUKS defends against attackers who\n  attempt to bypass the operating system by booting from another device or\n  removing the drive and mounting it elsewhere. Without the decryption key, the\n  data remains protected.\n\n**What LUKS Does Not Protect**:\n\n- **Data in Use**: Once the system is booted and the encrypted device is\n  unlocked, the data becomes accessible to the operating system and any user or\n  process with the necessary permissions. LUKS does not protect against attacks\n  on a running system, such as malware, remote exploits, or unauthorized users\n  with access to an unlocked session.\n\n- **File-Level Access Control**: LUKS encrypts entire partitions or disks, not\n  individual files or directories. It does not provide granular file-level\n  encryption or access control within the operating system.\n\n- **Network Attacks**: LUKS only protects data stored on disk. It does not\n  encrypt data transmitted over networks or protect against network-based\n  attacks.\n\n- **Bootloader and EFI Partitions**: The initial bootloader or EFI system\n  partition cannot be encrypted with LUKS, so some parts of the boot process may\n  remain exposed unless additional measures are taken. (i.e., Secure Boot,\n  additional passwords, TPM2)\n\nTo Sum it Up: LUKS encryption protects the confidentiality of all data stored on\nan encrypted block device by making it unreadable without the correct passphrase\nor key. This ensures that, if your device is lost or stolen, your data remains\nsecure and inaccessible to unauthorized users. However, LUKS does not protect\ndata once the system is unlocked and running, nor does it provide file-level\nencryption or protect against malware and network attacks. For comprehensive\nsecurity, LUKS should be combined with strong access controls and other security\nbest practices.\n\n## The Install\n\n1. Get the\n   [Nixos Minimal ISO](https://channels.nixos.org/nixos-25.05/latest-nixos-minimal-x86_64-linux.iso)\n   Get it on a usb stick, I use Ventoy with Ventoy2Disk.sh. The following is the\n   link to the\n   [Ventoy TarBall](https://sourceforge.net/projects/ventoy/files/v1.1.05/ventoy-1.1.05-linux.tar.gz/download)\n   download, untar it with `tar -xzf ventoy-1.1.05-linux.tar.gz`, and make it\n   executable with `chmod +x Ventoy2Disk.sh`, and finally execute it with\n   `sudo bash Ventoy2Disk.sh` Follow the prompts to finish the install.\n\n2. Configuring Networking\n\nThe minimal installer uses `wpa_supplicant` instead of NetworkManager. Choose\none of the following methods to enable networking:\n\n```bash\nsudo systemctl start wpa_supplicant\nwpa_cli\n```\n\n### Option A: Interactive `wpa_cli`\n\n```bash\n> add_network\n0\n\n> set_network 0 ssid \"myhomenetwork\"\nOK\n\n> set_network 0 psk \"mypassword\"\nOK\n\n> enable_network 0\nOK\n```\n\nTo exit type `quit`, then check your connection with `ping google.com`.\n\n### Option B: Non-Interactive `wpa_passphrase`\n\nThis method is quicker for known networks and persists the configuration for the\nlive environment.\n\nFirst, identify your wireless interface name (e.g., `wlan0`) using `ip a`.\n\n```bash\nsudo systemctl start wpa_supplicant # Ensure wpa_supplicant is running\n# This command generates the config and appends it to a file specific to wlan0\nsudo wpa_passphrase \"myhomenetwork\" \"mypassword\" | sudo tee /etc/wpa_supplicant/wpa_supplicant-wlan0.conf\nsudo systemctl restart wpa_supplicant@wlan0.service\n```\n\nAfter either method, exit `wpa_cli` with `quit`. Then test your connection:\n\n```bash\nping 1.1.1.1\n```\n\n3. Get your Disk Name with `lsblk`\n\nThe output should be something like:\n\n```bash\nNAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS\nnvme0n1     259:0    0   1,8T  0 disk\n```\n\n> ❗ From here, you can either\n\n4. Copy the disk configuration to your machine. You can choose one from the\n   [examples directory](https://github.com/nix-community/disko/tree/master/example).\n\nThere is still a starter repo that can save you some typing, make sure to\ncarefully review if you decide to use it:\n\n```bash\nexport NIX_CONFIG='experimental-features = nix-command flakes'\nexport EDITOR='hx' # or 'vi'\nnix-shell -p git yazi helix mkpasswd\ngit config --global user.name \"gitUsername\"\ngit config --global user.email \"gitEmail\"\n# OPTIONAL starter repo containing disk-config set up for impermanence\ngit clone https://github.com/saylesss88/my-flake.git\n```\n\nI prefer `helix` here as it's defaults are great. (i.e., auto closing brackets\nand much more)\n\nIf you choose to use the starter repo you won't need to run the next command as\nit is already populated in the repo and should use the\n[Starter Repo README](https://github.com/saylesss88/my-flake) most of the rest\nof the guide is for manual disko without the starter repo.\n\nIf you click on the layout you want then click the `Raw` button near the top,\nthen copy the `url` and use it in the following command:\n\n```bash\ncd /tmp\ncurl https://raw.githubusercontent.com/nix-community/disko/refs/heads/master/example/luks-btrfs-subvolumes.nix -o /tmp/disk-config.nix\n```\n\nThe above curl command is to the `luks-btrfs-subvolumes.nix` layout.\n\n5. Make Necessary changes, I prepared mine for impermanence with the following:\n\n```bash\nhx /tmp/disk-config.nix\n```\n\nMake sure you identify your system disk name with `lsblk` and change the\n`device` attribute below to match your disk.\n\n```bash\nlsblk\nnvme0n1       259:0    0 476.9G  0 disk\n├─nvme0n1p1   259:1    0   512M  0 part  /boot\n└─nvme0n1p2   259:2    0 476.4G  0 part\n```\n\nMy disk is `nvme0n1`, change below to match yours:\n\n```nix\n{\n  disko.devices = {\n    disk = {\n      nvme0n1 = {\n        type = \"disk\";\n        # Make sure this is correct with `lsblk`\n        device = \"/dev/nvme0n1\";\n        content = {\n          type = \"gpt\";\n          partitions = {\n            ESP = {\n              label = \"boot\";\n              name = \"ESP\";\n              size = \"1G\";\n              type = \"EF00\";\n              content = {\n                type = \"filesystem\";\n                format = \"vfat\";\n                mountpoint = \"/boot\";\n                mountOptions = [\n                  \"defaults\"\n                ];\n              };\n            };\n            luks = {\n              size = \"100%\";\n              label = \"luks\";\n              content = {\n                type = \"luks\";\n                name = \"cryptroot\";\n                content = {\n                  type = \"btrfs\";\n                  extraArgs = [\"-L\" \"nixos\" \"-f\"];\n                  subvolumes = {\n                    \"/root\" = {\n                      mountpoint = \"/\";\n                      mountOptions = [\"subvol=root\" \"compress=zstd\" \"noatime\"];\n                    };\n                    \"/root-blank\" = {\n                      mountOptions = [\"subvol=root-blank\" \"nodatacow\" \"noatime\"];\n                    };\n                    \"/home\" = {\n                      mountpoint = \"/home\";\n                      mountOptions = [\"subvol=home\" \"compress=zstd\" \"noatime\"];\n                    };\n                    \"/nix\" = {\n                      mountpoint = \"/nix\";\n                      mountOptions = [\"subvol=nix\" \"compress=zstd\" \"noatime\"];\n                    };\n                    \"/persist\" = {\n                      mountpoint = \"/persist\";\n                      mountOptions = [\"subvol=persist\" \"compress=zstd\" \"noatime\"];\n                    };\n                    \"/log\" = {\n                      mountpoint = \"/var/log\";\n                      mountOptions = [\"subvol=log\" \"compress=zstd\" \"noatime\"];\n                    };\n                    \"/lib\" = {\n                      mountpoint = \"/var/lib\";\n                      mountOptions = [\"subvol=lib\" \"compress=zstd\" \"noatime\"];\n                    };\n                    \"/persist/swap\" = {\n                      mountpoint = \"/persist/swap\";\n                      mountOptions = [\"subvol=swap\" \"noatime\" \"nodatacow\" \"compress=no\"];\n                      swap.swapfile.size = \"18G\";\n                    };\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n\n  fileSystems.\"/persist\".neededForBoot = true;\n  fileSystems.\"/var/log\".neededForBoot = true;\n  fileSystems.\"/var/lib\".neededForBoot = true;\n}\n```\n\nI have 16G of RAM so to be safe for hibernation I chose to give it some extra\nspace. The boot partition is 1G, this extra space is for specialisations and\nlanzaboote.\n\nor for a swapfile:\n\n```nix\nswapDevices = [\n  {\n    device = \"/persist/swap/swapfile\";\n    size = 18 * 1024; # Size in MB (18GB)\n    # or\n    # size = 16384; # Size in MB (16G);\n  }\n];\n```\n\n## Setting up zram and /tmp on RAM\n\nWhile `/tmp` is handled by `tmpfs` (as shown the below `configuration.nix`), you\ncan further enhance memory efficiency with `zram` for compressed swap, as shown\nbelow.\n\n> ```nix\n> {\n>   lib,\n>   config,\n>   ...\n> }: let\n>   cfg = config.custom.zram;\n> in {\n>   options.custom.zram = {\n>     enable = lib.mkEnableOption \"Enable utils module\";\n>   };\n>\n>   config = lib.mkIf cfg.enable {\n>     zramSwap = {\n>       enable = true;\n>       # one of \"lzo\", \"lz4\", \"zstd\"\n>       algorithm = \"zstd\";\n>        priority = 5;\n>        memoryPercent = 50;\n>     };\n>   };\n> }\n> ```\n>\n> And in your `configuration.nix` you would add:\n>\n> ```nix\n> # configuration.nix\n> custom = {\n>     zram.enable = true;\n> };\n> ```\n\nAfter adding the above module and rebuilding, you can see it with:\n\n```bash\nswapon --show\nNAME       TYPE      SIZE USED PRIO\n/dev/zram0 partition 7.5G   0B    5\n```\n\n6.  Run disko to partition, format and mount your disks. **Warning** this will\n    wipe **EVERYTHING** on your disk. Disko doesn't work with dual boot.\n\n```bash\nsudo nix --experimental-features \"nix-command flakes\" run github:nix-community/disko/latest -- --mode destroy,format,mount /tmp/disk-config.nix\n```\n\nCheck it with the following:\n\n```bash\nmount | grep /mnt\n```\n\nThe output for an `nvme0n1` disk would be similar to the following:\n\n```bash\n#... snip ...\n/dev/nvme0n1p2 on /mnt type btrfs (rw,noatime,compress=zstd:3,ssd,discard=async,space_cache=v2,subvolid=285,subvol=/root)\n/dev/nvme0n1p2 on /mnt/persist type btrfs (rw,noatime,compress=zstd:3,ssd,discard=async,space_cache=v2,subvolid=261,subvol=/persist)\n/dev/nvme0n1p2 on /mnt/etc type btrfs (rw,noatime,compress=zstd:3,ssd,discard=async,space_cache=v2,subvolid=261,subvol=/persist)\n/dev/nvme0n1p2 on /mnt/nix type btrfs (rw,noatime,compress=zstd:3,ssd,discard=async,space_cache=v2,subvolid=260,subvol=/nix)\n/dev/nvme0n1p2 on /mnt/var/lib type btrfs (rw,noatime,compress=zstd:3,ssd,discard=async,space_cache=v2,subvolid=258,subvol=/lib)\n/dev/nvme0n1p2 on /mnt/var/log type btrfs (rw,noatime,compress=zstd:3,ssd,discard=async,space_cache=v2,subvolid=259,subvol=/log)\n/dev/nvme0n1p2 on /mnt/nix/store type btrfs (ro,noatime,compress=zstd:3,ssd,discard=async,space_cache=v2,subvolid=260,subvol=/nix)\n# ... snip ...\n```\n\n7. Generate necessary files, here we use `--no-filesystems` because disko\n   handles the `fileSystems` attribute for us.\n\n```bash\nnixos-generate-config --no-filesystems --root /mnt\n```\n\n- The above command will place a `configuration.nix` and\n  `hardware-configuration.nix` in `/mnt/etc/nixos/`\n\nIt may be helpful to add a couple things to your `configuration.nix` now, while\nit's in its default location. You can just add what you want and rebuild once\nwith `sudo nixos-rebuild switch` and move on. (i.e. `git`, an editor, etc.).\n\n### Setting a Flake for your minimal Install\n\n8. Create the flake in your home directory to avoid needing to use sudo for\n   every command:\n\n```bash\ncd   # Move to home directory\nmkdir flake\ncd /mnt/etc/nixos/\nsudo mv hardware-configuration.nix configuration.nix ~/flake/\nsudo mv /tmp/disk-config.nix ~/flake/\n```\n\n```bash\ncd flake\nhx flake.nix\n```\n\n> You'll change `hostName = nixpkgs.lib.nixosSystem` to your chosen hostname,\n> (e.g. `magic = nixpkgs.lib.nixosSystem`). This will be the same as your\n> `networking.hostName = \"magic\";` in your `configuration.nix` that we will set\n> up shortly.\n\n```nix\n# flake.nix\n{\n  description = \"NixOS configuration\";\n\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n    disko.url = \"github:nix-community/disko/latest\";\n    disko.inputs.nixpkgs.follows = \"nixpkgs\";\n    # impermanence.url = \"github:nix-community/impermanence\";\n  };\n\n  outputs = inputs@{ nixpkgs, ... }: {\n    nixosConfigurations = {\n      # Change `hostName` to your chosen host name\n      nixos = nixpkgs.lib.nixosSystem {\n        system = \"x86_64-linux\";\n        modules = [\n          ./configuration.nix\n          inputs.disko.nixosModules.disko\n          # inputs.impermanence.nixosModules.impermanence\n        ];\n      };\n    };\n  };\n}\n```\n\n9. Edit `configuration.nix` with what is required, the following are required, I\n   clone my original flake repo and move the pieces into place but it's fairly\n   easy to just type it all out:\n\n- Bootloader, (e.g., `boot.loader.systemd-boot.enable = true;`)\n\n- User, the example uses `username` change this to your chosen username. If you\n  don't set your hostname it will be `nixos`.\n\n- Networking, `networking.networkmanager.enable = true;`\n\n- `hardware-configuration.nix` & `disk-config.nix` for this setup\n\n- If you type this out by hand and mess up a single character, you will have to\n  start over completely. A fairly safe way to do this is with `vim` or `hx` and\n  redirect the hashed pass to a `/tmp/pass.txt`, you can then read it into your\n  `users.nix`:\n\n```bash\nmkpasswd --method=yescrypt > /tmp/pass.txt\n# Enter your chosen password\n```\n\nAnd then when inside `configuration.nix`, move to the line where you want the\nhashed password and type `:r /tmp/pass.txt` to read the hash into your current\nfile.\n\n```nix\n# configuration.nix\n{\n  config,\n  lib,\n  pkgs,\n  inputs,\n  ...\n}: {\n  imports = [\n    # Include the results of the hardware scan.\n    ./hardware-configuration.nix\n    ./disk-config.nix\n  ];\n\n  # systemd Stage 1: if enabled, it handles unlocking of LUKS-encrypted volumes during boot.\n    boot.initrd.luks.devices = {\n    cryptroot = {\n      device = \"/dev/disk/by-partlabel/luks\";\n      allowDiscards = true;\n    };\n  };\n\n  # This complements using zram, putting /tmp on RAM\n    boot = {\n    tmp = {\n      useTmpfs = true;\n      tmpfsSize = \"50%\";\n    };\n  };\n\n  # Enable autoScrub for btrfs\n    services.btrfs.autoScrub = {\n    enable = true;\n    interval = \"weekly\";\n    fileSystems = [\"/\"];\n  };\n\n\n  # Change me!\n  networking.hostName = \"nixos\"; # This will match the `hostname` of your flake\n\n  networking.networkmanager.enable = true;\n\n  boot.loader.systemd-boot.enable = true; # (for UEFI systems only)\n  # List packages installed in system profile.\n  # You can use https://search.nixos.org/ to find more packages (and options).\n  environment.systemPackages = with pkgs; [\n    vim # Do not forget to add an editor to edit configuration.nix! The Nano editor is also installed by default.\n    #   wget\n    git\n  ];\n\n  time.timeZone = \"America/New_York\";\n\n# Change me to your chosen username (i.e. change nixosUser to your username)\n  users.users.nixosUser = {\n    isNormalUser = true;\n    extraGroups = [ \"wheel\" \"networkmanager\" ]; # Add \"wheel\" for sudo access\n    initialHashedPassword = \"READ_MKPASSWD_OUTPUT_HERE\"; # <-- This is where it goes!\n    # home = \"/home/nixos\"; # Optional: Disko typically handles home subvolumes\n  };\n  # Change me to match your chosen username\n  users.group.nixosUser = {};\n\n  console.keyMap = \"us\";\n\n  nixpkgs.config.allowUnfree = true;\n\n  system.stateVersion = \"25.05\";\n}\n```\n\nAlthough, just adding the `disk-config.nix` works for prompting you for your\nencryption passphrase adding the following is a more robust way of ensuring Nix\nis aware of this:\n\n```nix\n    boot.initrd.luks.devices = {\n    cryptroot = {\n      device = \"/dev/disk/by-partlabel/luks\";\n      allowDiscards = true;\n    };\n  };\n```\n\n10. Move the flake to `/mnt/etc/nixos` and run `nixos-install`:\n\n```bash\nsudo mv ~/flake /mnt/etc/nixos/\n```\n\n- Give everything a quick once over, insuring your host is set in both your\n  `flake.nix`, and `configuration.nix`. Ensure you changed the username in the\n  `configuration.nix` from `nixos` to your chosen name, this is the name you'll\n  use to login after you enter your encryption passphrase.\n\nThe below command uses `#nixos` because that's what the defaults are, you'll\nchange it to your chosen hostname.\n\n```bash\nsudo nixos-install --flake /mnt/etc/nixos/flake#nixos\n```\n\n- You will be prompted to enter a new password if everything succeeds.\n\n## Create a Blank Snapshot of /root\n\nThis is essential if you plan on using impermanence with this encrypted setup.\nWe take a snapshot of `/root` while it's a clean slate, right after we run disko\nto format the disk.\n\nTo access all of the subvolumes, we have to mount the Btrfs partitions\ntop-level.\n\n1. Unlock the LUKS device, if not already unlocked as it should be from running\n   disko:\n\n```bash\nsudo cryptsetup open /dev/disk/by-partlabel/luks cryptroot\n```\n\n2. Mount the Btrfs top-level (`subvolid=5`):\n\n```bash\nsudo mount -o subvolid=5 /dev/mapper/cryptroot /mnt\n```\n\n3. List the contents:\n\n```bash\nls /mnt\n# you should see something like\nroot   home  nix  persist  log  lib  ...\n```\n\n4. Now we can take a snapshot of the `root` subvolume:\n\n```bash\nsudo btrfs subvolume snapshot -r /mnt/root /mnt/root-blank\n```\n\n5. Verify Your Blank Snapshot:\n\nBefore continuing, make sure your blank snapshot exists. This is crucial for\nimpermanence to work properly.\n\n```bash\nsudo btrfs subvolume list /mnt\n```\n\nYou should see output containing both `root` and `root-blank` subvolumes:\n\n```bash\nID 256 gen ... path root\nID 257 gen ... path root-blank\n```\n\nCheck that the snapshot is read only, this ensures that our snapshot will remain\nthe same as the day we took it. It was set `ro` in disko but lets check anyways:\n\n```bash\nsudo btrfs property get -ts /mnt/root-blank\n# output should be\nro=true\n```\n\n5. Make sure to unmount:\n\n```bash\nsudo umount /mnt\n```\n\n- If everything checks out, reboot the system and you should be prompted to\n  enter your `user` and `password` to login to a shell to get started.\n\n- The flake will be placed at `/etc/nixos/flake` after the install and reboot, I\n  choose to move it to my home directory. Since the file was first in `/etc`\n  you'll need to adjust the permissions with something like\n  `sudo chown -R $USER:$USER ~/flake` and then you can work on it without\n  privilege escalation. This requires that you create a group for your user as\n  done in the `configuration.nix` above.\n\n- You can check the layout of your btrfs system with:\n\n```bash\nsudo btrfs subvolume list /\n```\n\n## Persisting Critical System State\n\nThe following is a one time operation, we're just getting it out of the way now.\nThis moves all of the important system state to a persistant location, further\npreparing for impermanence.\n\nIt's essential that you have first run the `nixos-install` command to populate\nthese directories before copying them over.\n\n```bash\nsudo mkdir -p /mnt/persist/etc\nsudo mkdir -p /mnt/persist/var/lib\nsudo mkdir -p /mnt/persist/var/log\nsudo mkdir -p /mnt/persist/home\nsudo mkdir -p /mnt/persist/root\nsudo cp -a /mnt/etc/. /mnt/persist/etc/\nsudo cp -a /mnt/var/lib/. /mnt/persist/var/lib\nsudo cp -a /mnt/var/log/. /mnt/persist/var/log\nsudo cp -a /mnt/home/. /mnt/persist/home/\nsudo cp -a /mnt/root/. /mnt/persist/root/\n```\n\nSince we are in a live environment, after the install and reboot the `/mnt`\nprefix will be removed.\n\n## Reboot\n\nNow that everything is done, we can safely reboot and ensure that our LUKS\npassword/passphrase is accepted as well as our userlevel password and username.\n\nAfter reboot, you can continue to setup\n[Sops Encrypted Secrets](https://saylesss88.github.io/installation/enc/sops-nix.html)\nand\n[Lanzaboote Secure Boot](https://saylesss88.github.io/installation/enc/lanzaboote.html)\n\n- To set up impermanence for this specific layout, follow the link\n  [Encrypted Impermanence](https://saylesss88.github.io/installation/enc/encrypted_impermanence.html)\n\n- [BTRFS Subvolumes](https://btrfs.readthedocs.io/en/latest/Subvolumes.html)\n\n- [systemd-cryptenroll man page](https://www.freedesktop.org/software/systemd/man/latest/systemd-cryptenroll.html)\n\n- [Linux TPM PCR Registry](https://uapi-group.org/specifications/specs/linux_tpm_pcr_registry/)\n\n- [Bypassing FDE with TPM2](https://oddlama.org/blog/bypassing-disk-encryption-with-tpm2-unlock/)\n","number":[3],"sub_items":[{"Chapter":{"name":"Encrypted Impermanence","content":"# Encrypted Impermanence\n\n<details>\n<summary> ✔️ Click to Expand Table of Contents</summary>\n\n<!-- toc -->\n\n</details>\n\n> ❗ Important Note: This guide details a setup involving encrypted partitions\n> and impermanent NixOS. While powerful, such configurations require careful\n> attention to detail. Incorrect steps, especially concerning encryption keys or\n> persistent data paths, can lead to **permanent data loss**. Please read all\n> instructions thoroughly before proceeding and consider backing up any critical\n> data beforehand. This has only been tested with the disk layout described in\n> [Encrypted Setups](https://saylesss88.github.io/installation/encrypted_manual.html)\n\nAs a system operates, it gradually accumulates state on its root partition. This\nstate is stored in various directories such as `/etc` and `/var`, capturing all\nthe configuration changes, logs, and other modifications—whether they’re\nwell-documented or the result of ad-hoc adjustments made while setting up and\nrunning services.\n\n**Impermanence**,in the context of operating systems, refers to a setup where\nthe majority of the system's root filesystem (`/`) is reset to a pristine state\non every reboot. This means any changes made to the system (e.g., installing new\npackages, modifying system files outside of configuration management, creating\ntemporary files) are discarded upon shutdown or reboot.\n\nHaving an impermanent root and `/tmp` has some security benefits as well. By\nreducing your persistent footprint you reduce your chance of leaving behind\nsensitive activity or data. Since Nix can boot with only `/nix` and `/boot`,\nexperienced users familiar with \"stateless\" systems can take advantage of this\nsmaller attack surface.\n\nAlthough this setup does not use `/tmp` as the root filesystem, the root itself\nis restored to its original state upon each reboot, as it was at installation.\nHowever, by configuring `/tmp` to reside in RAM, you ensure that temporary files\nincluding sensitive data like passwords are stored only in volatile memory and\nare automatically cleared on shutdown or reboot. This significantly enhances the\nsecurity of temporary data by preventing it from ever being written to disk.\n\n### Getting Started\n\n1. Add impermanence to your `flake.nix`. You will change the `hostname` in the\n   flake to match your `networking.hostName`.\n\n```nix\n# flake.nix\n{\n  description = \"NixOS configuration\";\n\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n    disko.url = \"github:nix-community/disko/latest\";\n    disko.inputs.nixpkgs.follows = \"nixpkgs\";\n    impermanence.url = \"github:nix-community/impermanence\";\n  };\n\n  outputs = inputs@{ nixpkgs, ... }: {\n    nixosConfigurations = {\n      hostname = nixpkgs.lib.nixosSystem {\n        system = \"x86_64-linux\";\n        modules = [\n          ./configuration.nix\n          inputs.disko.nixosModules.disko\n          inputs.impermanence.nixosModules.impermanence\n        ];\n      };\n    };\n  };\n}\n```\n\n2. Discover where your root subvolume is located with `findmnt`:\n\nIf you followed the\n[Encrypted Setups](https://saylesss88.github.io/installation/encrypted_manual.html)\nguide, your encrypted subvolume should be located at:\n`/dev/mapper/cryptroot /mnt`\n\n- Your encrypted Btrfs partition, once unlocked by LUKS, will be available at\n  `/dev/mapper/cryptroot` as configured here in the `disk-config.nix`:\n\n```nix\n# disk-config2.nix\n# ... snip ...\n            luks = {\n              size = \"100%\";\n              label = \"luks\";\n              content = {\n                type = \"luks\";\n                name = \"cryptroot\";\n                content = {\n# ... snip ...\n```\n\nDouble check that the paths exist:\n\n```bash\ncd /dev/mapper/crypt<TAB>  # autocomplete should fill out /dev/mapper/cryptroot\n```\n\n3. Create an `impermanence.nix`:\n\nNow, create a new file named `impermanence.nix` in your configuration directory\n(i.e. your flake directory). This file will contain all the specific settings\nfor your impermanent setup, including BTRFS subvolume management and persistent\ndata locations. Since this file is right next to your `configuration.nix`,\nyou'll just add an `imports = [ ./impermanence.nix ]` to your\n`configuration.nix` apply it to your configuration.\n\n```nix\n{\n  config,\n  lib,\n  ...\n}: {\n  boot.initrd.postDeviceCommands = lib.mkAfter ''\n    echo \"Rollback running\" > /mnt/rollback.log\n     mkdir -p /mnt\n     mount -t btrfs /dev/mapper/cryptroot /mnt\n\n     # Recursively delete all nested subvolumes inside /mnt/root\n     btrfs subvolume list -o /mnt/root | cut -f9 -d' ' | while read subvolume; do\n       echo \"Deleting /$subvolume subvolume...\" >> /mnt/rollback.log\n       btrfs subvolume delete \"/mnt/$subvolume\"\n     done\n\n     echo \"Deleting /root subvolume...\" >> /mnt/rollback.log\n     btrfs subvolume delete /mnt/root\n\n     echo \"Restoring blank /root subvolume...\" >> /mnt/rollback.log\n     btrfs subvolume snapshot /mnt/root-blank /mnt/root\n\n     umount /mnt\n  '';\n\n  environment.persistence.\"/persist\" = {\n    directories = [\n      \"/etc\"\n      \"/var/spool\"\n      \"/root\"\n      \"/srv\"\n      \"/etc/NetworkManager/system-connections\"\n      \"/var/lib/bluetooth\"\n    ];\n    files = [\n      # \"/etc/machine-id\"\n      # Add more files you want to persist\n    ];\n  };\n\n# optional quality of life setting\n  security.sudo.extraConfig = ''\n    Defaults lecture = never\n  '';\n}\n```\n\n- `/mnt/rollback.log`: this log will be available during the boot process for\n  debugging if the rollback fails, but won't persist.\n\nWith the above impermanence script, the btrfs subvolumes are deleted recursively\nand replaced with the `root-blank` snapshot we took during the install.\n\nI have commented out `\"/etc/machine-id\"` because we already copied over all of\nthe files to their persistent location and the above setting would work once and\nthen cause a conflict.\n\n## configuration.nix changes\n\n```nix\n# configuration.nix\n  boot.initrd.luks.devices = {\n    cryptroot = {\n      device = \"/dev/disk/by-partlabel/luks\";\n      allowDiscards = true;\n      preLVM = true;\n    };\n  };\n```\n\n- This defines how your system's initial ramdisk (`initrd`) should handle a\n  specific encrypted disk during the boot process. It helps with timing and is a\n  more robust way of telling Nix that we are using an encrypted disk.\n\nThe following is optional to enable `autoScrub` for btrfs, the wiki shows\n`interval = \"monthly\";` FYI.\n\n```nix\n# configuration.nix\n  services.btrfs.autoScrub = {\n    enable = true;\n    interval = \"weekly\";\n    fileSystems = [\"/\"];\n  };\n```\n\n- Remember to ensure that your `hostname` in your `configuration.nix` matches\n  the `hostname` in your `flake.nix`.\n\n### Applying Your Impermanence Configuration\n\nOnce you have completed all the steps and created or modified the necessary\nfiles (`flake.nix`, `impermanence.nix`), you need to apply these changes to your\nNixOS system.\n\n1. Navigate to your NixOS configuration directory (where your `flake.nix` is\n   located).\n\n```bash\ncd /path/to/your/flake\n```\n\n2. Rebuild and Switch: Execute the `nixos-rebuild switch` command. This command\n   will:\n\n- Evaluate your `flake.nix` and the modules it imports (including your new\n  `impermanence.nix`).\n\n- Build a new NixOS system closure based on your updated configuration.\n\n- Activate the new system configuration, making it the current running system.\n\n```bash\nsudo nixos-rebuild switch --flake .#hostname # Replace 'hostname' with your actual system hostname\n```\n\n3. Perform an Impermanence Test (Before Reboot):\n\n- Before you reboot, create a temporary directory and file in a non-persistent\n  location. Since you haven't explicitly added `/imperm_test` to your\n  `environment.persistence.\"/persist\"` directories, this file should not survive\n  a reboot.\n\n```bash\nmkdir /imperm_test\necho \"This should be Gone after Reboot\" | sudo tee /imperm_test/testfile\nls -l /imperm_test/testfile # Verify the file exists\ncat /imperm_test/testfile # Verify content\n```\n\n4. Reboot Your System: For the impermanence setup to take full effect and for\n   your root filesystem to be reset for the first time, you must reboot your\n   machine.\n\n```bash\nsudo reboot\n```\n\n5. Verify Impermanence (After Reboot):\n\n- After the system has rebooted, check if the test directory and file still\n  exist:\n\n```bash\nls -l /imperm_test/testfile\n```\n\nYou should see an output like `ls: cannot access '/imperm_test/testfile'`: No\nsuch file or directory. This confirms that the `/imperm_test` directory and its\ncontents were indeed ephemeral and were removed during the reboot process,\nindicating your impermanence setup is working correctly!\n\nYour system should now come up with a fresh root filesystem, and only the data\nspecified in your `environment.persistence.\"/persist\"` configuration will be\npersistent.\n","number":[3,1],"sub_items":[],"path":"installation/enc/encrypted_impermanence.md","source_path":"installation/enc/encrypted_impermanence.md","parent_names":["Encrypted Setups"]}},{"Chapter":{"name":"USB Stick Keyfile","content":"# USB Stick Keyfile\n\n<details>\n<summary> ✔️ Click to Expand Table of Contents</summary>\n\n<!-- toc -->\n\n</details>\n\nThis allows you to use a USB stick for your keyfile, with a backup in case you\nwant or need it. There is a setting `fallbackToPassword` that protects you in\ncase something fails with the USB key.\n\nFirst, I'll show how to set up a dedicated USB stick for a keyfile. (i.e., one\nthat is only used for this). After that I will show the process of adding the\nkeyfile to a USB stick with existing data on it that you don't want to lose.\n\n**Generate the keyfile**\n\n```bash\nsudo dd if=/dev/urandom of=/root/usb-luks.key bs=4096 count=1\n```\n\n## Keyfile Enrollment Methods\n\nThis is for a dedicated USB stick that we will wipe first then add the key.\n\nDisko defaults to LUKS2\n\n```bash\n# cryptsetup works for both LUKS1 and LUKS2 formats but doesn't work for\n# TPM2, FIDO2, and smartcards\nsudo cryptsetup luksAddKey /dev/disk/by-partlabel/luks /root/usb-luks.key\n```\n\n**OR**\n\n<details>\n<summary> ✔️ Click to expand Experimental TPM2 auto-unlock for LUKS </summary>\n\n> ⚠️ WARNING: Security Implications of TPM2 Auto-Unlock\n\n> Enabling TPM2 auto-unlock fundamentally changes your system's security model.\n> While this feature protects against certain forms of malicious software\n> injection by tying the decryption key to the system's boot state, it\n> eliminates the need for a user password at boot. This creates a significant\n> risk if your machine is stolen or seized, do not use this feature if the\n> physical security of your machine is a concern. This is still at a stage where\n> you can expect rough edges and workarounds.\n\n> ⚠️ WARNING: Do NOT use TPM auto-unlock if your CPU is vulnerable to faulTPM!\n> All AMD Zen2 and Zen3 Processors are known to be affected with AMD Zen1 likely\n> also affected and Zen4 unknown! Misconfigurations are also common, do your own\n> research!\n\n- [faulTPM:Exposing AMD fTPMs' Deepest Secrets](https://ieeexplore.ieee.org/document/10190531)\n\n- [AMD faulTPM Exploit Targets Zen 2 and Zen 3 Processors](https://www.techpowerup.com/308124/amd-faultpm-exploit-targets-zen-2-and-zen-3-processors)\n\nYou can add an additional layer by encrypting user data, such as individual home\nfolders, with a different mechanism, such as `fscrypt-experimental` or\n`systemd-homed`. Or, you can use a TPM pin to benefit from the security\nproperties of the TPM, while avoiding completely unattended unlocking.\n--[Arch Wiki](https://wiki.archlinux.org/title/Trusted_Platform_Module)\n\nI am reading that `fscrypt` is no longer experimental.\n\n```nix\nsecurity.pam.enableFscrypt = true;\n```\n\n```bash\nsudo fscrypt setup --all-users\nsudo mv /home/<user> /home/old<user>\nsudo mkdir /home/<user>\nsudo chown <user>:users /home/<user>\nsudo fscrypt encrypt --source pam_passphrase --user <user> --skip-unlock /home/<user>/\n```\n\n--☝️[Discourse](https://discourse.nixos.org/t/experienced-with-systemd-homed-or-other-encrypted-home/63516/2)\n\nIt is fairly complex as to how TPM2 auto-unlock can improve security in some\nways, it has to do with how Linux distributions fail to authenticate the boot\nprocess past the initrd.Even with encryption and Secure Boot enabled, the initrd\nstage often remains unverified, meaning a tampered initrd could be substituted\nwithout detection.\n\n- [Brave New Trusted Boot World](https://0pointer.net/blog/brave-new-trusted-boot-world.html)\n\nTPMs protect secrets by releasing them only if the boot process can be\nauthenticated through \"measurements.\" During boot, each component involved\n(firmware, bootloader, kernel, etc.) is hashed, and these hashes are extended\ninto special TPM registers called Platform Configuration Registers (PCRs). These\nPCRs hold a cumulative, tamper-evident record of the boot process state.\n\nIf any part of the boot sequence changes (even slightly), the PCR values will\ndiffer from the expected, causing the TPM to refuse to release the bound secret\n(such as a disk decryption key). This ensures that the system only boots or\nunlocks secrets when its software stack is known and trusted, providing strong\nprotection against tampering or unauthorized modifications. The values aren't\nonly protected by these PCRs but encrypted with a \"seed key\" that's generated on\nthe TPM chip itself, and cannot leave the TPM.\n\nCheck TPM support:\n\n```bash\ncat /sys/class/tpm/tpm0/device/description\nTPM 2.0 Device\n```\n\nCheck for necessary software dependencies:\n\n```bash\nsystemd-analyze has-tpm2\n```\n\nFind your encrypted partition with `lsblk`:\n\n```bash\nlsblk\n```\n\nFirst, you need to use the `systemd-cryptenroll` command to add a TPM2 key to\nyour encrypted LUKS partition. This process binds a key slot on your disk to the\nstate of your TPM2 chip's PCRs (Platform Configuration Registers).\n\n```bash\n# This command adds a new key to the LUKS volume, using a key generated by the TPM2 chip.\n# It binds the key to PCRs 0,2,7,and 15 ensuring the key is only released if the firmware\n# and Secure Boot state of your system is unchanged.\nsudo systemd-cryptenroll --tpm2-device=auto --tpm2-pcrs=0+2+7+15 /dev/disk/by-partlabel/luks\n```\n\nThere are quite a few options for the above command, some use the following with\nless pcrs and a wipe feature:\n\n```bash\nsudo systemd-cryptenroll --wipe-slot=tpm2 --tpm2-device=auto --tpm2-pcrs=0+7 /dev/disk/by-partlabel/luks\n```\n\n- Using less pcrs could prevent breakage but reduces security. Check out the PCR\n  Definitions below and decide if you require additional PCRs or less.\n\n- `wipe-slot` tells the system to delete any key associated with the TPM2 chip\n  from the LUKS volume's keyslot before adding a new one.\n\nYou can choose a more complex `--tpm2-pcrs` for more security but it makes the\nconfiguration more fragile because any legitimate system update altering any\nmeasured component tied to these PCRs will prevent the TPM from releasing the\nkey and lock you out, unless you re-enroll the key with the updated PCR values.\n\n- [PCR Definitions](https://uapi-group.org/specifications/specs/linux_tpm_pcr_registry/)\n\n- [Authenticated Boot and FDE](https://0pointer.net/blog/authenticated-boot-and-disk-encryption-on-linux.html)\n  This article explains the limitations and remedies very well.\n\nThat said, I do often see people mention a firmware update breaking their TPM2\nauto-unlock functionality. Keep this in mind and have a backup plan. This is\nalso incompatible with the encrypted impermanence setup shared in this book, the\n`boot.initrd.postDeviceCommands` conflict.\n\nChange `YourUser` to your username and ensure that `cryptroot` is the name of\nyours, if you followed this books encrypted disko install it should be:\n\n```nix\n  # Adds your user to the 'tss' group, allowing you to interact with the TPM\n  users.users.YourUser.extraGroups = [ \"tss\" ];\n  # Enables TPM2 services and tools on your system\n  security.tpm2.enable = true;\n  # Ensure the necessary kernel modules are in the initrd\n  boot.initrd.kernelModules = [\"tpm_tis\"];\n  # switches the initrd to a systemd-based environment, required for TPM2\n  boot.initrd.systemd.enable = true;\n  # ❗ Tell the initrd to use the TPM2 key for the encrypted root\n  boot.initrd.luks.devices.cryptroot = {\n    device = \"/dev/disk/by-partlabel/luks\";\n    # These options tell systemd-cryptsetup to automatically try to unlock the device\n    # using the TPM2 key. 'tpm2-measure=yes' ensures the PCRs are verified but only works if you use one disk\n    crypttabExtraOpts = [\"tpm2-device=auto\" \"tpm2-measure=yes\"];\n    fallbackToPassword = true;\n  };\n  environment.systemPackages = [ pkgs.tpm2-tss ];\n```\n\n> ❗ NOTE: `cryptroot` needs to match what your encrypted partition is named, I\n> have seen quite a few different names here.\n\nIf you use this, you can't also use the USB Keyfile or the included impermanence\nguide.\n\n</details>\n\n**Description**\n\n- `/dev/disk/by-partlabel/luks` refers to your encrypted partition by its\n  partition label, which is stable and less likely to change than\n  `/dev/nvme0n1p2`\n\n- `/root/usb-luks.key` is the keyfile we generated.\n\n- You'll be prompted to enter your existing LUKS passphrase to authorize adding\n  the new key.\n\n- Now our LUKS volume will accept both our existing passphrase and the new\n  keyfile (from the USB stick) for unlocking.\n\n1.  **Clear Data on USB stick and replace with 0's**\n\n```bash\nlsblk\nNAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS\nsda           8:0    1   239M  0 disk\nsdb           8:16   1   1.4M  0 disk  /run/media/jr/7CD1-149A # Example USB mount\nzram0       253:0    0   7.5G  0 disk  [SWAP]\nnvme0n1     259:0    0 476.9G  0 disk\n├─nvme0n1p1 259:1    0   512M  0 part  /boot\n└─nvme0n1p2 259:2    0 476.4G  0 part\n  └─cryptroot 254:0  0 476.4G  0 crypt /persist  # Main Btrfs mount\n                                               # (other subvolumes are within /persist and bind-mounted by impermanence)\n# unplug the device and run lsblk again so your sure\n```\n\n2. Before wiping you must unmount any mounted partitions:\n\n```bash\nsudo umount /dev/sda1\n```\n\n```bash\n# Overwrite with Zeros (fast, sufficient for most uses)\nsudo dd if=/dev/zero of=/dev/sda bs=4M status=progress\n# Or overwrite with Random Data (More Secure, Slower)\nsudo dd if=/dev/urandom of=/dev/sda bs=4M status=progress\n# Or for the most secure way run multiple passes of\nsudo shred -v -n 3 /dev/sda\n```\n\n3. Create a New Partition and Format (Optional)\n\n```bash\nsudo fdisk /dev/sda\n```\n\n1.  Press `o` to create a new empty DOS partition table (if you are creating\n    partitions on a fresh disk or want to wipe existing partitions and start\n    over). Be very careful with this step as it will erase all existing\n    partition information on the disk.\n\n2.  Press `n` to create a new partition.\n\n- You will then be prompted for the partition type:\n  - `p` for a primary partition (you can have up to 4 primary partitions)\n\n  - `e` for an extended partition (which can contain logical partitions)\n\n- Next, you'll be asked for the partition number (e.g., 1, 2, 3, 4).\n\n- Then, you'll be asked for the first sector (press Enter to accept the default,\n  which is usually the first available sector after the previous partition or\n  the beginning of the disk).\n\n- Finally, you'll be asked for the last sector or size (you can specify a size\n  like +10G for 10 Gigabytes, +512M for 512 Megabytes, or press Enter to use the\n  rest of the available space).\n\n3. Press `w` to write the changes to the partition table and exit fdisk.\n\nAfter pressing `w`, the kernel needs to be aware of the new partition table.\nSometimes this happens automatically, but if you encounter issues, a reboot or a\ncommand like `partprobe` (if available and needed) can help.\n\nFormats as FAT32:\n\n```bash\nsudo mkfs.vfat /dev/sda1\n# or as ext4\nsudo mkfs.ext4 /dev/sda1\n```\n\nI chose `vfat` so I ran `sudo mkfs.vfat /dev/sda1`. In my case this changed the\ndevice path to `/run/media/jr/7CD1-149A` so it's important to find your own UUID\nwith the following command:\n\n```bash\nsudo blkid /dev/sda1\n/dev/sda1: SEC_TYPE=\"msdos\" UUID=\"B7B4-863B\" BLOCK_SIZE=\"512\" TYPE=\"vfat\" PARTUUID=\"7d1f9d7f-01\"\n```\n\n- As you can see the above UUID is `\"B7B4-863B\"`\n\n- Remove and re-insert the USB stick, this ensures the system recognizes the new\n  partition and filesystem.\n\n4. Copy the keyfile to your USB Stick\n\n```bash\nsudo cp /root/usb-luks.key /run/media/jr/B7B4-863B/\nsync\n```\n\n5. Update your NixOS Configuration\n\nNote the output of `blkid /dev/sda1` and if you have a backup device list that\nalso:\n\nThe following is from the wiki edited for my setup, it was created by Tzanko\nMatev:\n\n```nix\nlet\n  PRIMARYUSBID = \"B7B4-863B\";\n  BACKUPUSBID = \"Ventoy\";\nin {\n\n  boot.initrd.kernelModules = [\n    \"uas\"\n    \"usbcore\"\n    \"usb_storage\"\n    \"vfat\"\n    \"nls_cp437\"\n    \"nls_iso8859_1\"\n  ];\n\n  boot.initrd.postDeviceCommands = lib.mkBefore ''\n    mkdir -p /key\n    sleep 2\n    mount -n -t vfat -o ro $(findfs UUID=${PRIMARYUSBID}) /key || \\\n    mount -n -t vfat -o ro $(findfs UUID=${BACKUPUSBID}) /key || echo \"No USB key found\"\n  '';\n\n  boot.initrd.luks.devices.cryptroot = {\n    device = \"/dev/disk/by-partlabel/luks\";\n    keyFile = \"/key/usb-luks.key\";\n    fallbackToPassword = true;\n    allowDiscards = true;\n    preLVM = false; # Crucial!\n  };\n}\n```\n\nIf you have issues or just want to remove the key take note of the path used to\nadd it so you don't have to enter the whole key:\n\n```bash\nsudo cryptsetup luksRemoveKey /dev/disk/by-partlabel/luks --key-file /root/usb-luks.key\n```\n\n6. Securely Remove the Keyfile from Your System:\n\n```bash\nsudo shred --remove --zero /root/usb-luks.key\n```\n\n## Instructions for Using a USB Stick with Existing Data\n\n1. Generate the Keyfile\n\n```bash\nsudo dd if=/dev/urandom of=/root/usb-luks.key bs=4096 count=1\n```\n\n2. Add the Keyfile to your LUKS Volume\n\n```bash\nsudo cryptsetup luksAddKey /dev/disk/by-partlabel/luks /root/usb-luks.key\n```\n\n(enter your existing passphrase when prompted)\n\n3. Copy the Keyfile to the USB Stick\n\n- Plug in the USB Stick and note its mount point\n  (e.g.,`/run/media/$USER/YourLabel`)\n\n- Copy the keyfile:\n\n```bash\nsudo cp /root/usb-luks.key /run/media/$USER/YourLabel/\nsync\n```\n\n- You run the above as 2 commands, the second being `sync`.\n\n- You can rename it if you wish (e.g., `luks.key`)\n\n4. Securely Delete the Local Keyfile\n\n```bash\nsudo shred --remove --zero /root/usb-luks.key\n```\n\n- You need to ensure the keyfile is accessible in the initrd. Since automounting\n  (like `/run/media/...`) does not happen in `initrd`, you must manually mount\n  the USB in the `initrd` using its `UUID` or label.\n\nFind the USB Partition UUID:\n\n```bash\nlsblk -o NAME,UUID\n# or\nblkid /dev/sda1\n```\n\nSuppose the UUID is `B7B4-863B`\n\nAdd to your `configuration.nix`:\n\n```nix\nboot.initrd.kernelModules = [ \"usb_storage\" \"vfat\" \"nls_cp437\" \"nls_iso8859_1\" ];\n\nboot.initrd.postDeviceCommands = lib.mkBefore ''\n  mkdir -p /key\n  sleep 1\n  mount -n -t vfat -o ro $(findfs UUID=B7B4-863B) /key || echo \"USB not found\"\n'';\n\nboot.initrd.luks.devices.cryptroot = {\n  device = \"/dev/disk/by-partlabel/luks\";\n  keyFile = \"/key/usb-luks.key\"; # or whatever you named it\n  fallbackToPassword = true;\n  allowDiscards = true;\n};\n```\n","number":[3,2],"sub_items":[],"path":"installation/enc/USB_keyfile.md","source_path":"installation/enc/USB_keyfile.md","parent_names":["Encrypted Setups"]}},{"Chapter":{"name":"Sops-Nix encrypted secrets","content":"# Sops-Nix encrypted secrets\n\n<details>\n<summary> Click to Expand Table of Contents</summary>\n\n<!-- toc -->\n\n</details>\n\n[SOPS](https://github.com/getsops/sops?ref=blog.gitguardian.com), short for\n**S**ecrets**OP**eration**S**, is an editor of encrypted files that supports\nquite a few BINARY formats and encrypts with AWS KMS, GCP KMS, Azure Key Vault,\nage, and PGP.\n\nManaging secrets—like API keys, SSH deploy keys, and password hashes is a\ncritical part of system configuration, but it’s also one of the trickiest to do\nsecurely and reproducibly. Traditionally, secrets might be stored in ad hoc\nlocations, referenced by absolute paths, or managed manually outside of version\ncontrol. This approach makes it hard to share, rebuild, or audit your\nconfiguration, and increases the risk of accidental leaks or inconsistencies\nbetween systems.\n\n`sops-nix` solves these problems by integrating Mozilla SOPS directly into your\nNixOS configuration. Instead of relying on hardcoded file paths or copying\nsecrets around, you declare your secrets in your Nix code, encrypt them with\nstrong keys, and let `sops-nix` handle decryption and placement at activation\ntime.\n\nEncryption with strong keys, as used by sops-nix, makes brute force attacks\ncomputationally unfeasible with current technology—the time and resources\nrequired to try every possible key would be astronomically high. However, this\nprotection relies on using strong, secret keys and good security practices;\nadvances in technology or poor key management can weaken this defense.\n\n> ❗ **CRITICAL SECURITY NOTE:** While the encryption itself is robust, this\n> protection fundamentally relies on using **strong, secret keys** and\n> **diligent security practices**. If your PGP passphrase is weak, your Age\n> private key is easily guessable, or the cleartext secret itself is very short\n> and has low entropy (e.g., \"12345\", \"true\", \"admin\"), an attacker might be\n> able to compromise your secrets regardless of the encryption.\n\n1. Add sops to your `flake.nix`:\n\n```nix\n{\n  inputs.sops-nix.url = \"github:Mic92/sops-nix\";\n  inputs.sops-nix.inputs.nixpkgs.follows = \"nixpkgs\";\n\n  outputs = { self, nixpkgs, sops-nix }: {\n    # change `yourhostname` to your actual hostname\n    nixosConfigurations.yourhostname = nixpkgs.lib.nixosSystem {\n      # customize to your system\n      system = \"x86_64-linux\";\n      modules = [\n        ./configuration.nix\n        sops-nix.nixosModules.sops\n      ];\n    };\n  };\n}\n```\n\n2. Add `sops` and `age` to your `environment.systemPackages`:\n\n```nix\nenvironment.systemPackages = [\n    pkgs.sops\n    pkgs.age\n];\n```\n\n3. Generate a key (This is your **private key** and **MUST NEVER BE COMMITTED TO\n   GIT OR SHARED**):\n\n```bash\nmkdir -p ~/.config/sops/age\nage-keygen -o ~/.config/sops/age/keys.txt\n```\n\nTo get the Public Keys Value, run the following command:\n\n```bash\nage-keygen -y ~/.config/sops/age/keys.txt\nage12zlz6lvcdk6eqaewfylg35w0syh58sm7gh53q5vvn7hd7c6nngyseftjxl\n```\n\nCopy the `age` value it gives you back.\n\n4. Create a `.sops.yaml` in the same directory as your `flake.nix`:\n\n```yaml\n# .sops.yaml\nkeys:\n  # Your personal age public key (from age-keygen -y ~/.config/sops/age/keys.txt)\n  - &personal_age_key age12zlz6lvcdk6eqaewfylg35w0syh58sm7gh53q5vvn7hd7c6nngyseftjxl\n\n  # You can also use PGP keys if you prefer, but age is often simpler\n  # - &personal_pgp_key 0xDEADBEEFCAFE0123\n\ncreation_rules:\n  # This rule applies to any file named 'secrets.yaml' directly in the 'secrets/' directory\n  # or 'secrets/github-deploy-key.yaml' etc.\n  - path_regex: \"secrets/.*\\\\.yaml$\"\n    key_groups:\n      - age:\n          - *personal_age_key\n        # Add host keys for decryption on the target system\n        # sops-nix will automatically pick up the system's SSH host keys\n        # as decryption keys if enabled in your NixOS config.\n        # So you typically don't list them explicitly here unless you\n        # want to restrict it to specific fingerprints, which is rare.\n        # This part ensures your *personal* key can decrypt it.\n```\n\nSave it and move on, this file and `sops.nix` are safe to version control.\n\n5. sops-nix's automatic decryption feature using system SSH host keys only works\n   with ed25519 host keys for deriving Age decryption keys. Therefore, for\n   system decryption, ensure your using ed25519 not rsa keys:\n\n```bash\nssh-keygen -t ed25519 -C \"your_email@example.com\"\n# for multiple keys run something like\nssh-keygen -t ed25519 -f ~/nix-book-deploy-key -C \"deploy-key-nix-book-repo\"\n```\n\n6. Copy the **PRIVATE** key for each and add them to your secrets directory:\n\nWhile in your flake directory:\n\n```bash\nmkdir secrets\nsops secrets/github-deploy-key.yaml  # For your github ssh key\n```\n\nWhen you call a `sops` command, it will handle the encryption/decryption\ntransparently and open the cleartext file in an editor.\n\nEditing will happen in the editor that `$SOPS_EDITOR` or `$EDITOR` is set to,\nsops will wait for the editor to exit, and then try to reencrypt the file.\n\nThe above command will open a default sops `github-deploy-key.yaml` in your\n`$EDITOR`:\n\nErase the default `sops` filler and type `github_deploy_key_ed25519: |`, move\nyour cursor 1 line down and type `:r ~/.ssh/id_ed25519` to read the private key\ninto the file and repeat as needed.\n\n```yaml\ngithub_deploy_key_ed25519: |\n  -----BEGIN OPENSSH PRIVATE KEY-----\n  ...\n  -----END OPENSSH PRIVATE KEY-----\n\ngithub_deploy_key_ed25519_nix-book: |\n  -----BEGIN OPENSSH PRIVATE KEY-----\n  ...\n  -----END OPENSSH PRIVATE KEY-----\n```\n\nThe `-----BEGIN` and the rest of the private key **must** be indented 2 spaces\n\nEnsure sops can decrypt it:\n\n```bash\nsops -d secrets/github-deploy-key.yaml\n```\n\n> ❗ WARNING: Only ever enter your private keys through the `sops` command. If\n> you forget and paste them in without the `sops` command then run `git add` at\n> any point, your git history will have contained an unencrypted secret which is\n> a nono. Always use the `sops` command when dealing with files in the `secrets`\n> directory, save the file and inspect that it is encrypted on save. If not\n> something went wrong with the `sops` process, **do not add it to Git**. If you\n> do, you will be required to rewrite your entire history which can be bad if\n> you're collaborating with others. `git-filter-repo` is one such solution that\n> rewrites your history. Just keep this in mind. This happens because Git has a\n> protection that stops you from doing stupid things.\n\nGenerate an encrypted password hash with:\n\n```bash\nmkpasswd --method=yescrypt > /tmp/password-hash.txt\n# Enter your chosen password and copy the encrypted hash it gives you back\n```\n\n```bash\nsops secrets/password-hash.yaml      # For your `hashedPasswordFile`\n```\n\nThe above command will open your `$EDITOR` with the file `password-hash.yaml`,\nadd the following content to it. Replace `PasteEncryptedHashHere` with the\noutput of the `mkpasswd` command above:\n\nDelete the default `sops` filler, type `password_hash:` and leave your cursor\nafter the `:` and type `:r /tmp/password-hash.txt`\n\n```yaml\npassword_hash: PasteEncryptedHashHere\n```\n\nEnsure sops can decrypt it:\n\n```bash\nsops -d secrets/password-hash.yaml\n```\n\n7. Create a `sops.nix` and import it or add this directly to your\n   `configuration.nix`:\n\nMy `sops.nix` is located at `~/flake/hosts/hostname/sops.nix` and the secrets\ndirectory is located at `~/flake/secrets` so the path from `sops.nix` to\n`secrets/pasword-hash.yaml` would be `../../secrets/password-hash.yaml`\n\nAnother step you can take is to copy your key to a persistent location,\npreparing for impermanence:\n\n```bash\nsudo mkdir /persist/sops/age\nsudo cp ~/.config/sops/age/keys.txt /persist/sops/age/keys.txt\n```\n\nThen you would change the `age.keyFile = \"/persist/sops/age/keys.txt\"` to match\nthis location below.\n\n```nix\n# ~/flake/hosts/magic/sops.nix  # magic is my hostname\n# hosts/magic/ is also where my configuration.nix is\n{...}: {\n  sops = {\n    defaultSopsFile = ../../.sops.yaml; # Or the correct path to your .sops.yaml\n    # Don't mix sshKeyPaths and keyFile\n    age.sshKeyPaths = [];\n    age.keyFile = \"/persist/sops/age/keys.txt\";\n\n    secrets = {\n      \"password_hash\" = {\n        sopsFile = ../../secrets/password-hash.yaml; # <-- Points to your password hash file\n        owner = \"root\";\n        group = \"root\";\n        mode = \"0400\";\n        neededForUsers = true;\n      };\n      \"github_deploy_key_ed25519_nix-book\" = {\n        sopsFile = ../../secrets/github-deploy-key.yaml;\n        key = \"github_deploy_key_ed25519_nix-book\";\n        owner = \"root\";\n        group = \"root\";\n        mode = \"0400\";\n      };\n      \"github_deploy_key_ed25519\" = {\n        sopsFile = ../../secrets/github-deploy-key.yaml;\n        key = \"github_deploy_key_ed25519\";\n        owner = \"root\";\n        group = \"root\";\n        mode = \"0400\";\n      };\n    };\n  };\n}\n```\n\nImport `sops.nix` into your `configuration.nix` or equivalent:\n\n```nix\n# configuration.nix\nimports = [\n  ./sops.nix # Assuming sops.nix is in the same directory as configuration.nix, adjust path as needed\n  # ... other imports\n];\n```\n\n> ❗ NOTE: You may see in the sops quickstart guide that if you're using\n> impermanence, the key used for secret decryption (`sops.age.keyFile`) must be\n> in a persistent directory, loaded early enough during the boot process. If you\n> are using the btrfs subvolume layout you don't need to worry about this\n> because your home will be on its own partition when only the root partition is\n> wiped on reboot. Adding `neededForUsers = true;` tells `sops-nix` to decrypt\n> and make that secret available earlier in the boot process specifically,\n> before user and group accounts are created.\n\nYou typically use `age.sshKeyPaths` for **system-level secrets** with a\npersistent SSH host key\n\nFor **user-level secrets**, use `age.keyFile` pointing to your Age private key,\nstored in a safe persistent location.\n\nFor reproducibility, keep your key files in a persistent, predictable path and\ndocument which keys are used for which secrets in your `.sops.yaml`.\n\nIf you don't need both `age.keyFile` and `age.sshKeyPaths` it can reduce\ncomplexity to use one or the other. Although most people may choose one, it's\nnot bad to use both it just adds complexity.\n\nAnd finally use the password-hash for your `hashedPasswordFile` for your user,\nmy user is `jr` so I added this:\n\n```nix\n# ... snip ...\n    users.users = {\n      # ${username} = {\n      jr = {\n        homeMode = \"755\";\n        isNormalUser = true;\n        # description = userVars.gitUsername;\n        hashedPasswordFile = config.sops.secrets.password_hash.path;\n  # ...snip...\n```\n\nBy integrating SOPS with NixOS through `sops-nix`, you gain a modern, secure,\nand reproducible way to manage sensitive secrets. Unlike traditional approaches\nwhere secrets are often scattered in ad hoc locations, referenced by absolute\npaths, or managed outside version control, `sops-nix` keeps your secrets\nencrypted, declarative, and version-control friendly.\n","number":[3,3],"sub_items":[],"path":"installation/enc/sops-nix.md","source_path":"installation/enc/sops-nix.md","parent_names":["Encrypted Setups"]}},{"Chapter":{"name":"Secure Boot with Lanzaboote","content":"# Secure Boot with Lanzaboote\n\n<details>\n<summary> Click to Expand Table of Contents</summary>\n\n<!-- toc -->\n\n</details>\n\n⚠️ **Warning: This can easily brick your system** ⚠️\n\nWe will mainly follow the lanzaboote\n[Quick Start Guide](https://github.com/nix-community/lanzaboote/blob/master/docs/QUICK_START.md)\n\nFor Windows dual-booters and BitLocker users, you should export your BitLocker\nrecovery keys and confirm that they are correct. Refer to this\n[Microsoft support article](https://support.microsoft.com/en-us/windows/find-your-bitlocker-recovery-key-6b71ad27-0b89-ea08-f143-056f5ab347d6)\n\n> ❗ NOTE: There are some serious limitations to this setup when used without\n> encryption, I'd say it could stop the average person. But an experienced\n> hacker could easily bypass this without encryption if they had access to your\n> computer. For more protection look into TPM2 Hardware Requirements, and full\n> disk encryption.\n\n## Important Considerations\n\nI found\n[This Article](https://0pointer.net/blog/authenticated-boot-and-disk-encryption-on-linux.html)\nfairly enlightening as far as the state of Authenticated Boot and Disk\nEncryption on Linux.\n\n- [Brave New Trusted Boot World](https://0pointer.net/blog/brave-new-trusted-boot-world.html)\n\nLanzaboote only secures the boot chain. The userspace remains unverified (i.e.,\nthe nix store, etc.), to verify userspace you need to implement additional\nintegrity checks. It's common to rely to disk encryption to prevent tampering\nwith and keep the Nix store safe but it's not always desirable. (i.e.,\nunattended boot)\n\n## Requirements\n\nTo be able to setup Secure Boot on your device, NixOS needs to be installed in\nUEFI mode and systemd-boot must be used as a boot loader. This means if you wish\nto install lanzaboote on a new machine, you need to follow the install\ninstruction for systemd-boot and then switch to lanzaboote after the first boot.\n\nCheck these prerequisits with `bootctl status`, this is an example output:\n\n```bash\nsudo bootctl status\nSystem:\n     Firmware: UEFI 2.70 (Lenovo 0.4720)\n  Secure Boot: disabled (disabled)\n TPM2 Support: yes\n Boot into FW: supported\n\nCurrent Boot Loader:\n      Product: systemd-boot 251.7\n...\n```\n\nThe firmware **must** be `UEFI` and the current bootloader needs to be\n`systemd-boot`. If you check these boxes, you're good to go.\n\n## Security Requirements\n\nTo provide any security your system needs to defend against an attacker turning\nUEFI Secure Boot off or being able to sign binaries with the keys we are going\nto generate.\n\nThe easiest way to achieve this is to:\n\n1. Enable a BIOS password for your system, this will prevent someone from just\n   shutting off secure boot.\n\n2. Use full disk encryption.\n\n## Preparation\n\n**Finding the UEFI System Partition (ESP)**\n\nThe UEFI boot process revolves around the ESP, the (U)EFI System Partition. This\npartition is conventionally mounted at `/boot` on NixOS.\n\nVerify this with the command `sudo bootctl status`. Look for `ESP:`\n\n**Creating Your Keys**\n\nFirst you'll need to install `sbctl` which is available in `Nixpkgs`:\n\n```nix\n# configuration.nix or equivalent\nenvironment.systemPackages = [ pkgs.sbctl ];\n```\n\nCreate the keys:\n\n```bash\n$ sudo sbctl create-keys\n[sudo] password for julian:\nCreated Owner UUID 8ec4b2c3-dc7f-4362-b9a3-0cc17e5a34cd\nCreating secure boot keys...✓\nSecure boot keys created!\n```\n\nIf you already have keys in `/etc/secureboot` migrate these to `/var/lib/sbctl`:\n\n```bash\nsbctl setup --migrate\n```\n\n## Configuring Lanzaboote With Flakes\n\nShown all in `flake.nix` for brevity. Can easily be split up into a `boot.nix`,\netc:\n\n```nix\n{\n  description = \"A SecureBoot-enabled NixOS configurations\";\n\n  inputs = {\n    nixpkgs.url = \"github:NixOS/nixpkgs/nixos-unstable\";\n\n    lanzaboote = {\n      url = \"github:nix-community/lanzaboote/v0.4.2\";\n\n      # Optional but recommended to limit the size of your system closure.\n      inputs.nixpkgs.follows = \"nixpkgs\";\n    };\n  };\n\n  outputs = { self, nixpkgs, lanzaboote, ...}: {\n    nixosConfigurations = {\n      yourHost = nixpkgs.lib.nixosSystem {\n        system = \"x86_64-linux\";\n\n        modules = [\n          # This is not a complete NixOS configuration and you need to reference\n          # your normal configuration here.\n\n          lanzaboote.nixosModules.lanzaboote\n\n          ({ pkgs, lib, ... }: {\n\n            environment.systemPackages = [\n              # For debugging and troubleshooting Secure Boot.\n              pkgs.sbctl\n            ];\n\n            # Lanzaboote currently replaces the systemd-boot module.\n            # This setting is usually set to true in configuration.nix\n            # generated at installation time. So we force it to false\n            # for now.\n            boot.loader.systemd-boot.enable = lib.mkForce false;\n\n            boot.lanzaboote = {\n              enable = true;\n              pkiBundle = \"/var/lib/sbctl\";\n            };\n          })\n        ];\n      };\n    };\n  };\n}\n```\n\n**Build it**\n\n```bash\nsudo nixos-rebuild switch --flake /path/to/flake\n```\n\n### Ensure Your Machine is Ready for Secure Boot enforcement\n\n```bash\n$ sudo sbctl verify\nVerifying file database and EFI images in /boot...\n✓ /boot/EFI/BOOT/BOOTX64.EFI is signed\n✓ /boot/EFI/Linux/nixos-generation-355.efi is signed\n✓ /boot/EFI/Linux/nixos-generation-356.efi is signed\n✗ /boot/EFI/nixos/0n01vj3mq06pc31i2yhxndvhv4kwl2vp-linux-6.1.3-bzImage.efi is not signed\n✓ /boot/EFI/systemd/systemd-bootx64.efi is signed\n```\n\n### Enabling Secure Boot and Entering Setup Mode\n\nThis is where things can get tricky because UEFI/BIOS are widely different and\nuse different conventions.\n\nYou can see your BIOS from the output of `bootctl status`:\n\n```bash\nsudo bootctl status\ndoas (jr@magic) password:\nSystem:\n      Firmware: UEFI 2.70 (American Megatrends)\n```\n\nMy UEFI is an American Megatrends, find yours and look up which key you have to\nhit to enter the BIOS on reboot, mine is the delete key. So I reboot and\nrepeatedly hit delete until it brings up the BIOS settings.\n\nThe lanzaboote guide shows a few systems and how to enter setup mode for them.\n\nFor a ThinkPad the steps are:\n\n1. Select the \"Security\" tab.\n\n2. Select the \"Secure Boot\" entry.\n\n3. Set \"Secure Boot\" to enabled.\n\n4. Select \"Reset to Setup Mode\".\n\n---\n\nFor my system, it would allow me to do the above steps but when I saved and\nexited I got a red screen then blue screen and it said No Valid Keys or\nsomething like that and eventually brought me to the MOK Manager where you can\nmanually register keys, this is NOT what you want to do.\n\nEven after this mistake I was able to re-enable secure boot and get back into\nthe system.\n\nAfter some tinkering, I found that I was able to enter \"custom mode\" without\nenabling secure boot, which in turn allowed me to select the \"Reset to Setup\nMode\"\n\nIt asks if you are sure you want to erase all of the variables to enter setup\nmode? Hit \"Yes\". Then it asks if you want to exit without saving, we want to\nsave our changes so hit \"No\" do not exit without saving.\n\nAfter this you should see all No Keys entries.\n\nFinally, Hit the setting to save and exit, some BIOS list an F4 or F9 keybind\nthat saves and exits.\n\n> ❗: For my system, choosing \"save and reboot\" would not work for some reason,\n> I had to choose \"save and exit\".\n\nAfter hitting \"save and exit\", the system boots into NixOS like normal but you\nare in setup mode if everything worked correctly.\n\nOpen a terminal and type:\n\n```bash\nsudo sbctl enroll-keys --microsoft\nEnrolling keys to EFI variables...\nWith vendor keys from microsoft...✓\nEnrolled keys to the EFI variables!\n```\n\n> ⚠️ If you used `--microsoft` while enrolling the keys, you might want to check\n> that the Secure Boot Forbidden Signature Database (dbx) is not empty. A quick\n> and dirty way is by checking the file size of\n> `/sys/firmware/efi/efivars/dbx-\\*`. Keeping an up to date dbx reduces Secure\n> Boot bypasses, see for example:\n> <https://uefi.org/sites/default/files/resources/dbx_release_info.pdf>\n\nI then Rebooted into BIOS and enabled secure boot, saved and exited. This loads\nNixOS as if you just rebooted.\n\nAnd finally check the output of `sbctl status`:\n\n```bash\nsudo sbctl status\nSystem:\n      Firmware: UEFI 2.70 (American Megatrends)\n Firmware Arch: x64\n   Secure Boot: enabled (user)\n  TPM2 Support: yes\n  Measured UKI: yes\n  Boot into FW: supported\n```\n\nWe can see the `Secure Boot: enabled (user)`\n\n## What Lanzaboote (Secure Boot) Actually Secures on NixOS and Limitations\n\nAs mentioned earlier, this provides some basic protection that may be good\nenough for your desktop in your bedroom but there are some serious limitations.\nI want to be clear that this may stop an average person but an advanced threat\nactor with resources could still fairly easily get in.\n\nSecure Boot (with Lanzaboote or any other tool) on NixOS primarily protects the\nboot chain—the bootloader, kernel, and initrd—by ensuring only signed, trusted\nbinaries are executed at boot. This is a real and valuable security improvement,\nespecially for defending against “evil maid” attacks (where someone with\nphysical access tampers with your bootloader or kernel) and for preventing many\nforms of persistent malware.\n\nHere are some of the caveats:\n\n1. Userspace Remains Unverified\n\n   Once the kernel and initrd have booted, NixOS (by default) does not\n   cryptographically verify the integrity of the rest of userspace (the programs\n   and libraries in the Nix store, your configs, etc.).\n\n   This means an attacker who can modify userspace (e.g., by gaining root\n   access) can potentially install persistent malware, even if your boot chain\n   is protected\n\n   .\n\n2. Kernel Lockdown Is Not Enabled\n\n   The Linux kernel’s [lockdown mode]\n\n   is designed to prevent even root from tampering with the kernel at runtime\n   (e.g., by loading unsigned modules, using kexec, or accessing /dev/mem).\n\n   NixOS does not enable kernel lockdown by default, and enabling it is\n   non-trivial, especially given how the Nix store works (modules and kernels\n   are built dynamically and not always signed at install time).\n\n   Without lockdown, a root user (or malware with root) can still compromise the\n   kernel after boot.\n\n3. Stage 2 Verification Is Lacking\n\n   Some distributions (like Fedora Silverblue or systems using dm-verity)\n   cryptographically verify the entire userspace at boot, making it immutable\n   and much harder to tamper with. This is not the default on NixOS, though\n   there are experimental or appliance-focused solutions\n\n   .\n\n4. Disk Encryption Complements Secure Boot\n\n   Full disk encryption (e.g., LUKS) is strongly recommended alongside Secure\n   Boot. Encryption protects your data at rest and ensures that even if someone\n   bypasses Secure Boot, they cannot read or modify your files without your\n   passphrase\n","number":[3,4],"sub_items":[],"path":"installation/enc/lanzaboote.md","source_path":"installation/enc/lanzaboote.md","parent_names":["Encrypted Setups"]}}],"path":"installation/enc/enc_install.md","source_path":"installation/enc/enc_install.md","parent_names":[]}},{"Chapter":{"name":"Understanding Nix Functions","content":"---\ntitle: My Chapter\ndate: 2025-11-21\nauthor: saylesss88\ndescription: Chapter 2\n---\n\n# Chapter 2\n\n<details>\n<summary> ✔️ Click to Expand Table of Contents</summary>\n\n<!-- toc -->\n\n</details>\n\n<!-- <img src=\"images/nixLogo.png\" width=\"400\" height=\"300\"> -->\n\n![trees2](images/trees2.cleaned.png)\n\n## Understanding Nix Functions\n\n**Functions** are the building blocks of Nix, appearing everywhere in Nix\nexpressions and configurations. Mastering them is essential for writing\neffective Nix code and understanding tools like NixOS and Home Manager. This\nchapter explores how Nix functions work, focusing on their **single-argument\nnature**, **currying**, **partial application**, and their role in **modules**.\n\n## What are Nix Functions?\n\nA **Nix Function** is a rule that takes an input (called an **argument**) and\nproduces an **output** based on that input. Unlike many programming languages,\nNix functions are designed to take exactly one argument at a time. This unique\napproach, combined with a technique called currying, allows Nix to simulate\nmulti-argument functions in a flexible and reusable way.\n\n## Builtins\n\n<details>\n<summary> ✔️ Nix Builtin Functions (Click to Expand)</summary>\n\nThe Nix expression evaluator has a bunch of functions and constants built in:\n\n- `toString e`: (Convert the expression `e` to a string)\n\n- `import path`: (Load, parse and return the Nix expression in the file `path`)\n\n- `throw x`: (Throw an error message `x`. Usually stops evaluation)\n\n- `map f list`: (Apply the function `f` to each element in the `list`)\n\n- [Built-in Functions](https://nix.dev/manual/nix/2.18/language/builtins)\n\n- [Nix Operators](https://nix.dev/manual/nix/2.26/language/operators)\n\n</details>\n\n## Lambdas\n\nNix functions are anonymous (lambdas) (e.g., `x: x + 2`), and technically take a\nsingle parameter. However, that single parameter is very often an attribute set,\nallowing you to effectively pass multiple named inputs by destructuring (e.g.,\n`{ arg1, arg2 }: arg1 + arg2`).\n\nType the parameter name, followed by a colon, and finally the body of the\nfunction.\n\n```nix\nnix-repl> param: param * 2\n<<lambda @ <<string>>:1:1>>\n\nnix-repl> (param: param * 2) 2\n4\n```\n\nThe above example shows that everything in Nix returns a value. When you call a\nfunction directly (without first assigning the function itself to a variable),\nthe result of that call is immediately evaluated and displayed/used.\n\nIn order to make our function reusable and be able to pass different values at\ndifferent times we have to assign our function to a variable:\n\n```nix\nnix-repl> twoTimes = param: param * 2\n```\n\nNow, we can reference our function by it's name and pass our required parameter:\n\n```nix\nnix-repl> twoTimes\n«lambda @ «string»:1:2»\nnix-repl> twoTimes 2\n4\nnix-repl> twoTimes 4\n8\n```\n\nWe defined a function `param: param * 2` takes one parameter `param`, and\nreturns `param * 2`. We then assigned this function to the variable `twoTimes`.\nLastly, we called the function with a few different arguments showing it's\nreusability.\n\n## Understanding Function Structure: The Role of the Colon\n\nThe colon (`:`) acts as a clear separator within a function definition:\n\n- **Left of the Colon:** This is the function's **argument**. It's a placeholder\n  name for a value that will be provided when the function is called.\n\n- **Right of the Colon:** This is the **function body**. It's the expression\n  that will be evaluated when the function is invoked.\n\n**Think of function arguments as naming values that aren't known in advance.**\nThese names are placeholders that get filled with specific values when the\nfunction is used.\n\n**Example:**\n\n```nix\ngreet = personName: \"Hello, ${personName}!\";\n```\n\n- Here, `personName` is the **argument** (the placeholder).\n\n- `\"Hello, ${personName}!\"`, is the **function body** (which uses the\n  placeholder to create the greeting).\n\nWhen you call the function, (click to see Output):\n\n```nix\ngreet \"Anonymous\"\n~ \"Hello, Anonymous!\"\n```\n\n- The value `\"Anonymous\"` is substituted for the `personName` placeholder within\n  the function body.\n\n- This structure is the foundation of all Nix functions, whether simple or\n  complex.\n\n### Single-Argument Functions: The Basics\n\nThe simplest form of a Nix function takes a single argument. In Nix, function\ndefinitions like `x: x + 1` or `personName: \"Hello, ${personName}!\";` are\n**anonymous lambda functions**. They exist as values until they are assigned to\na variable.\n\n- Click to see Output:\n\n```nix\n# This is an anonymous lambda function value:\n# x: x + 1\ninc = x: x + 1;          # here we assigned our lambda to a variable `inc`\ninc 5\n~ 6\n```\n\n- `x` is the argument.\n\n- `x + 1` is the function body.\n\nThis straightforward design makes single-argument functions easy to understand\nand use. But what if you need a function that seems to take multiple arguments?\nThat's where **currying** comes in.\n\n### Simulating Multiple Arguments: Currying\n\nTo create functions that appear to take multiple arguments, Nix uses currying.\nThis involves nesting single-argument functions, where each function takes one\nargument and returns another function that takes the next argument, and so on.\n\n```nix\nnix-repl> multiply = x: (y: x*y)\nnix-repl> multiply\n«lambda»\nnix-repl> multiply 4\n«lambda»\nnix-repl> (mul 4) 5\n20\n```\n\nWe defined a function that takes the parameter `x`, the body returns another\nfunction. This other function takes a parameter `y` and returns `x*y`.\nTherefore, calling `multiply 4` returns a function like: `x: 4*y`. In turn, we\ncall the returned function with `5`, and get the expected result.\n\n#### Currying example 2\n\n```nix\n# concat is equivalent to:\n# concat = x: (y: x + y);\nconcat = x: y: x + y;\nconcat 6 6    # Evaluates to 12\n12\n```\n\nHere, `concat` is actually **two nested functions**\n\n1. The **first function** takes `x` and returns another function.\n\n2. The **second function** takes `y` and performs `x + y`\n\nNix interprets the colons (`:`) as separators for this chain of single-argument\nfunctions.\n\nHere's how it works step by step:\n\n- When you call `concat 6`, the outer function binds `x` to `6` and returns a\n  new function: `y: 6 + y`.\n\n- When you call that function with `6` (i.e., `concat 6 6`), it computes\n  `6 + 6`, resulting in `12`.\n\nThis chaining is why Nix functions are so powerful—it allows you to build\nflexible, reusable functions.\n\nCurrying is a powerful feature in Nix that enables you to partially apply\narguments to functions, leading to increased reusability. This behavior is a\ndirect consequence of Nix functions being \"first-class citizens\" (a concept\nwe'll delve into later), and it proves invaluable for decomposing intricate\nlogic into a series of smaller, more focused functions.\n\n**Key Insight**: Every colon in a function definition separates a **single\nargument** from its **function body**, even if that body is another function\ndefinition.\n\n#### Greeting Example\n\nLet's explore currying with a more relatable example in the `nix repl`:\n\n```nix\nnix repl\nnix-repl> greeting = prefix: name: \"${prefix}, ${name}!\";\n\nnix-repl> greeting \"Hello\"\n<<lambda @ <<string>>:1:10>> # partial application returns a lambda\n\nnix-repl> greeting \"Hello\" \"Alice\"\n\"Hello, Alice!\"         # providing both arguments returns the expected result\n```\n\nThis function is a chain of two single-argument functions:\n\n1. The outer function takes `prefix` (e.g. `\"Hello\"`) and returns a function\n   that expects `name`.\n\n2. The inner function takes `name` (e.g. `\"Alice\"`) and combines it with\n   `prefix` to produce the final string.\n\nThanks to **lexical scope** (where inner functions can access variables from\nouter functions), the inner function \"remembers\" the `prefix` value.\n\n#### Partial Application: Using Functions Incrementally\n\nBecause of **currying**, you can apply arguments to a Nix function one at a\ntime. This is called _partial application_. When you provide only some of the\nexpected arguments, you get a new function that \"remembers\" the provided\narguments and waits for the rest.\n\n**Example:**\n\nUsing our `greeting` function again:\n\n```nix\nnix repl\nnix-repl> greeting = prefix: name: \"${prefix}, ${name}!\";\nnix-repl> helloGreeting = greeting \"Hello\";\nnix-repl> helloGreeting \"Alice\"\n\"Hello, Alice\"\n```\n\n- `helloGreeting` is now a new function. It has already received the `prefix`\n  argument (`\"Hello\"`), when we provide the second argument we get\n  `\"Hello, Alice!\"`\n\n**Benefits of Partial Application:**\n\nPartial application provides significant benefits by enabling you to derive\nspecialized functions from more general ones through the process of fixing\ncertain parameters. Additionally, it serves as a powerful tool for adapting\nexisting functions to fit the precise argument requirements of higher-order\nfunctions like `map` and `filter`.\n\n#### Nix Functions being \"first class citizens\"\n\nIn the context of Nix, the phrase \"Nix treats functions as first-class citizens\"\nmeans that functions in Nix are treated as values, just like numbers, strings,\nor lists. They can be manipulated, passed around, and used in the same flexible\nways as other data types. This concept comes from functional programming and has\nspecific implications in Nix.\n\n**What It Means in Nix**\n\n1. Functions Can Be **Assigned to Variables**:\n\n- You can store a function in a variable, just like you would store a number or\n  string.\n\n- Example:\n\n```nix\ngreet = name: \"Hello, ${name}!\";\n```\n\n- Here, greet is a variable that holds a function.\n\n2. Functions Can Be **Passed as Arguments**:\n\n- You can pass a function to another function as an argument, allowing for\n  higher-order functions (functions that operate on other functions).\n\n- Example:\n\n```nix\napplyTwice = f: x: f (f x);\ninc = x: x + 1;\napplyTwice inc 5 # Output: 7 (increments 5 twice: 5 → 6 → 7)\n~ 7\n```\n\n- Here, applyTwice takes a function `f` (in this case, `inc`) and applies it to\n  `x` twice.\n\n3. Functions Can Be **Returned from Functions**:\n\n- Functions can produce other functions as their output, which is key to\n  currying in Nix.\n\n- Example:\n\n```nix\ngreeting = prefix: name: \"${prefix}, ${name}!\";\nhelloGreeting = greeting \"Hello\";  # Returns a function\nhelloGreeting \"Alice\"  # Output: \"Hello, Alice!\"\n~ \"Hello, Alice!\"\n```\n\n- The greeting function returns another function when partially applied with\n  prefix.\n\n4. Functions **Are Values in Expressions**:\n\n- Functions can be used anywhere a value is expected, such as in attribute sets\n  or lists.\n\n- Example:\n\n```nix\nmyFuncs = {\n  add = x: y: x + y;\n  multiply = x: y: x * y;\n};\nmyFuncs.add 3 4  # Output: 7\n~ 7\n```\n\n- Here, functions are stored as values in an attribute set.\n\n- To try this in the `repl` just remove the semi-colon (`;`)\n\n**Why This Matters in Nix**:\n\nThis functional approach is fundamental to Nix's unique build system. In Nix,\n**package builds (called derivations)** are essentially functions. They take\nspecific **inputs** (source code, dependencies, build scripts) and\ndeterministically produce **outputs** (a built package).\n\nThis design ensures **atomicity**: if a build does not succeed completely and\nperfectly, it produces no output at all. This prevents situations common in\nother package managers where partial updates or corrupted builds can leave your\nsystem in an inconsistent or broken state.\n\nMany NixOS and Home Manager modules are functions, and their first-class status\nmeans they can be combined, reused, or passed to other parts of the\nconfiguration system.\n\nNow that we understand the \"first-class\" nature of Nix Functions let's see how\nthey fit into NixOS and Home Manager modules.\n\n#### The Function Nature of NixOS and Home Manager Modules\n\nIt's crucial to understand that most NixOS and Home Manager modules are\nfundamentally **functions**.\n\nThese module functions typically accept a single argument: **an attribute set**\n(remember this, it's important to understand).\n\n**Example**:\n\nA practical NixOS module example for Thunar with plugins:\n\n```nix\n# thunar.nix\n{pkgs, ...}: {\n  programs = {\n    thunar = {\n      enable = true;\n      plugins = with pkgs.xfce; [\n        thunar-archive-plugin\n        thunar-volman\n      ];\n    };\n  };\n}\n```\n\n- To use this module I would need to import it into my `configuration.nix` or\n  equivalent, shown here for completeness.\n\n```nix\n# configuration.nix\n# ... snip ...\nimports = [ ../nixos/thunar.nix ];\n# ... snip ...\n```\n\n- This is actually a pretty good example of `with` making it a bit harder to\n  reason where the plugins are from. You might instinctively try to trace a path\n  like `programs.thunar.plugins.pkgs.xfce` because you saw `pkgs.xfce` in the\n  `with` statement. But that's now how `with` works. The `pkgs.xfce` path exists\n  _outside_ the `plugins` list, defining the source of the items, not their\n  nested structure within the list.\n\n- To follow best practices you could write the above plugins section as:\n\n```nix\nplugins = [\n  pkgs.xfce.thunar-archive-plugin\n  pkgs.xfce.thunar-volman\n];\n```\n\n- Now it's clear that each plugin comes directly from `pkgs` and each will\n  resolve to a derivation.\n  - To be clear either way is fine, especially in such a small self contained\n    module. If it were in a single file `configuration.nix` it would be a bit\n    more confusing to trace. Explicitness is your friend with Nix and\n    maintaining reproducability. `with` isn't always bad but should be avoided\n    at the top of a file for example to bring `nixpkgs` into scope, use `let`\n    instead.\n\nThe entire module definition is a function that takes one argument (an attribute\nset):`{ pkgs, ... }`. When this module is included in your configuration, the\nNixOS module system calls this function with a specific attribute set. This\nattribute set contains the available packages (`pkgs`), and other relevant\ninformation. The module then uses these values to define parts of your system.\n\n### Understanding passing and getting back arguments\n\nFor this example we will build the Hello derivation from the Nix Pills series.\n\nCreate an `autotools.nix` with the following contents:\n\n```nix\npkgs: attrs: let\n  defaultAttrs = {\n    builder = \"${pkgs.bash}/bin/bash\";\n    args = [./builder.sh];\n    baseInputs = with pkgs; [\n      gnutar\n      gzip\n      gnumake\n      gcc\n      coreutils\n      gawk\n      gnused\n      gnugrep\n      binutils.bintools\n    ];\n    buildInputs = [];\n    system = builtins.currentSystem;\n  };\nin\n  derivation (defaultAttrs // attrs)\n```\n\nLet's create the hello derivation:\n\n```nix\nlet\n  pkgs = import <nixpkgs> {};\n  mkDerivation = import ./autotools.nix pkgs;\nin\n  mkDerivation {\n    name = \"hello\";\n    src = ./hello-2.12.1.tar.gz;\n  }\n```\n\n- You can get the tarball\n  [here](https://ftp.gnu.org/gnu/hello/hello-2.12.1.tar.gz), place it in the\n  same directory as `autotools.nix`\n\nAnd finally the `builder.sh` that `autotools.nix` declares for the `args`\nattribute:\n\n```bash\n#!/bin/bash\nset -e\nunset PATH\nfor p in $buildInputs $baseInputs; do\n    export PATH=$p/bin${PATH:+:}$PATH\ndone\n\ntar -xf $src\n\nfor d in *; do\n    if [ -d \"$d\" ]; then\n        cd \"$d\"\n        break\n    fi\ndone\n\n./configure --prefix=$out\nmake\nmake install\n```\n\nWhen you write:\n\n```nix\nmkDerivation = import ./autotools.nix pkgs;\n```\n\n- `import ./autotools.nix`: This evaluates the `autotools.nix` file. Because it\n  starts with `pkgs: attrs: ...`, it means that `autotools.nix` evaluates to a\n  function that expects one argument named `pkgs`.\n\n- `... pkgs`: We are immediately calling that function (the one returned by\n  `import ./autotools.nix`) and passing it our `pkgs` variable (which is the\n  result of `import <nixpkgs> {}`).\n\n**This illustrates the concept of Currying in Nix**:\n\nThe function defined in `autotools.nix` (`pkgs: attrs: ...`) is a curried\nfunction. It's a function that, when given its first argument (`pkgs`), returns\nanother function (which then expects `attrs`).\n\nThe result of import `./autotools.nix pkgs` is that second, inner function:\n`attrs: derivation (defaultAttrs // attrs)`. This inner function is then bound\nto the `mkDerivation` variable, making it ready to be called with just the\nspecific attributes for your package (like `name` and `src`).\n\n**Understanding the `attrs` Argument**\n\nNow let's focus on the second argument of our `autotools.nix` function: `attrs`.\n\nRecall the full function signature in `autotools.nix`:\n\n```nix\npkgs: attrs: let\n  # ... defaultAttrs definition ...\nin\n  derivation (defaultAttrs // attrs)\n```\n\n1. What `attrs` Represents:\n\n- Once `autotools.nix` has received its `pkgs` argument (and returned the inner\n  function), this inner function is waiting for its final argument, which we\n  call `attrs`.\n\n- `attrs` is simply an attribute set (a key-value map in Nix). It's designed to\n  receive all the specific properties of the individual package you want to\n  build using this helper.\n\n2. How `attrs` is Used:\n\n- Look at the final line of `autotools.nix`:\n  `derivation (defaultAttrs // attrs)`.\n\n- The `//` operator in Nix performs an attribute set merge. It takes all\n  attributes from `defaultAttrs` and combines them with all attributes from\n  `attrs`.\n\n- Crucially, if an attribute exists in both `defaultAttrs` and `attrs`, the\n  value from `attrs` (the second operand) takes precedence and overrides the\n  default value.\n\n3. Applying attrs in the hello Derivation:\n\n- In the `hello` derivation, we call `mkDerivation` like this:\n\n```nix\n        mkDerivation {\n          name = \"hello\";\n          src = ./hello-2.12.1.tar.gz;\n        }\n```\n\n- The attribute set `{ name = \"hello\"; src = ./hello-2.12.1.tar.gz; }` is what\n  gets passed as the `attrs` argument to the `mkDerivation` function (which,\n  remember, is the inner function returned by `autotools.nix`).\n\n- When derivation `(defaultAttrs // attrs)` is evaluated for \"hello\", the `name`\n  and `src` provided in the `attrs` set will be merged with all the\n  `defaultAttrs` (like `builder`, `args`, `baseInputs`, etc.).\n\nIn summary:\n\n- The `pkgs` argument configures the general environment and available tools for\n  the builder.\n\n- The `attrs` argument is where you provide the unique details for each specific\n  package you intend to build using this `autotools.nix` helper. It allows you\n  to specify things like the package's name, source code, version, and any\n  custom build flags, while still benefiting from all the sensible defaults\n  provided by `autotools.nix`. This separation makes `autotools.nix` a reusable\n  and flexible \"template\" for creating derivations.\n\n#### Conclusion\n\nHaving explored the fundamental nature of functions in Nix, we can now see this\nconcept applies to more complex areas like NixOS configuration and derivations.\nIn the next chapter,\n[NixOS Modules Explained](https://saylesss88.github.io/NixOS_Modules_Explained_3.html).\nWe will learn about NixOS Modules which are themselves functions most of the\ntime.\n\n#### Resources\n\n<details>\n<summary> ✔️ Resources (Click to Expand) </summary>\n\n- [nix.dev Nix Lang Basics](https://nix.dev/tutorials/nix-language.html)\n\n- [nix pills Functions and Imports](https://nixos.org/guides/nix-pills/05-functions-and-imports.html)\n\n- [zero-to-nix Nix Lang](https://zero-to-nix.com/concepts/nix-language/)\n\n- [A tour of Nix \"Functions\"](https://nixcloud.io/tour/?id=functions%2Fintroduction)\n\n- [learn Nix in y minutes](https://learnxinyminutes.com/nix/)\n\n- [noogle function library](https://noogle.dev/)\n\n</details>\n","number":[4],"sub_items":[{"Chapter":{"name":"Practical Nix Functions","content":"# Practical Nix Functions\n\n<details>\n<summary>\n✔️\nIf you want to follow along with this example you'll have to place the following\nin your project directory. Section is collapsed to focus on functions:\n\n</summary>\n\n![coding6](images/coding6.png)\n\n1. [graphviz](https://gitlab.com/api/v4/projects/4207231/packages/generic/graphviz-releases/2.49.3/graphviz-2.49.3.tar.gz)\n\n2. [hello](https://ftp.gnu.org/gnu/hello/hello-2.12.1.tar.gz)\n\n3. `autotools.nix`:\n\n```nix\n# autotools.nix\npkgs: attrs:\nwith pkgs; let\n  defaultAttrs = {\n    builder = \"${bash}/bin/bash\";\n    args = [./builder.sh];\n    setup = ./setup.sh;\n    baseInputs = [gnutar gzip gnumake gcc binutils-unwrapped coreutils gawk gnused gnugrep patchelf findutils];\n    buildInputs = [];\n    system = builtins.currentSystem;\n  };\nin\n  derivation (defaultAttrs // attrs)\n```\n\n4. `setup.sh`:\n\n```bash\n# setup.sh (This is a library of functions setting up the environment, not directly executable)\nunset PATH\nfor p in $baseInputs $buildInputs; do\n  if [ -d $p/bin ]; then\n    export PATH=\"$p/bin${PATH:+:}$PATH\"\n  fi\n  if [ -d $p/lib/pkgconfig ]; then\n    export PKG_CONFIG_PATH=\"$p/lib/pkgconfig${PKG_CONFIG_PATH:+:}$PKG_CONFIG_PATH\"\n  fi\ndone\n\nfunction unpackPhase() {\n  tar -xzf $src\n\n  for d in *; do\n    if [ -d \"$d\" ]; then\n      cd \"$d\"\n      break\n    fi\n  done\n}\n\nfunction configurePhase() {\n  ./configure --prefix=$out\n}\n\nfunction buildPhase() {\n  make\n}\n\nfunction installPhase() {\n  make install\n}\n\nfunction fixupPhase() {\n  find $out -type f -exec patchelf --shrink-rpath '{}' \\; -exec strip '{}' \\; 2>/dev/null\n}\n\nfunction genericBuild() {\n  unpackPhase\n  configurePhase\n  buildPhase\n  installPhase\n  fixupPhase\n}\n```\n\n5. And finally `builder.sh`:\n\n```bash\n# builder.sh (This is the actual builder script specified in the derivation and\n# what `nix-build` expects)\nset -e\nsource $setup\ngenericBuild\n```\n\n</details>\n\nThis is another example from the Nix-Pill series shown in another way to show\nsome powerful aspects of functions.\n\nIf you have a `default.nix` like this:\n\n```nix\n# default.nix\n{\n  hello = import ./hello.nix;\n  graphviz = import ./graphviz.nix;\n}\n```\n\nIt expects the files that it imports to look like this:\n\n```nix\n# graphviz.nix\nlet\n  pkgs = import <nixpkgs> { };\n  mkDerivation = import ./autotools.nix pkgs;\nin\nmkDerivation {\n  name = \"graphviz\";\n  src = ./graphviz-2.49.3.tar.gz;\n}\n```\n\nAnd `hello.nix`:\n\n```nix\n# hello.nix\nlet\n  pkgs = import <nixpkgs> { };\n  mkDerivation = import ./autotools.nix pkgs;\nin\nmkDerivation {\n  name = \"hello\";\n  src = ./hello-2.12.1.tar.gz;\n}\n```\n\nYou would build these with:\n\n```bash\nnix-build -A hello\nnix-build -A graphviz\n```\n\nAs you can see both derivations are dependendent on `nixpkgs` which they\n**both** import directly. To centralize our dependencies and avoid redundant\nimports, we'll refactor our individual package definitions (`hello.nix`,\n`graphviz.nix`) into functions. Our `default.nix` will then be responsible for\nsetting up the common inputs (like `pkgs` and `mkDerivation`) and passing them\nas arguments when it imports and calls these package functions.\n\nHere is what our `default.nix` will look like:\n\n```nix\nlet\n  pkgs = import <nixpkgs> { };\n  mkDerivation = import ./autotools.nix pkgs;\nin\nwith pkgs;\n{\n  hello = import ./hello.nix { inherit mkDerivation; };\n  graphviz = import ./graphviz.nix {\n    inherit\n      mkDerivation\n      lib\n      gd\n      pkg-config\n      ;\n  };\n  graphvizCore = import ./graphviz.nix {\n    inherit\n      mkDerivation\n      lib\n      gd\n      pkg-config\n      ;\n    gdSupport = false;\n  };\n}\n```\n\nWe define some local variables in the `let` expression and pass them around.\n\nThe whole expression in the above `default.nix` returns an attribute set with\nthe keys `hello`, `graphviz`, and `graphvizCore`\n\nWe import `hello.nix` and `graphviz.nix`, which both return a function. We call\nthe functions, passing them a set of inputs with the `inherit` construct.\n\nLet's change `hello.nix` into a function to match what the `default.nix` now\nexpects.\n\n```nix\n# hello.nix\n{mkDerivation}:\nmkDerivation {\n  name = \"hello\";\n  src = ./hello-2.12.1.tar.gz;\n}\n```\n\nNow our `graphviz` attribute expects `graphviz.nix` to be a function that takes\nthe arguments listed in the above `default.nix`, here's what `graphviz.nix` will\nlook like as a function:\n\n```nix\n# graphviz.nix\n{\n  mkDerivation,\n  lib,\n  gdSupport ? true,\n  gd,\n  pkg-config,\n}:\nmkDerivation {\n  name = \"graphviz\";\n  src = ./graphviz-2.49.3.tar.gz;\n  buildInputs =\n    if gdSupport\n    then [\n      pkg-config\n      (lib.getLib gd)\n      (lib.getDev gd)\n    ]\n    else [];\n}\n```\n\nWe factorized the import of `nixpkgs` and `mkDerivation`, and also added a\nvariant of `graphviz` with gd support disabled. The result is that both\n`hello.nix` and `graphviz.nix` are independent of the repository and\ncustomizable by passing specific inputs.\n\nNow, we can build the package with `gd` support disabled with the `graphvizCore`\nattribute:\n\n```bash\nnix-build -A graphvizCore\n# or we can still build the package that now defaults to gd support\nnix-build -A graphviz\n```\n\nThis example showed us how to turn expressions into functions. We saw how\nfunctions are passed around and shared between Nix expressions and derivations.\n","number":[4,1],"sub_items":[],"path":"functions/practical_functions_2.1.md","source_path":"functions/practical_functions_2.1.md","parent_names":["Understanding Nix Functions"]}},{"Chapter":{"name":"Functions and NixOS Modules","content":"# Functions and NixOS Modules\n\n<details>\n<summary> ✔️ Click to Expand Table of Contents</summary>\n\n<!-- toc -->\n\n</details>\n\nWhen you start exploring NixOS configurations or tools like Home Manager, you'll\nencounter a concept called Nix Modules. Modules are also functions, but they\nbehave differently regarding their arguments, which can be a source of\nconfusion.\n\n**What are NixOS Modules**?\n\nNix Modules are a powerful system built on top of basic Nix functions, primarily\nused for declarative system configurations (like NixOS, Home Manager, NixOps,\netc.). They allow you to define parts of your system configuration in separate\nfiles that are then composed together.\n\nEach module is typically a Nix function that returns an attribute set with\nspecific keys like `options`, `config`, and `imports`.\n\n**Automatic Arguments in Modules**\n\nUnlike the functions we've been writing, Nix's module system automatically\npasses a standard set of arguments to every module function it evaluates. You\ndon't explicitly pass these arguments when you `import` a module file; the\nmodule system handles it for you.\n\nThe most common automatic arguments you'll see are:\n\n- `config`: The aggregated configuration options of all modules combined. This\n  is what you use to read other configuration values.\n\n- `options`: The definitions of all available configuration options across all\n  modules.\n\n- `pkgs`: The standard Nixpkgs set, equivalent to `import <nixpkgs> {}`. This is\n  incredibly convenient as you don't need to import it in every module.\n\n- `lib`: The Nixpkgs utility library (`pkgs.lib`), providing helper functions\n  for common tasks.\n\n- `specialArgs`: An attribute set of extra arguments to be passed to the module\n  functions.\n\nA typical module might start like this:\n\n```nix\n# Example NixOS module\n{ config, pkgs, lib, ... }: # These arguments are passed automatically by the module system\n{\n  # ... module options and configuration\n  environment.systemPackages = [ pkgs.firefox pkgs.git ];\n  services.nginx.enable = true;\n  # ...\n}\n```\n\nIn the above module, the only required argument is `pkgs` because we explicitly\nuse it in the module (i.e. `pkgs.firefox`). Editors have pretty good support for\nletting you know if you're missing arguments or have unnecessary ones. `config`,\nand `lib` and would be required if we were setting any options in this module.\n\nThis automatic passing of arguments is a core feature of the module system that\nsimplifies writing configurations, as you always have access to `pkgs`, `lib`,\nand the evolving `config` and `options` without boilerplate.\n\n#### `specialArgs`: Passing Custom Arguments to Modules\n\nWhile the module system passes a standard set of arguments automatically, what\nif you need to pass additional, custom data to your modules that isn't part of\nthe standard `config`, `pkgs`, `lib`, or `options`? This is where `specialArgs`\ncomes in.\n\n`specialArgs` is an attribute you can pass to the `import` function when you\nload a module (or a set of modules). It's typically used to provide data that\nyour modules need but isn't something Nixpkgs would normally manage.\n\nFor example, in a `configuration.nix`:\n\n```nix\n# From your configuration.nix\n{ config, pkgs, lib, ... }: # Standard module arguments\n\nlet\n  myCustomValue = \"helloWorld\";\nin\n{\n  # ... imports all modules, including your custom ones\n  imports = [\n    ./hardware-configuration.nix\n    ./my-webserver-module.nix\n  ];\n\n  # This is where specialArgs would be used (often in import statements)\n  # Example: passing a custom value to ALL modules:\n  # (in module context, this is more complex, but conceptually)\n  # let\n  #   allModules = [ ./my-module.nix ];\n  # in\n  # lib.nixosSystem {\n  #   modules = allModules;\n  #   specialArgs = {\n  #     username = \"johndoe\";\n  #     mySecretKey = \"/run/keys/ssh_key\";\n  #   };\n  #   # ...\n  # };\n}\n```\n\nAnd then, inside `my-webserver-module.nix`:\n\n```nix\n# my-webserver-module.nix\n{ config, pkgs, lib, username, mySecretKey, ... }: # username and mySecretKey come from specialArgs\n{\n  # ... use username and mySecretKey in your module\n  users.users.${username} = {\n    isNormalUser = true;\n    extraGroups = [ \"wheel\" \"networkmanager\" ];\n    # ...\n  };\n  # ...\n}\n```\n\nAny argument listed in a module's function signature that is not one of the\nstandard `config`, `pkgs`, `lib`, `options` (or `pkgs.callPackage`, etc., which\nare often implicit through `pkgs`) must be provided via `specialArgs` at the\npoint where the modules are composed.\n\nAny values listed in a module that aren’t automatically passed via Nixpkgs must\nbe explicitly provided through `specialArgs`.\n\n### `specialArgs` and `extraSpecialArgs` with Flakes\n\nNixOS modules use `specialArgs` and Home-Manager uses `extraSpecialArgs` to\nallow you to pass extra arguments.\n\nOr with Flakes it would look like this:\n\n```nix\n{\n  description = \"My Flake\";\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n    home-manager.url = \"github:nix-community/home-manager\";\n    home-manager.inputs.nixpkgs.follows = \"nixpkgs\";\n   };\n\n  outputs = { self, nixpkgs, home-manager, ... }:\n    let\n      lib = nixpkgs.lib;\n      pkgs = nixpkgs.legacyPackages.${\"x86_64-linux\"};\n      system = \"x86_64-linux\";\n  host = \"magic\";\n  username = \"jr\";\n  userVars = {\n    timezone = \"America/New_York\";\n    locale = \"en_US.UTF-8\";\n    gitUsername = \"TSawyer87\";\n    dotfilesDir = \"~/.dotfiles\";\n    wm = \"hyprland\";\n    browser = \"firefox\";\n    term = \"ghostty\";\n    editor = \"hx\";\n    keyboardLayout = \"us\";\n  };\n    in {\n      nixosConfigurations = {\n        YOURHOSTNAME = lib.nixosSystem {\n          system = \"x86_64-linux\";\n          modules = [ ./configuration.nix ];\n          specialArgs = {\n            inherit userVars; # == userVars = userVars;\n            inherit host;\n            inherit username;\n          };\n        };\n      };\n      homeConfigurations = {\n        USERNAME = home-manager.lib.homeManagerConfiguration {\n          inherit pkgs;\n          modules = [ ./home.nix ];\n          extraSpecialArgs = {\n            inherit userVars;\n            inherit host;\n            inherit username;\n            # or it can be written like this:\n            # inherit userVars host username;\n          };\n        };\n      };\n    };\n}\n```\n\nNow if I want to use any of these arguments in modules I can by any module file\nreferenced by my configuration.\n\nFor example, the following is a `git.nix` module that uses the variables from\nthe flake passed from `extraSpecialArgs` in this case because it's a\nhome-manager module:\n\n```nix\n# git.nix\n{ userVars, ... }: {\n  programs = {\n    git = {\n      enable = true;\n      userName = userVars.gitUsername;\n    };\n  };\n}\n```\n\n| Feature         | Regular Nix Function (e.g., `hello.nix`)                            | Nix Module (e.g., `my-config-module.nix`)                           |\n| :-------------- | :------------------------------------------------------------------ | :------------------------------------------------------------------ |\n| **Arguments**   | **You must explicitly pass every single argument.**                 | **Automatically receives `config`, `pkgs`, `lib`, `options`, etc.** |\n| **Custom Args** | Passed directly in the function call.                               | Passed via `specialArgs` when the modules are composed.             |\n| **Boilerplate** | Often needs `pkgs = import <nixpkgs> {};` if not explicitly passed. | `pkgs` and `lib` are always available automatically.                |\n| **Purpose**     | Defines a package, a utility, or a single value.                    | Defines a reusable part of a declarative system configuration.      |\n","number":[4,2],"sub_items":[],"path":"functions/functions_and_modules_2.2.md","source_path":"functions/functions_and_modules_2.2.md","parent_names":["Understanding Nix Functions"]}}],"path":"Understanding_Nix_Functions_2.md","source_path":"Understanding_Nix_Functions_2.md","parent_names":[]}},{"Chapter":{"name":"NixOS Modules Explained","content":"---\ntitle: My Chapter\ndate: 2025-11-21\nauthor: saylesss88\ndescription: Chapter 3\n---\n\n# Chapter 3\n\n<details>\n<summary> ✔️ Click to Expand Table of Contents</summary>\n\n<!-- toc -->\n\n</details>\n\n## Nix Module System Explained\n\n<!-- ![gruv3](images/gruv3.png) -->\n\n![buildings](images/buildings1.png)\n\n**TL;DR**: In this chapter, we will break down the Nix module system used by\nboth NixOS and Home-Manager. We will discuss using home-manager as a module and\nthe flexibility that modules give us. We will touch on options and break down\nthe `vim` module from the Nixpkgs collection. Finally we will display how to\ntest modules with the repl.\n\nYour `configuration.nix` is a module. For the Nixpkgs collection most modules\nare in `nixos/modules`.\n\nThe suggested way of using `home-manager` according to their manual is as a\n[NixOS module](https://nix-community.github.io/home-manager/index.xhtml#sec-install-nixos-module).\nBoth home-manager and NixOS use the same module system.\n\n## Module Structure\n\n```nix\n{\n  imports = [\n    # Paths to other modules.\n    # Compose this module out of smaller ones.\n  ];\n\n  options = {\n    # Option declarations.\n    # Declare what settings a user of this module can set.\n    # Usually this includes a global \"enable\" option which defaults to false.\n  };\n\n  config = {\n    # Option definitions.\n    # Define what other settings, services and resources should be active.\n    # Usually these depend on whether a user of this module chose to \"enable\" it\n    # using the \"option\" above.\n    # Options for modules imported in \"imports\" can be set here.\n  };\n}\n```\n\n`imports`, `options`, and `config` are the top-level attributes of a Nix module.\nThey are the primary, reserved keys that the Nix module system recognizes and\nprocesses to combine different configurations into a single, cohesive system or\nuser environment. `config` is the same `config` you receive as a module argument\n(e.g. `{ pkgs, config, ... }:` at the top of your module function)\n\nUnderstanding `config`:\n\n`config` is the big constantly updated blueprint of your entire system.\n\nEvery time you bring in a new module, it adds its own settings and options to\nthis blueprint. So, when a module receives the `config` argument, it's getting\nthe complete picture of everything you've asked NixOS to set up so far.\n\nThis allows the module to:\n\n- See what other parts of your system are doing.\n\n- Make smart decisions based on those settings.\n\n- Add its own pieces to the overall plan, building on what's already there.\n\n- Most modules are functions that take an attribute set and return an attribute\n  set.\n\nTo turn the above module into a function accepting an attribute set just add the\nfunction arguments to the top, click the eye to see the whole module:\n\n```nix\n{ config, pkgs, ... }:\n~ {\n~   imports = [\n~     # Paths to other modules.\n~     # Compose this module out of smaller ones.\n~   ];\n~\n~   options = {\n~     # Option declarations.\n~     # Declare what settings a user of this module can set.\n~     # Usually this includes a global \"enable\" option which defaults to false.\n~   };\n~\n~   config = {\n~     # Option definitions.\n~     # Define what other settings, services and resources should be active.\n~     # Usually these depend on whether a user of this module chose to \"enable\" it\n~     # using the \"option\" above.\n~     # Options for modules imported in \"imports\" can be set here.\n~   };\n~ }\n```\n\nIt may require the attribute set to contain:\n\n- `config`: The configuration of the entire system.\n\n- `options`: All option declarations refined with all definition and declaration\n  references.\n\n- `pkgs`: The attribute set extracted from the Nix package collection and\n  enhanced with the `nixpkgs.config` option.\n\n- `modulesPath`: The location of the module directory of NixOS.\n\n## Modularize your configuration.nix\n\nMany people start of using a single `configuration.nix` and eventually their\nsingle file configuration gets too large to search through and maintain\nconveniently.\n\nThis is where **modules** come in allowing you to break up your configuration\ninto logical parts. Your `boot.nix` will contain settings and options related to\nthe actual boot process. You're `services.nix` will only have services and so\non...\n\n- These modules are placed in a logical path relative to either your\n  `configuration.nix` or equivalent or if you're using flakes relative to your\n  `flake.nix` or equivalent.\n  - The `imports` mechanism takes paths to other modules as its argument and\n    combines them to be included in the evaluation of the system configuration.\n\n> ```nix\n> { ... }:\n> {\n>   imports = [\n>      # Paths to other modules\n>\n>      # They can be relative paths\n>      ./otherModule.nix\n>\n>      # Or absolute\n>      /path/to/otherModule.nix\n>\n>      # Or to a directory\n>      ../modules/home/shells/nushell\n>   ];\n> }\n> ```\n\n> ❗: The **imports** mechanism includes and evaluates the Nix expression found\n> at the given path _as a module_. If that path is a directory, it will\n> automatically look for and evaluate a `default.nix` file within that directory\n> _as a module_. It is common to have that `default.nix` be a function that only\n> imports and combines all the modules in said directory. Like the above\n> example, in the nushell directory would be a `default.nix` that is\n> automatically imported and evaluated.\n\n**Crucial Distinction: `imports` vs. `import`**:\n\nBeginners often confuse the modules attribute `imports = [./module.nix]` here\nwith the Nix builtins function `import module.nix`. The first expects a path to\na file containing a NixOS module (having the same specific structure we're\ndescribing here), while the second loads whatever Nix expression is in that file\n(no expected structure). --NixOS Wiki.\n\nConsidering `configuration.nix` is a module, it can be imported like any other\nmodule and this is exactly what you do when getting started with flakes.\n\n```nix\n# flake.nix\n{\n  description = \"NixOS configuration\";\n\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n    home-manager.url = \"github:nix-community/home-manager\";\n    home-manager.inputs.nixpkgs.follows = \"nixpkgs\";\n  };\n\n  outputs = inputs@{ nixpkgs, home-manager, ... }: {\n    nixosConfigurations = {\n      hostname = nixpkgs.lib.nixosSystem {\n        system = \"x86_64-linux\";\n        modules = [\n          ./configuration.nix\n          home-manager.nixosModules.home-manager\n          {\n            home-manager.useGlobalPkgs = true;\n            home-manager.useUserPackages = true;\n            home-manager.users.jdoe = ./home.nix;\n\n            # Optionally, use home-manager.extraSpecialArgs to pass\n            # arguments to home.nix\n          }\n        ];\n      };\n    };\n  };\n}\n```\n\n`modules = [...]` in `flake.nix`: This is effectively the initial `imports` list\nfor your entire NixOS system or Home Manager user configuration. It tells the\nNix module system: \"Start by collecting and merging the configurations defined\nin these specific modules.\"\n\nThe above example is what you get from running:\n`nix flake new /etc/nixos -t github:nix-community/home-manager#nixos`\n\nIf you notice the `home-manager.nixosModules.home-manager`, that is what imports\nhome-manager as a module.\n\nYou could also make the actual home-manager module and import it like this:\n\n```nix\n# home-manager.nix\n{ inputs, outputs, ... }: {\n  imports = [\n    # Import home-manager's NixOS module\n    inputs.home-manager.nixosModules.home-manager\n  ];\n\n  home-manager = {\n    extraSpecialArgs = { inherit inputs outputs; };\n    users = {\n      # Import your home-manager configuration\n      your-username = import ../home-manager/home.nix;\n    };\n  };\n}\n```\n\nThis \"module\" isn't much different from the one included in the `flake.nix`\nabove, it is just shown here to show the flexibility of modules. They can be as\nbig and complex or as small and simple as you want. You can break up every\nsingle program or component of your configuration into individual modules or\nhave modules that bundle similar programs the choice is yours.\n\nThen in your `configuration.nix` or equivalent you would add `home-manager.nix`\nto your imports list and you would have home-manager as a NixOS module.\n\n<details>\n<summary>\n✔️ Refresher (Click to Expand):\n</summary>\n\nAn **attribute set** is a collection of name-value pairs called _attributes_:\n\nAttribute sets are written enclosed in curly braces `{}`. Attribute names and\nattribute values are separated by an equal sign `=`. Each value can be an\narbitrary expression, terminated by a semicolon `;`.\n\n> **Example**:[nix.dev reference](https://nix.dev/manual/nix/2.24/language/syntax#attrs-literal)\n> This defines an attribute set with attributes named:\n>\n> - `x` with the value `123`, an integer\n> - `text` with the value `\"Hello\"`, a string\n> - `y` where the value is the result of applying the function `f` to the\n>   attribute set `{bla = 456; }`\n>\n> ```nix\n> {\n>  x = 123;\n>  text = \"Hello\";\n>  y = f { bla = 456; };\n> }\n> ```\n>\n> ```nix\n> { a = \"Foo\"; b = \"Bar\"}.a\n> ~ \"Foo\"\n> ```\n\nAttributes can appear in any order. An attribute name may only occur once in\neach attribute set.\n\n> ❗ Remember `{}` is a valid attribute set in Nix.\n\nThe following is a **function** with an attribute set argument, remember that\nanytime you see a `:` in Nix code it means this is a function. To the left is\nthe **function arguments** and to the right is the **function body**:\n\n```nix\n{ a, b }: a + b\n```\n\nThe simplest possible **NixOS Module**:\n\n```nix\n{ ... }:\n{\n}\n```\n\n</details>\n\nNixOS produces a full system configuration by combining smaller, more isolated\nand reusable components: **Modules**. If you want to understand Nix and NixOS\nmake sure you grasp modules!\n\nA NixOS module defines configuration options and behaviors for system\ncomponents, allowing users to extend, customize, and compose configurations\ndeclaratively.\n\nA **module** is a file containing a Nix expression with a specific structure. It\n_declares_ options for other modules to define (give a value). Modules were\nintroduced to allow extending NixOS without modifying its source code.\n\nTo define any values, the module system first has to know which ones are\nallowed. This is done by declaring options that specify which attributes can be\nset and used elsewhere.\n\nIf you want to write your own modules, I recommend setting up\n[nixd](https://github.com/nix-community/nixd?tab=readme-ov-file) or\n[nil](https://github.com/oxalica/nil) with your editor of choice. This will\nallow your editor to warn you about missing arguments and dependencies as well\nas syntax errors.\n\n### Declaring Options\n\nOptions are declared under the top-level `options` attribute with\n`lib.mkOption`.\n\n[mkOption](https://nixos.org/manual/nixpkgs/stable/#function-library-lib.options.mkOption)\nCreates an Option attribute set. It accepts an attribute set with certain keys\nsuch as, `default`, `package`, and `example`.\n\n```nix\n# options.nix\n{ lib, ... }:\n{\n  options = {\n    name = lib.mkOption { type = lib.types.str; };\n  };\n}\n```\n\n> `lib` provides helper functions from `nixpkgs.lib` and the ellipsis (`...`) is\n> for arbitrary arguments which means that this function is prepared to accept\n> **any additional arguments** that the caller might provide, even if those\n> arguments are not explicitly named or used within the module's body. They make\n> the modules more flexible, without the `...` each module would have to\n> explicitly list every possible argument it might receive, which would be\n> cumbersome and error-prone. So `{lib, ... }:` means that \"I need the `lib`\n> argument\" **and** I acknowledge that the module system might pass other\n> arguments automatically (like `config`, `pkgs`, etc.) and I'm fine with them\n> being there, even if I don't use them directly in this specific module file.\n\n### Defining Values\n\nOptions are **set** or **defined** under the top-level `config` attribute:\n\n```nix\n# config.nix\n{ ... }:\n{\n  config = {\n    name = \"Slick Jones\";\n  };\n}\n```\n\nIn this **option declaration**, we created an option `name` of type _string_ and\nset that same option to a string.\n\n**Option Definitions** can be in a separate file than **Option Declarations**\n\n### Evaluating Modules\n\nModules are **evaluated** with\n[lib.evalModules](https://nixos.org/manual/nixpkgs/stable/#module-system-lib-evalModules)\n`lib.evalModules` evaluates a set of modules, typically once per application\n(e.g. once for NixOS and once for Home-Manager).\n\n## Checking out the Vim module provided by Nixpkgs\n\nThe following is `nixpkgs/nixos/modules/programs/vim.nix`, a module that is\nincluded in the Nixpkgs collection:\n\n```nix\n{\n  config,\n  lib,\n  pkgs,\n  ...\n}:\n\nlet\n  cfg = config.programs.vim;\nin\n{\n  options.programs.vim = {\n    enable = lib.mkEnableOption \"Vi IMproved, an advanced text\";\n\n    defaultEditor = lib.mkEnableOption \"vim as the default editor\";\n\n    package = lib.mkPackageOption pkgs \"vim\" { example = \"vim-full\"; };\n  };\n\n  # TODO: convert it into assert after 24.11 release\n  config = lib.mkIf (cfg.enable || cfg.defaultEditor) {\n    warnings = lib.mkIf (cfg.defaultEditor && !cfg.enable) [\n      \"programs.vim.defaultEditor will only work if programs.vim.enable is\n       enabled, which will be enforced after the 24.11 release\"\n    ];\n    environment = {\n      systemPackages = [ cfg.package ];\n      variables.EDITOR = lib.mkIf cfg.defaultEditor (lib.mkOverride 900 \"vim\");\n      pathsToLink = [ \"/share/vim-plugins\" ];\n    };\n  };\n}\n```\n\nIt provides options to enable Vim, set it as the default editor, and specify the\nVim package to use.\n\n<details>\n<summary> ✔️ Breakdown of the vim module.(Click to Expand)</summary>\n1. Module Inputs and Structure:\n\n```nix\n{\n  config,\n  lib,\n  pkgs,\n  ...\n}\n```\n\n**Inputs**: The module takes the above inputs and `...` (catch-all for other\nargs)\n\n- `config`: Allows the module to read option values (e.g.\n  `config.programs.vim.enable`). It provides access to the evaluated\n  configuration.\n\n- `lib`: The Nixpkgs library, giving us helper functions like `mkEnableOption` ,\n  `mkIf`, and `mkOverride`.\n\n- `pkgs`: The Nixpkgs package set, used to access packages like `pkgs.vim`\n\n- `...`: Allows the module to accept additional arguments, making it flexible\n  for extension in the future.\n\n> Key Takeaways: A NixOS module is typically a function that can include\n> `config`, `lib`, and `pkgs`, but it doesn’t require them. The `...` argument\n> ensures flexibility, allowing a module to accept extra inputs without breaking\n> future compatibility. Using `lib` simplifies handling options (mkEnableOption,\n> mkIf, mkOverride) and helps follow best practices. Modules define options,\n> which users can set in their configuration, and `config`, which applies\n> changes based on those options.\n\n2. Local Configuration Reference:\n\n```nix\nlet\n  cfg = config.programs.vim;\nin\n```\n\nThis is a local alias. Instead of typing `config.programs.vim` over and over,\nthe module uses `cfg`.\n\n3. Option Declaration\n\n```nix\noptions.programs.vim = {\n  enable = lib.mkEnableOption \"Vi IMproved, an advanced text\";\n  defaultEditor = lib.mkEnableOption \"vim as the default editor\";\n  package = lib.mkPackageOption pkgs \"vim\" { example = \"vim-full\"; };\n};\n```\n\nThis defines three user-configurable options:\n\n- `enable`: Turns on Vim support system-wide.\n\n- `defaultEditor`: Sets Vim as the system's default `$EDITOR`.\n\n- `package`: lets the user override which Vim package is used.\n\n> `mkPackageOption` is a helper that defines a package-typed option with a\n> default (`pkgs.vim`) and provides docs + example. Using `lib.mkEnableOption`\n> makes it clear exactly where this function is coming from. Same with\n> `lib.mkIf` and as you can see they can be further down the configuration,\n> further from where you defined `with lib;` making it less clear where they\n> come from. Explicitness is your friend when it comes to reproducability and\n> clarity.\n\n4. Conditional Configuration\n\n```nix\nconfig = lib.mkIf (cfg.enable || cfg.defaultEditor) {\n```\n\n- This block is only activated if _either_ `programs.vim.enable` or\n  `defaultEditor` is set.\n\n5. Warnings\n\n```nix\nwarnings = lib.mkIf (cfg.defaultEditor && !cfg.enable) [\n  \"programs.vim.defaultEditor will only work if programs.vim.enable is enabled,\n   which will be enforced after the 24.11 release\"\n];\n```\n\nGives you a soft warning if you try to set `defaultEditor = true` without also\nenabling Vim.\n\n6. Actual System Config Changes\n\n```nix\nenvironment = {\n  systemPackages = [ cfg.package ];\n  variables.EDITOR = lib.mkIf cfg.defaultEditor (lib.mkOverride 900 \"vim\");\n  pathsToLink = [ \"/share/vim-plugins\" ];\n};\n```\n\nIt adds Vim to your `systemPackages`, sets `$EDITOR` if `defaultEditor` is true,\nand makes `/share/vim-plugins` available in the environment.\n\n</details>\n\nThe following is a bat home-manager module that I wrote:\n\n```nix\n# bat.nix\n{\n  pkgs,\n  config,\n  lib,\n  ...\n}: let\n  cfg = config.custom.batModule;\nin {\n  options.custom.batModule.enable = lib.mkOption {\n    type = lib.types.bool;\n    default = false;\n    description = \"Enable bat module\";\n  };\n\n  config = lib.mkIf cfg.enable {\n    programs.bat = {\n      enable = true;\n      themes = {\n        dracula = {\n          src = pkgs.fetchFromGitHub {\n            owner = \"dracula\";\n            repo = \"sublime\"; # Bat uses sublime syntax for its themes\n            rev = \"26c57ec282abcaa76e57e055f38432bd827ac34e\";\n            sha256 = \"019hfl4zbn4vm4154hh3bwk6hm7bdxbr1hdww83nabxwjn99ndhv\";\n          };\n          file = \"Dracula.tmTheme\";\n        };\n      };\n      extraPackages = with pkgs.bat-extras; [\n        batdiff\n        batman\n        prettybat\n        batgrep\n      ];\n    };\n  };\n}\n```\n\nNow I could add this to my `home.nix` to enable it:\n\n```nix\n# home.nix\ncustom = {\n  batModule.enable = true;\n}\n```\n\nIf I set this option to true the bat configuration is dropped in place. If it's\nnot set to true, it won't put the bat configuration in the system. Same as with\noptions defined in modules within the Nixpkgs repository.\n\nIf I had set the default to `true`, it would automatically enable the module\nwithout requiring an explicit `custom.batModule.enable = true;` call in my\n`home.nix`.\n\n### Module Composition\n\nNixOS achieves its full system configuration by combining the configurations\ndefined in various modules. This composition is primarily handled through the\n`imports` mechanism.\n\n`imports`: This is a standard option within a NixOS or Home Manager\nconfiguration (often found in your configuration.nix or home.nix). It takes a\nlist of paths to other Nix modules. When you include a module in the imports\nlist, the options and configurations defined in that module become part of your\noverall system configuration.\n\nYou declaratively state the desired state of your system by setting options\nacross various modules. The NixOS build system then evaluates and merges these\noption settings. The culmination of this process, which includes building the\nentire system closure, is represented by the derivation built by\n`config.system.build.toplevel`.\n\n### NixOS Modules and Dependency Locking with npins\n\n<details>\n<summary> ✔️ npins example (Click to Expand)</summary>\nAs our NixOS configurations grow in complexity, so too does the challenge of\nmanaging the dependencies they rely on. Ensuring consistency and reproducibility\nnot only applies to individual packages but also to the versions of Nixpkgs and\nother external resources our configurations depend upon.\n\nTraditionally, NixOS configurations often implicitly rely on the version of\nNixpkgs available when `nixos-rebuild` is run. However, for more robust and\nreproducible setups, especially in collaborative environments or when rolling\nback to specific configurations, explicitly locking these dependencies to\nspecific versions becomes crucial.\n\nIn the following example, we'll explore how to use a tool called `npins` to\nmanage and lock the dependencies of a NixOS configuration, ensuring a more\npredictable and reproducible system. This will involve setting up a project\nstructure and using npins to pin the specific version of Nixpkgs our\nconfiguration relies on.\n\nThis is the file structure:\n\n```bash\n❯ tree\n.\n├── configuration.nix\n├── default.nix\n├── desktop.nix\n└── npins\n    ├── default.nix\n    └── sources.json\n```\n\nThis uses `npins` for dependency locking. Install it and run this in the project\n\ndirectory:\n\n```bash\nnpins init\n```\n\nCreate a `default.nix` with the following:\n\n```nix\n# default.nix\n{ system ? builtins.currentSystem, sources ? import ./npins, }:\nlet\n  pkgs = import sources.nixpkgs {\n    config = { };\n    overlays = [ ];\n  };\n  inherit (pkgs) lib;\nin lib.makeScope pkgs.newScope (self: {\n\n  shell = pkgs.mkShell { packages = [ pkgs.npins self.myPackage ]; };\n\n    # inherit lib;\n\n  nixosSystem = import (sources.nixpkgs + \"/nixos\") {\n    configuration = ./configuration.nix;\n  };\n\n  moduleEvale = lib.evalModules {\n    modules = [\n      # ...\n    ];\n  };\n})\n```\n\nA `configuration.nix` with the following:\n\n```nix\n# configuration.nix\n{\n  boot.loader.grub.device = \"nodev\";\n  fileSystems.\"/\".device = \"/devst\";\n  system.stateVersion = \"25.05\";\n\n  # declaring options means to declare a new option\n  # defining options means to define a value of an option\n  imports = [\n    # ./main.nix\n     ./desktop.nix # Files\n    # ./minimal.nix\n  ];\n\n  # mine.desktop.enable = true;\n}\n```\n\nAnd a `desktop.nix` with the following:\n\n```nix\n# desktop.nix\n{ pkgs, lib, config, ... }:\n\n{\n  imports = [];\n\n  # Define an option to enable or disable desktop configuration\n  options.mine.desktop.enable = lib.mkEnableOption \"desktop settings\";\n\n  # Configuration that applies when the option is enabled\n  config = lib.mkIf config.mine.desktop.enable {\n    environment.systemPackages = [ pkgs.git ];\n  };\n}\n```\n\n`mkEnableOption` defaults to false. Now in your `configuration.nix` you can\nuncomment `mine.desktop.enable = true;` to enable the desktop config and\nvice-versa.\n\nYou can test that this works by running:\n\n```bash\nnix-instantiate -A nixosSystem.system\n```\n\n`nix-instantiate` performs only the evaluation phase of Nix expressions. During\nthis phase, Nix interprets the Nix code, resolves all dependencies, and\nconstructs derivations but does not execute any build actions. Useful for\ntesting.\n\nTo check if this worked and `git` is installed in systemPackages you can load it\ninto `nix repl` but first you'll want `lib` to be available so uncomment this in\nyour `default.nix`:\n\n```nix\n# default.nix\ninherit lib;\n```\n\nRerun `nix-instantiate -A nixosSystem.system`\n\nThen load the repl and check that `git` is in `systemPackages`:\n\n```bash\nnix repl -f .\nnix-repl> builtins.filter (pkg: lib.hasPrefix \"git\" pkg.name) nixosSystem.config.environment.systemPackages\n```\n\nThis shows the path to the derivation\n\nCheck that mine.desktop.enable is true\n\n```nix\nnix-repl> nixosSystem.config.mine.desktop.enable\ntrue\n```\n\nAs demonstrated with npins, explicitly managing the dependencies of your NixOS\nmodules is a powerful technique for ensuring the long-term stability and\nreproducibility of your system configurations. By pinning specific versions of\nNixpkgs and other resources, you gain greater control over your environment and\nreduce the risk of unexpected changes due to upstream updates.\n\n</details>\n\n### Best Practices\n\nYou'll see the following all throughout Nix code and is convenient although it\ndoesn't follow best practices. One reason is static analysis can't reason about\nthe code (e.g. Because it implicitly brings all attributes into scope, tools\ncan't verify which ones are actually being used), because it would have to\nactually evaluate the files to see which names are in scope:\n\n```nix\n# utils.nix\n{ pkgs, ... }: {\n  environment.systemPackages = with pkgs; [\n    rustup\n    evcxr\n    nix-prefetch-git\n  ];\n}\n```\n\nAnother reason the above expression is considered an \"anti-pattern\" is when more\nthen one `with` is used, it's no longer clear where the names are coming from.\n\nScoping rules for `with` are not intuitive, see\n[issue](https://github.com/NixOS/nix/issues/490) --nix.dev This can make\ndebugging harder, as searching for variable origins becomes ambiguous (i.e. open\nto more than one interpretation).\n\nThe following follows best practices:\n\n```nix\n{pkgs, ... }: {\n  environment.systemPackages = builtins.attrValues {\n    inherit (pkgs)\n      rustup\n      evcxr\n      nix-prefetch-git;\n  };\n}\n```\n\n- [Noogle builtins.attrValues](https://noogle.dev/f/builtins/attrValues)\n\n<details>\n<summary> ✔️ Above Command Summary (Click to Expand) </summary>\n\n```nix\n{\n  inherit (pkgs) rustup evcxr nix-prefetch-git;\n}\n```\n\nis equivalent to:\n\n```nix\n{\n  rustup = pkgs.rustup;\n  evcxr = pkgs.evcxr;\n  nix-prefetch-git = pkgs.nix-prefetch-git;\n}\n```\n\nApplying `builtins.attrValues` produces:\n\n```nix\n[ pkgs.evcxr pkgs.nix-prefetch-git pkgs.rustup ]\n```\n\nAs you can see only the values are included in the list, not the keys. This is\nmore explicit and declarative but can be more complicated, especially for a\nbeginner.\n\n`builtins.attrValues` returns the values of all attributes in the given set,\nsorted by attribute name. The above expression turns into something like the\nfollowing avoiding bringing every attribute name from `nixpkgs` into scope.\n\nA more straightforward example:\n\n```nix\nattrValues {c = 3; a = 1; b = 2;}\n=> [1 2 3]\n```\n\n</details>\n\nThis approach avoids unintended name clashes or confusion when debugging.\n\nUpon looking into this a bit further, most people use the following format to\navoid the \"anti-pattern\" from using `with pkgs;`:\n\n```nix\n# utils.nix\n{ pkgs, ... }: {\n  environment.systemPackages = [\n    pkgs.rustup\n    pkgs.evcxr\n    pkgs.nix-prefetch-git\n  ];\n}\n```\n\nWhile the performance differences might be negligible on modern computers,\nadopting this best practice from the start is highly recommended. The above\napproach is more explicit, it's clear exactly where each package is coming from.\n\nIf maintaining strict scope control matters, use `builtins.attrValues`.\n\nIf readability and simplicity are more your priority, explicitly referencing\n`pkgs.<packageName>` might be better. Now you can choose for yourself.\n\n#### Conclusion\n\nAs we have seen throughout this chapter, modules are the building blocks of your\nNixOS system and are themselves often functions. There are a few different ways\nto use these modules to build your system. In the next chapter,\n[Nix Flakes Explained](https://saylesss88.github.io/Nix_Flakes_Explained_4.html)\nwe will learn about Nix Flakes as a more modern and comprehensive entrypoint for\nmanaging your entire system and its dependencies.\n\nTo further deepen your understanding of NixOS Modules and the broader ecosystem\nof tools and best practices surrounding them, the following resources offer\nvaluable insights and information.\n\n#### Resources on Modules\n\n<details>\n<summary> ✔️ Resources (Click to Expand) </summary>\n\n- [WritingNixOsModules](https://nixos.org/manual/nixos/stable/#sec-writing-modules)\n\n- [NixWikiNixOSModules](https://nixos.wiki/wiki/NixOS_modules)\n\n- [nix.dev A basic module](https://nix.dev/tutorials/module-system/a-basic-module/index.html)\n\n- [ModuleSystemDeepDive](https://nix.dev/tutorials/module-system/deep-dive#module-system-deep-dive)\n\n- [xeiaso Nixos Modules for fun & profit](https://xeiaso.net/talks/asg-2023-nixos/)\n\n- [NixOS Flakes Book Module System](https://nixos-and-flakes.thiscute.world/other-usage-of-flakes/module-system)\n\n# Videos\n\n[NixHour Writing NixOS modules](https://www.youtube.com/watch?v=N7hFP_40DJo&t=17s)\n-- This example is from this video\n[infinisilModules](https://infinisil.com/modules.mp4)\n\n[tweagModuleSystemRecursion](https://www.youtube.com/watch?v=cZjOzOHb2ow)\n\n</details>\n","number":[5],"sub_items":[],"path":"NixOS_Modules_Explained_3.md","source_path":"NixOS_Modules_Explained_3.md","parent_names":[]}},{"Chapter":{"name":"Nix Flakes Explained","content":"---\ntitle: My Chapter\ndate: 2025-11-21\nauthor: saylesss88\ndescription: Chapter 4\n---\n\n# Chapter 4\n\n<details>\n<summary> ✔️ Click to Expand Table of Contents</summary>\n\n<!-- toc -->\n\n</details>\n\n![trees3](images/trees3.cleaned.png)\n\n<!-- <img src=\"images/gruv15.png\" width=\"800\" height=\"600\"> -->\n\n## Nix Flakes Explained\n\nIf you're completely new, take a look at\n[this](https://nixos.wiki/wiki/flakes#Installing_flakes) to get flakes on your\nsystem.\n\nFor the Nix Flake man page type `man nix3 flake` and for a specific feature,\ntype something like `man nix3 flake-lock`.\n\nFlakes replace stateful channels (which cause much confusion among novices) and\nintroduce a more intuitive and consistent CLI, making them a perfect opportunity\nto start using Nix. -- Alexander Bantyev\n[Practical Nix Flakes](https://serokell.io/blog/practical-nix-flakes)\n\nThe \"state\" being remembered and updated by channels is the specific revision of\nthe Nixpkgs repository that your local Nix installation considers \"current\" for\na given channel. When this state changes on your machine, your builds diverge\nfrom others whose machines have a different, independently updated channel\nstate.\n\nChannels are also constantly updated on the remote servers. So, \"nixos-unstable\"\ntoday refers to a different set of packages and versions than \"nixos-unstable\"\ndid yesterday or will tomorrow.\n\nFlakes solve this by making the exact revision of `nixpkgs` (and other\ndependencies) an explicit input within your `flake.nix` file, pinned in the\n`flake.lock`. This means the state is explicitly defined in the configuration\nitself, not implicitly managed by a global system setting.\n\nEvaluation time is notoriously slow on NixOS, the problem was that in the past\nNix evaluation wasn't hermetic preventing effective evaluation caching. A `.nix`\nfile can import other Nix files or by looking them up in the Nix search path\n(`$NIX_PATH`). This causes a cached result to be inconsistent unless every file\nis perfectly kept track of. Flakes solve this problem by ensuring fully hermetic\nevaluation.\n\n\"Hermetic\" means that the output of an evaluation (the derivation itself)\ndepends _only_ on the explicit inputs provided, not on anything external like\nenvironment variables or pulling in files only on your system. This is the\nproblem that Nix solves and the problem that flakes are built around.\n\n## What is a Nix Flake?\n\n**Nix flakes** are independent components in the Nix ecosystem. They define\ntheir own **dependencies** (inputs) and what they produce (outputs), which can\ninclude **packages**, **deployment configurations**, or **Nix functions** for\nother flakes to use.\n\nFlakes provide a standardized framework for building and managing software,\nmaking all project inputs explicit for greater reproducibility and\nself-containment.\n\nAt its core, a flake is a source tree (like a Git repository) that contains a\n`flake.nix` file in its root directory. This file provides a standardized way to\naccess Nix artifacts such as packages and modules.\n\nFlakes provide a standard way to write Nix expressions (and therefore packages)\nwhose dependencies are version-pinned in a lock file, improving reproducibility\nof Nix installations. -- NixOS Wiki\n\nThink of `flake.nix` as the central entry point of a flake. It not only defines\nwhat the flake produces but also declares its dependencies.\n\n### Key Concepts\n\n`flake.nix`: **The Heart of a Flake**\n\nThe `flake.nix` file is mandatory for any flake. It must contain an attribute\nset with at least one required attribute: `outputs`. It can also optionally\ninclude `description` and `inputs`.\n\n**Basic Structure:**\n\n```nix\n{\n  description = \"Package description\";\n  inputs = { /* Dependencies go here */ };\n  outputs = { /* What the flake produces */ };\n  nixConfig = { /* Advanced configuration options */ };\n}\n```\n\nI typically see `nixConfig` used for extra-substituters for cachix. This is a\ngeneral-purpose way to define Nix configuration options that apply when this\nflake is evaluated or built. It ties into your `/etc/nix/nix.conf` or\n`~/.config/nix/nix.conf`.\n\nFor example, create a directory and add a `flake.nix` with the following\ncontents, yes this is a complete `flake.nix` demonstrating _outputs_ being the\nonly required attribute:\n\n```nix\n# flake.nix\n{\n  outputs = _: { multiply = 2 * 2; };\n}\n```\n\nNow evaluate it with:\n\n```bash\nnix eval .#multiply\n4\n```\n\nIn the `outputs = _: { ... };` line, the `_` (underscore) is a placeholder\nargument. It represents the inputs that the outputs function could receive (like\n`inputs`, `self`, `pkgs`, etc.), but in this specific case, we're not using any\nof them to define the multiply attribute. It's a common convention in Nix to use\n`_` when an argument is required by a function but intentionally ignored.\n\nIn the command `nix eval .#multiply`:\n\n- the `.` signifies the current directory, indicating that Nix should look for a\n  `flake.nix` file in the directory where you're running the command.\n\n- The `#` is used to select a specific attribute from the `outputs` of the\n  flake. In this case, it's telling Nix to evaluate the `multiply` attribute.\n\nIn the next example we will create a `devShells` output as well as a `packages`\noutput.\n\n**`flake.lock` auto-generated lock file**\n\nAll flake inputs are pinned to specific revisions in a lockfile called\n`flake.lock` This file stores the revision info as JSON.\n\nThe `flake.lock` file ensures that Nix flakes have purely deterministic outputs.\nA `flake.nix` file without an accompanying `flake.lock` should be considered\nincomplete and a kind of proto-flake. Any Nix CLI command that is run against\nthe flake—like `nix build`, `nix develop`, or even `nix flake show`—generates a\n`flake.lock` for you.\n\nHere’s an example section of a `flake.lock` file that pins Nixpkgs to a specific\nrevision:\n\n```bash\n$ cat flake.lock\n{\n  \"nodes\": {\n    \"nixpkgs\": {\n      \"info\": {\n        \"lastModified\": 1587398327,\n        \"narHash\": \"sha256-mEKkeLgUrzAsdEaJ/1wdvYn0YZBAKEG3AN21koD2AgU=\"\n      },\n      \"locked\": {\n        \"owner\": \"NixOS\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"5272327b81ed355bbed5659b8d303cf2979b6953\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"NixOS\",\n        \"ref\": \"nixos-20.03\",\n        \"repo\": \"nixpkgs\",\n        \"type\": \"github\"\n      }\n    },\n    \"root\": {\n      \"inputs\": {\n        \"nixpkgs\": \"nixpkgs\"\n      }\n    }\n  },\n  \"root\": \"root\",\n  \"version\": 5\n}\n```\n\nAny future build of this flake will use the version of `nixpkgs` recorded in the\nlock file. If you add new inputs, they will be automatically added when you run\na nix flake command like `nix flake show`. But it won't replace existing locks.\n\nIf you need to update a locked input to the latest version:\n\n```bash\nnix flake lock --update-input nixpkgs\nnix build\n```\n\nThe above command allows you to update individual inputs, and `nix flake update`\nwill update the whole lock file.\n\n### Helper functions that are good to know for working with Flakes\n\n`lib.genAttrs`: A function, given the name of the attribute, returns the\nattribute's value\n\nExample:\n\n```nix\nnix repl\nnix-repl> :l <nixpkgs>\nnix-repl> lib.genAttrs [ \"boom\" \"bash\" ] (name: \"sonic\" + name)\n```\n\n**Output**:\n\n```nix\n{\n  bash = \"sonicbash\";\n  boom = \"sonicboom\";\n}\n```\n\nYou will often see the following:\n\nA common use for this with flakes is to have a list of different systems:\n\n```nix\n     systems = [\n       \"x86_64-linux\"\n       \"aarch64-linux\"\n       \"x86_64-darwin\"\n       \"aarch64-darwin\"\n     ];\n```\n\nAnd use it to generate an attribute set for each listed system:\n\n```nix\neachSystem = lib.genAttrs systems;\n```\n\nThe above command creates an attribute set by mapping over a list of system\nstrings. If you notice, you provide it a list (i.e. [ 1 2 3 ]) and the function\nreturns a set (i.e. `{ ... }`)\n\nWhy `genAttrs` is useful:\n\n- It lets you define attributes (like `packages`, `checks`, `devShells`) per\n  supported system in a DRY(don't repeat yourself), structured way.\n\n- `lib.mapAttrs`: A function, given an attribute's name and value, returns a new\n  `nameValuePair`.\n\nExample:\n\n```nix\nnix-repl> builtins.mapAttrs (name: value: name + \"-\" + value) { x = \"foo\"; y = \"bar\"; }\n```\n\n**Output**:\n\n```nix\n{\n  x = \"x-foo\";\n  y = \"y-bar\";\n}\n```\n\n`pkgs.mkShell`: is a specialized `stdenv.mkDerivation` that removes some\nrepetition when using it with `nix-shell` (or `nix develop`)\n\nExample:\n\n```nix\n{ pkgs ? import <nixpkgs> {} }:\npkgs.mkShell {\n  packages = [ pkgs.gnumake ];\n\n  inputsFrom = [ pkgs.hello pkgs.gnutar ];\n\n  shellHook = ''\n    export DEBUG=1\n  '';\n}\n```\n\n#### A Simple flake that outputs a devshell and a package\n\nIn a new directory create a `flake.nix`\n\n```nix\n# flake.nix\n{\n  outputs = {\n    self,\n    nixpkgs,\n  }: let\n    pkgs = nixpkgs.legacyPackages.x86_64-linux;\n  in {\n\n    packages.x86_64-linux.default = pkgs.kakoune; # You could define a meta-package here\n\n    devShells.x86_64-linux.default = pkgs.mkShell {\n      packages = [\n        pkgs.kakoune\n        pkgs.git\n        pkgs.ripgrep\n        pkgs.fzf\n      ];\n    };\n  };\n}\n```\n\n`mkShell` is a wrapper around `mkDerivation`\n\nThis flake offers two main outputs for `x86_64-linux` systems:\n\n1. A **standard package** (`packages.x86_64-linux.default`): This simple example\n   just re-exports `kakoune` from `nixpkgs`. You could build your own apps here.\n\n2. A **development shell** (`devShells.x86_64-linux.default`): This provides a\n   convenient environment where you have specific tools available without\n   installing them globally on your system.\n\nTo use this flake you have a few options:\n\n- `nix run` will launch kakoune\n\n- `nix develop` will activate the development environment providing all of the\n  pkgs listed under `mkShell`.\n\n- Or more explicitly `nix develop .#devShells.x86_64-linux.default`, does the\n  same thing as the command above.\n\n#### Flake References\n\n<details>\n<summary> ✔️ Flake References (Click to Expand) </summary>\n\n**Flake references** (flakerefs) are a way to specify the location of a flake.\nThey have two different formats:\n\n> **Attribute set representation**:\n>\n> ```nix\n> {\n>   type = \"github\";\n>   owner = \"NixOS\";\n>   repo = \"nixpkgs\";\n> }\n> ```\n>\n> or **URL-like syntax**:\n>\n> ```nix\n> github:NixOS/nixpkgs\n> ```\n>\n> These are used on the command line as a more convenient alternative to the\n> attribute set representation. For instance, in the command\n>\n> ```nix\n> nix build github:NixOS/nixpkgs#hello\n> ```\n>\n> `github:NixOS/nixpkgs` is a flake reference (while `hello` is an output\n> attribute). They are also allowed in the `inputs` attribute of a flake, e.g.\n>\n> ```nix\n> inputs.nixpkgs.url = \"github:NixOS/nixpkgs\";\n> ```\n>\n> is equivalent to\n>\n> ```nix\n> inputs.nixpkgs = {\n>   type = \"github\";\n>   owner = \"NixOS\";\n>   repo = \"nixpkgs\";\n> };\n> ```\n>\n> --\n> [nix.dev flake-references](https://nix.dev/manual/nix/2.24/command-ref/new-cli/nix3-flake#flake-references)\n\n</details>\n\n#### Nix Flake Commands\n\n<details>\n<summary> ✔️ Flake Commands (Click to Expand) </summary>\n\n> `nix flake` provides subcommands for creating, modifying and querying _Nix\n> Flakes_. Flakes are the unit for packaging Nix code in a reproducible and\n> discoverable way. They can have dependencies on other flakes, making it\n> possible to have multi-repository Nix projects.\n\n— From\n[nix.dev Reference Manual](https://nix.dev/manual/nix/2.28/command-ref/new-cli/nix3-flake)\n\n- The main thing to note here is that `nix flake` is used to manage Nix flakes\n  and that Flake commands are whitespace separated rather than hyphen `-`\n  separated.\n\n- Flakes do provide some advantages when it comes to discoverability of outputs.\n\n- For Example, two helpful commands to inspect a flake are:\n  - [nix flake show](https://nix.dev/manual/nix/2.28/command-ref/new-cli/nix3-flake-show)\n    command: Show the outputs provided by a flake.\n\n  - [nix flake check](https://nix.dev/manual/nix/2.28/command-ref/new-cli/nix3-flake-check)\n    command: check whether the flake evaluates and run its tests.\n\n  - Any Nix CLI command that is run against a flake -- like `nix build`,\n    `nix develop`, `nix flake show` -- generate a `flake.lock` file for you.\n    - The `flake.lock` file ensures that all flake inputs are pinned to specific\n      revisions and that Flakes have purely deterministic outputs.\n\n  Example:\n\n```bash\nnix shell nixpkgs#ponysay --command ponysay \"Flakes Rock!\"\n```\n\nThis works because of the [flake registry] that maps symbolic identifiers like\n`nixpkgs` to actual locations such as `https://github.com/NixOS/nixpkgs`. So the\nfollowing are equivalent:\n\n```bash\nnix shell nixpkgs#ponysay --command ponysay Flakes Rock!\nnix shell github:NixOS/nixpkgs#ponysay --command ponysay Flakes Rock!\n```\n\nTo override the `nixpkgs` registry with your own local copy you could:\n\n```bash\nnix registry add nixpkgs ~/src/local-nixpkgs\n```\n\n</details>\n\n### Attribute Sets: The Building Blocks\n\n<details>\n<summary> ✔️ Attribute set Refresher (Click to Expand) </summary>\n\n**Attribute sets** are fundamental in Nix. They are simply collections of\nname-value pairs wrapped in curly braces `{}`.\n\n- Example, (click to see Output):\n\n```nix\nlet\n  my_attrset = { foo = \"bar\"; };\nin\nmy_attrset.foo\n~ \"bar\"\n```\n\n**Top-Level Attributes of a Flake**:\n\nFlakes have specific **top-level attributes** that can be accessed directly\n(without dot notation). The most common ones are `inputs`, `outputs`, and\n`nixConfig`.\n\n  </details>\n\n### Deeper Dive into the Structure of `flake.nix`\n\n<!-- ![Flakes](images/Flakes.png) -->\n\n`inputs`: **Declaring Dependencies**\n\nThe `inputs` attribute set specifies the other flakes that your current flake\ndepends on.\n\nEach key in the `inputs` set is a name you choose for the dependency, and the\nvalue is a reference to that flake (usually a URL or a Git Repo).\n\nTo access something from a dependency, you generally go through the `inputs`\nattribute (e.g., `inputs.helix.packages`).\n\nSee\n[Nix Flake inputs](https://saylesss88.github.io/flakes/flake_inputs_4.1.html)\nfor a flake inputs deep dive.\n\n**Example:** This declares dependencies on the `nixpkgs` and `import-cargo`\nflakes:\n\n```nix\ninputs = {\n  import-cargo.url = \"github:edolstra/import-cargo\";\n  nixpkgs.url = \"nixpkgs\";\n};\n```\n\nWhen Nix evaluates your flake, it fetches and evaluates each input. These\nevaluated inputs are then passed as an attribute set to the outputs function,\nwith the keys matching the names you gave them in the inputs set.\n\nThe special input `self` is a reference to the `outputs` and the source tree of\nthe current flake itself.\n\n**`outputs`: Defining What Your Flake Provides**\n\nThe **`outputs`** attribute defines what your flake makes available. This can\ninclude packages, NixOS modules, development environments (`devShells`) and\nother Nix derivations.\n\nFlakes can output arbitrary Nix values. However, certain outputs have specific\nmeanings for Nix commands and must adhere to particular types (often\nderivations, as described in the\n[output schema](https://nixos.wiki/wiki/Flakes)).\n\nYou can inspect the outputs of a flake using the command:\n\n```nix\nnix flake show\n```\n\n> This command takes a flake URI and displays its outputs in a tree structure,\n> showing the attribute paths and their corresponding types.\n\n**Understanding the `outputs` Function**\n\nBeginners often mistakenly think that self and nixpkgs within\n`outputs = { self, nixpkgs, ... }: { ... }` are the outputs themselves. Instead,\nthey are the _input arguments_ (often called _output arguments_) to the outputs\nfunction.\n\nThe outputs function in `flake.nix` always takes a single argument, which is an\nattribute set. The syntax `{ self, nixpkgs, ... }` is Nix's way of destructuring\nthis single input attribute set to extract the values associated with the keys\n`self` and `nixpkgs`.\n\nFlakes output your whole system configuration, packages, as well as Nix\nfunctions for use elsewhere.\n\n- For example, the `nixpkgs` repository has its own `flake.nix` file that\n  outputs many helper functions via the `lib` attribute.\n\n- For a deep dive into flake outputs, see\n  [Nix Flake Outputs](https://saylesss88.github.io/flakes/flake_outputs_4.2.html)\n\n> The `lib` convention The convention of using `lib` to output functions is\n> observed not just by Nixpkgs but by many other Nix projects. You’re free,\n> however, to output functions via whichever attribute you prefer. --\n> [Zero to Nix Flakes](https://zero-to-nix.com/concepts/flakes/#inputs)\n\nSome flake outputs are required to be system specific (i.e. \"x86_64-linux\" for\n(64-bit AMD/Intel Linux) including packages, development environments, and NixOS\nconfigurations)\n\n**Variadic Attributes (...) and @-patterns**\n\nThe `...` syntax in the input arguments of the outputs function indicates\nvariadic attributes, meaning the input attribute set can contain more attributes\nthan just those explicitly listed (like `lib` and `nixpkgs`).\n\n**Example:**\n\n```nix\nmul = { a, b, ... }: a * b;\nmul { a = 3; b = 4; c = 2; } # 'c' is an extra attribute\n```\n\nHowever, you cannot directly access these extra attributes within the function\nbody unless you use the @-pattern:\n\n- (Click for Output)\n\n```nix\nmul = s@{ a, b, ... }: a  b  s.c; # 's' now refers to the entire input set\nmul { a = 3; b = 4; c = 2; } # Output: 24\n~ 24\n```\n\nWhen used in the outputs function argument list (e.g.,\n`outputs = { pkgs, ... } @ inputs)`, the @-pattern binds the entire input\nattribute set to a name (in this case, `inputs`) while also allowing you to\ndestructure specific attributes like pkgs.\n\n**What `outputs = { pkgs, ... } @ inputs: { ... };` does:**\n\n1. **Destructuring:** It tries to extract the value associated with the key\n   `pkgs` from the input attribute set and binds it to the variable `pkgs`. The\n   `...` allows for other keys in the input attribute set to be ignored during\n   this direct destructuring.\n\n2. **Binding the Entire Set:** It binds the entire input attribute set to the\n   variable inputs.\n   - Example `flake.nix`:\n\n```nix\n{\ninputs.nixpkgs.url = \"github:NixOS/nixpkgs/nixos-unstable\";\ninputs.home-manager.url = \"github:nix-community/home-manager\";\n\noutputs = { self, nixpkgs, ... } @ attrs: { # A `packages` output for the x86_64-linux platform\npackages.x86_64-linux.hello = nixpkgs.legacyPackages.x86_64-linux.hello;\n\n    # A `nixosConfigurations` output (for a NixOS system named \"fnord\")\n    nixosConfigurations.fnord = nixpkgs.lib.nixosSystem {\n      system = \"x86_64-linux\";\n      specialArgs = attrs;\n      modules = [ ./configuration.nix ];\n    };\n\n};\n}\n```\n\n**Platform Specificity in Outputs**\n\nFlakes ensure that their outputs are consistent across different evaluation\nenvironments. Therefore, any package-related output must explicitly specify the\ntarget platform (a combination of architecture and OS, `x86_64-linux`).\n\n**legacyPackages Explained**\n\n`legacyPackages` is a way for flakes to interact with the traditional, less\nstructured package organization of nixpkgs. Instead of packages being directly\nat the top level (e.g., `pkgs.hello`), `legacyPackages` provides a\nplatform-aware way to access them within the flake's structured output format\n(e.g., `nixpkgs.legacyPackages.x86_64-linux.hello`). It acts as a bridge between\nthe flake's expected output structure and nixpkgs's historical organization.\n\n**The Sole Argument of outputs**\n\nIt's crucial to remember that the outputs function accepts only one argument,\nwhich is an attribute set. The `{ self, nixpkgs, ... }` syntax is simply\ndestructuring that single input attribute set.\n\n**Outputs of the Flake (Return Value)**\n\nThe outputs of the flake refer to the attribute set that is returned by the\n`outputs` function. This attribute set can contain various named outputs like\n`packages`, `nixosConfigurations`, `devShells`, etc.\n\n**Imports: Including Other Nix Expressions**\n\nThe `import` function in Nix is used to evaluate the Nix expression found at a\nspecified path (usually a file or directory) and return its value.\n\nBasic Usage: import `./path/to/file.nix`\n\n**Passing Arguments During Import**\n\n`import <nixpkgs> {}` is calling two functions, not one.\n\n1. `import <nixpkgs>`: The first function call\n\n- `import` is a built-in Nix function. Its job is to load and evaluate a Nix\n  expression from a specified path.\n\n- `<nixpkgs>` is a flake reference. When you use `import <nixpkgs>`, Nix\n  evaluates the `default.nix` file (or sometimes `lib/default.nix`) found at\n  that location.\n\n- The `default.nix` in `nixpkgs` evaluates to a function. This function is\n  designed to be configurable, allowing you to pass arguments like `system`,\n  `config`, etc. to customize how `nixpkgs` behaves and what packages it\n  provides.\n\n- So, `import <nixpkgs>` doesn't give you the `nixpkgs` package set directly; it\n  gives you the function that generates the `nixpkgs` package set derivation.\n\n2. `{}`: The second function call (and its argument)\n\n- `{}` denotes an empty attribute set\n\n- When an attribute set immediately follows a function, it means you are calling\n  that function and passing the attribute set as its single argument.\n\nSo, the `{}` after `import <nixpkgs>` is not part of the `import` function\niteself. It's the argument being passed to the function that `import <nixpkgs>`\njust returned.\n\nYou can also pass an attribute set as an argument to the Nix expression being\nimported:\n\n```nix\nlet\nmyHelpers = import ./lib/my-helpers.nix { pkgs = nixpkgs; };\nin\n# ... use myHelpers\n```\n\nIn this case, the Nix expression in `./lib/my-helpers.nix` is likely a function\nthat expects an argument (often named `pkgs` by convention):\n\n```nix\n# ./lib/my-helpers.nix\n\n{ pkgs }:\nlet\nmyPackage = pkgs.stdenv.mkDerivation {\nname = \"my-package\"; # ...\n};\nin\nmyPackage\n```\n\nBy passing `{ pkgs = nixpkgs; }` during the import, you are providing the\nnixpkgs value from your current `flake.nix` scope to the pkgs parameter expected\nby the code in `./lib/my-helpers.nix`.\n\n**Importing Directories (`default.nix`)**\n\nWhen you use import with a path that points to a directory, Nix automatically\nlooks for a file named `default.nix` within that directory. If found, Nix\nevaluates the expressions within `default.nix` as if you had specified its path\ndirectly in the import statement.\n\n- For more advanced examples see\n  [Nix Flake Examples](https://saylesss88.github.io/flakes/flake_examples_4.3.html)\n\n##### Conclusion: Unifying Your Nix Experience with Flakes\n\nFor some examples of more advanced outputs like `devShells` and `checks`, check\nout this blog post that I wrote:\n[Nix Flakes Tips and Tricks](https://tsawyer87.github.io/posts/nix_flakes_tips/)\n\nIn this chapter, we've explored Nix Flakes as a powerful and modern approach to\nmanaging Nix projects, from development environments to entire system\nconfigurations. We've seen how they provide structure, dependency management,\nand reproducibility through well-defined inputs and outputs. Flakes offer a\ncohesive way to organize your Nix code and share it with others.\n\nAs we've worked with the flake.nix file, you've likely noticed its structure – a\ntop-level attribute set defining various outputs like devShells, packages,\nnixosConfigurations, and more. These top-level attributes are not arbitrary;\nthey follow certain conventions and play specific roles within the Flake\necosystem.\n\nIn the next chapter,\n[Understanding Top-Level Attributes](https://saylesss88.github.io/Understanding_Top-Level_Attributes_5.html)\nwe will delve deeper into the meaning and purpose of these common top-level\nattributes. We'll explore how they are structured, what kind of expressions they\ntypically contain, and how they contribute to the overall functionality and\norganization of your Nix Flakes. Understanding these attributes is key to\neffectively leveraging the full potential of Nix Flakes.\n\n##### Further Resources\n\n<details>\n<summary> ✔️ Resources (Click to Expand)</summary>\n\n- [practical-nix-flakes](https://serokell.io/blog/practical-nix-flakes)\n\n- [Nix Flakes an Introduction](https://xeiaso.net/blog/nix-flakes-1-2022-02-21/)\n\n- [tweag nix-flakes](https://www.tweag.io/blog/2020-07-31-nixos-flakes/)\n\n- [NixOS-wiki Flakes](https://nixos.wiki/wiki/Flakes)\n\n- [nix.dev flakes](https://nix.dev/concepts/flakes.html)\n\n- [anatomy-of-a-flake](https://vtimofeenko.com/posts/practical-nix-flake-anatomy-a-guided-tour-of-flake.nix/)\n\n- [flakes-arent-real](https://jade.fyi/blog/flakes-arent-real/)\n\n- [wombats-book-of-nix](https://mhwombat.codeberg.page/nix-book/#_attribute_set_operations)\n\n- [zero-to-nix flakes](https://zero-to-nix.com/concepts/flakes/)\n\n- [nixos-and-flakes-book](https://nixos-and-flakes.thiscute.world/)\n\n- [FlakeHub](https://flakehub.com/)\n\n![FlakeHub](images/nixosnix.png)\n\n</details>\n","number":[6],"sub_items":[{"Chapter":{"name":"Nix Flake Inputs","content":"# Nix Flake Inputs\n\n<details>\n<summary> ✔️ Click to Expand Table of Contents</summary>\n\n<!-- toc -->\n\n</details>\n\nThe attribute `inputs` specifies the dependencies of a flake, as an attrset\nmapping input names to flake references.\n\nIf a repository provides a `flake.nix` you can include it as an input in your\n`flake.nix`.\n\nFor example, I like yazi as my file explorer and have been using helix as my\neditor. To be able to get yazi to work with helix I needed the latest versions\nof both yazi and helix. One way to get the latest versions was to add their\nflakes as inputs to my flake:\n\n```nix\n{\n\tinputs = {\n\t\tnixpkgs.url = \"github:NixOS/nixpkgs/nixos-24.11\";\n\t\thome-manager = {\n\t\t\turl = \"github:nix-community/home-manager/release-24.11\";\n\t\t\tinputs.nixpkgs.follows = \"nixpkgs\";\n\t\t};\n    helix = {\n      url = \"github:helix-editor/helix\";\n      inputs.nixpkgs.follows = \"nixpkgs\";\n    };\n\t\tyazi.url = \"github:sxyazi/yazi\";\n\t};\n\toutputs = { nixpkgs, home-manager, ... } @ inputs: {\n\t# ... snip ... #\n```\n\n- Now to use this input, I would reference these inputs in both my yazi and\n  helix modules:\n\n```nix\n# yazi.nix\n{ pkgs, config, inputs, ... }: {\n\tprograms.yazi = {\n\t\tenable = true;\n\t\tpackage = inputs.yazi.packages.${pkgs.system}.default;\n\t};\n}\n```\n\n```nix\n# helix.nix\n{ pkgs, config, inputs, ... }: {\n\tprograms.helix = {\n\t\tenable = true;\n\t\tpackage = inputs.helix.packages.${pkgs.system}.helix;\n\t};\n}\n```\n\nUnderstanding `.default` vs. Named Outputs (e.g., `.helix`) from the Source\n\nThe difference between `inputs.yazi.packages.${pkgs.system}.default` and\n`inputs.helix.packages.${pkgs.system}.helix` comes down to how the respective\nupstream flakes define their outputs. You can always inspect a flake's\n`flake.nix` or use `nix flake show <flake-reference>` to understand its\nstructure.\n\n## Helix `flake.nix`\n\nLet's look at the relevant section of Helix's `flake.nix` click the eye to see\nthe full flake:\n\n```nix\n~ {\n~   description = \"A post-modern text editor.\";\n~\n~   inputs = {\n~     nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n~     rust-overlay = {\n~       url = \"github:oxalica/rust-overlay\";\n~       inputs.nixpkgs.follows = \"nixpkgs\";\n~     };\n~   };\n~\n~   outputs = {\n~     self,\n~     nixpkgs,\n~     rust-overlay,\n~     ...\n~   }: let\n~     inherit (nixpkgs) lib;\n~     systems = [\n~       \"x86_64-linux\"\n~       \"aarch64-linux\"\n~       \"x86_64-darwin\"\n~       \"aarch64-darwin\"\n~     ];\n~     eachSystem = lib.genAttrs systems;\n~     pkgsFor = eachSystem (system:\n~       import nixpkgs {\n~         localSystem.system = system;\n~         overlays = [(import rust-overlay) self.overlays.helix];\n~       });\n~     gitRev = self.rev or self.dirtyRev or null;\n   in {\n     packages = eachSystem (system: {\n       inherit (pkgsFor.${system}) helix;\n       /*\n       The default Helix build. Uses the latest stable Rust toolchain, and unstable\n       nixpkgs.\n\n       The build inputs can be overridden with the following:\n\n       packages.${system}.default.override { rustPlatform = newPlatform; };\n\n       Overriding a derivation attribute can be done as well:\n\n       packages.${system}.default.overrideAttrs { buildType = \"debug\"; };\n       */\n      default = self.packages.${system}.helix;\n    });\n~    checks =\n~      lib.mapAttrs (system: pkgs: let\n~        # Get Helix's MSRV toolchain to build with by default.\n~        msrvToolchain = pkgs.pkgsBuildHost.rust-bin.fromRustupToolchainFile ./rust-toolchain.toml;\n~        msrvPlatform = pkgs.makeRustPlatform {\n~          cargo = msrvToolchain;\n~          rustc = msrvToolchain;\n~        };\n~      in {\n~        helix = self.packages.${system}.helix.override {\n~          rustPlatform = msrvPlatform;\n~        };\n~      })\n~      pkgsFor;\n~\n~    # Devshell behavior is preserved.\n~    devShells =\n~      lib.mapAttrs (system: pkgs: {\n~        default = let\n~          commonRustFlagsEnv = \"-C link-arg=-fuse-ld=lld -C target-cpu=native --cfg tokio_unstable\";\n~          platformRustFlagsEnv = lib.optionalString pkgs.stdenv.isLinux \"-Clink-arg=-Wl,--no-rosegment\";\n~        in\n~          pkgs.mkShell {\n~            inputsFrom = [self.checks.${system}.helix];\n~            nativeBuildInputs = with pkgs;\n~              [\n~                lld\n~                cargo-flamegraph\n~                rust-bin.nightly.latest.rust-analyzer\n~              ]\n~              ++ (lib.optional (stdenv.isx86_64 && stdenv.isLinux) cargo-tarpaulin)\n~              ++ (lib.optional stdenv.isLinux lldb)\n~              ++ (lib.optional stdenv.isDarwin darwin.apple_sdk.frameworks.CoreFoundation);\n~            shellHook = ''\n~              export RUST_BACKTRACE=\"1\"\n~              export RUSTFLAGS=\"''${RUSTFLAGS:-\"\"} ${commonRustFlagsEnv} ${platformRustFlagsEnv}\"\n~            '';\n~          };\n~      })\n~      pkgsFor;\n~\n~    overlays = {\n~      helix = final: prev: {\n~        helix = final.callPackage ./default.nix {inherit gitRev;};\n~      };\n~\n~      default = self.overlays.helix;\n~    };\n~  };\n~  nixConfig = {\n~    extra-substituters = [\"https://helix.cachix.org\"];\n~    extra-trusted-public-keys = [\"helix.cachix.org-1:ejp9KQpR1FBI2onstMQ34yogDm4OgU2ru6lIwPvuCVs=\"];\n~  };\n~}\n```\n\nDissecting `inherit (pkgsFor.${system}) helix;`\n\nImagine the Nix evaluation process for Helix `flake.nix` in the `outputs`\nsection:\n\n1. `packages = eachSystem (system: { ... });` Part iterates through each\n   `system` (like `x86_64-linux`). For each `system`, it's creating an attribute\n   set that will become `self.packages.${system}`.\n\n2. Inside the `eachSystem` function, for a specific system (e.g.\n   `x86_64-linux`): The code is building an attribute set that will ultimately\n   be assigned to `self.packages.x86_64-linux`.\n\n3. When you write `inherit (sourceAttrset) attributeName;`, it's equivalent to\n   writing `attributeName = sourceAttrset.attributeName;`.\n\nSo, `inherit (pkgsFor.${system}) helix;` is equivalent to:\n\n```nix\nhelix = pkgsFor.${system}.helix;\n```\n\nTherefore, because of `inherit (pkgsFor.${system}) helix;`, the helix attribute\nis explicitly defined under\n`packages.${system}``. This is why you access it as `inputs.helix.packages.${pkgs.system}.helix;`.\n\n## Yazi `flake.nix`\n\nNow this is yazi's `flake.nix`, yazi's documentation tells you to use `.default`\nbut lets examine the flake and see why:\n\n```nix\n~{\n~  inputs = {\n~    nixpkgs.url = \"github:NixOS/nixpkgs/nixpkgs-unstable\";\n~    flake-utils.url = \"github:numtide/flake-utils\";\n~    rust-overlay = {\n~      url = \"github:oxalica/rust-overlay\";\n~      inputs.nixpkgs.follows = \"nixpkgs\";\n~    };\n~  };\n~\n~  outputs =\n~    {\n~      self,\n~      nixpkgs,\n~      rust-overlay,\n~      flake-utils,\n~      ...\n~    }:\n~    flake-utils.lib.eachDefaultSystem (\n~      system:\n~      let\n~        pkgs = import nixpkgs {\n~          inherit system;\n~          overlays = [ rust-overlay.overlays.default ];\n~        };\n~        toolchain = pkgs.rust-bin.stable.latest.default;\n~        rustPlatform = pkgs.makeRustPlatform {\n~          cargo = toolchain;\n~          rustc = toolchain;\n~        };\n~\n~        rev = self.shortRev or self.dirtyShortRev or \"dirty\";\n~        date = self.lastModifiedDate or self.lastModified or \"19700101\";\n~        version =\n~          (builtins.fromTOML (builtins.readFile ./yazi-fm/Cargo.toml)).package.version\n~          + \"pre${builtins.substring 0 8 date}_${rev}\";\n~      in\n      {\n        packages = {\n          yazi-unwrapped = pkgs.callPackage ./nix/yazi-unwrapped.nix {\n            inherit\n              version\n              rev\n              date\n              rustPlatform\n              ;\n          };\n          yazi = pkgs.callPackage ./nix/yazi.nix { inherit (self.packages.${system}) yazi-unwrapped; };\n          default = self.packages.${system}.yazi;\n        };\n\n~        devShells = {\n~          default = pkgs.callPackage ./nix/shell.nix { };\n~        };\n~\n~        formatter = pkgs.nixfmt-rfc-style;\n~      }\n~    )\n~    // {\n~      overlays = {\n~        default = self.overlays.yazi;\n~        yazi = _: prev: { inherit (self.packages.${prev.stdenv.system}) yazi yazi-unwrapped; };\n~      };\n~    };\n~}\n```\n\nIn this case using `inputs.yazi.packages.${pkgs.system}.yazi` would also work\n\n- `yazi = pkgs.callPackage ./nix/yazi.nix { inherit (self.packages.${system}) yazi-unwrapped; };`\n  This line defines the yazi variable (or, more precisely, creates an attribute\n  named yazi within the `packages.${system}` set). It assigns to this yazi\n  attribute the result of calling the Nix expression in `./nix/yazi.nix` with\n  yazi-unwrapped as an argument. This yazi attribute represents the actual,\n  runnable Yazi package.\n\n- `default = self.packages.${system}.yazi;` This line then aliases the yazi\n  package. It creates another attribute named `default` within the same\n  `packages.${system}` set and points it directly to the yazi attribute that was\n  just defined.\n\n- So, when you access `inputs.yazi.packages.${pkgs.system}.default`, you're\n  effectively following the alias to the yazi package.\n\n- The choice to use `.default` is primarily for convenience and adherence to a\n  common flake convention, making the flake easier for users to consume without\n  needing to dive into its internal structure.\n","number":[6,1],"sub_items":[],"path":"flakes/flake_inputs_4.1.md","source_path":"flakes/flake_inputs_4.1.md","parent_names":["Nix Flakes Explained"]}},{"Chapter":{"name":"Nix Flake Outputs","content":"# Nix Flake Outputs\n\n<details>\n<summary> ✔️ Click to Expand Table of Contents</summary>\n\n<!-- toc -->\n\n</details>\n\nFlake outputs are what the flake produces when built. Flakes can have multiple\noutputs simultaneously such as:\n\n- **Packages**: Self-contained bundles that are built using derivations and\n  provide either some kind of software or dependencies of software.\n\n- [NixOS modules](https://saylesss88.github.io/NixOS_Modules_Explained_3.html)\n\n- Nix development environments\n\n- [Nix templates](https://github.com/NixOS/templates)\n\n- The `outputs` top-level attribute is actually a function that takes an attribute\n  set of inputs and returns an attribute set that is essentially a recipe for\n  building the flake.\n\n## Output Schema\n\nOnce the inputs are resolved, they're passed to the `outputs` attribute. This\n`outputs` attribute is, in fact, a function, as indicated by the `:` colon\n(or the `lambda` syntax) that follows its definition. This function takes the\nresolved inputs (and `self`, the flake's directory in the store) as arguments,\nand its return value dictates the outputs of the flake, following this schema:\n\n```nix\n{ self, nixpkgs, ... }@inputs:\n{\n  # Executed by `nix flake check`\n  checks.\"<system>\".\"<name>\" = derivation;\n  # Executed by `nix build .#<name>`\n  packages.\"<system>\".\"<name>\" = derivation;\n  # Executed by `nix build .`\n  packages.\"<system>\".default = derivation;\n  # Executed by `nix run .#<name>`\n  apps.\"<system>\".\"<name>\" = {\n    type = \"app\";\n    program = \"<store-path>\";\n  };\n  # Executed by `nix run . -- <args?>`\n  apps.\"<system>\".default = { type = \"app\"; program = \"...\"; };\n\n  # Formatter (alejandra, nixfmt or nixpkgs-fmt)\n  formatter.\"<system>\" = derivation;\n  # Used for nixpkgs packages, also accessible via `nix build .#<name>`\n  legacyPackages.\"<system>\".\"<name>\" = derivation;\n  # Overlay, consumed by other flakes\n  overlays.\"<name>\" = final: prev: { };\n  # Default overlay\n  overlays.default = final: prev: { };\n  # Nixos module, consumed by other flakes\n  nixosModules.\"<name>\" = { config, ... }: { options = {}; config = {}; };\n  # Default module\n  nixosModules.default = { config, ... }: { options = {}; config = {}; };\n  # Used with `nixos-rebuild switch --flake .#<hostname>`\n  # nixosConfigurations.\"<hostname>\".config.system.build.toplevel must be a derivation\n  nixosConfigurations.\"<hostname>\" = {};\n  # Used by `nix develop .#<name>`\n  devShells.\"<system>\".\"<name>\" = derivation;\n  # Used by `nix develop`\n  devShells.\"<system>\".default = derivation;\n  # Hydra build jobs\n  hydraJobs.\"<attr>\".\"<system>\" = derivation;\n  # Used by `nix flake init -t <flake>#<name>`\n  templates.\"<name>\" = {\n    path = \"<store-path>\";\n    description = \"template description goes here?\";\n  };\n  # Used by `nix flake init -t <flake>`\n  templates.default = { path = \"<store-path>\"; description = \"\"; };\n}\n```\n\nThe first line `{ self, nixpkgs, ... }@ inputs:` defines the functions parameters:\nIt's important to understand that within the scope of the `outputs` function\n`nixpkgs` is available at the top-level because we explicitly passed it as an\nargument but for individual modules outside this flake the scope is lost,\nand you need to use `inputs.nixpkgs` (or equivalent)\n\n1. It explicitly names the `self` attribute, making it directly accessible.\n   The variadic `...` ellipses part of the function signature is what allows\n   all your flake inputs to be brought into the function's scope without having\n   to list each one explicitly.\n\n2. It destructures all other attributes (your defined `inputs`) into the\n   functions scope.\n\n3. It gives you a convenient single variable, `inputs`, that refers to the\n   entire attribute set passed to the `outputs` function. This allows you to\n   access inputs either individually (e.g. `nixpkgs`) or through the `inputs`\n   variable (e.g. `inputs.nixpkgs`).\n\nYou can also define additional arbitrary attributes, but these are the outputs\nthat Nix knows about.\n\nAs you can see, the majority of the outputs within the outputs schema expect a\nderivation. This means that for packages, applications, formatters, checks,\nand development shells, you'll be defining a Nix derivation—a set of\ninstructions that tells Nix how to build a particular software component. This\nis central to Nix's declarative nature.\n\n- The command `nix flake show`, takes a flake URI and prints all the outputs of\n  the flake as a nice tree structure, mapping attribute paths to the types of values.\n\n```bash\n  ~/players/third  3s\n❯ nix flake show\npath:/home/jr/players/third?lastModified=1748272555&narHash=sha256-oNzkC6X9hA0MpOBmJSZ89w4znXxv4Q5EkFhp0ewehY0%3D\n├───nixosConfigurations\n│   └───testing: NixOS configuration\n└───nixosModules\n    └───default: NixOS module\n```\n\nTo show you the structure of this little flake project:\n\n```bash\n  ~/players\n❯ tree\n .\n├──  first\n│   ├──  flake.lock\n│   ├──  flake.nix\n│   └──  result -> /nix/store/701vyaanmqchd2nnaq71y65v8ws11zx0-nixos-system-nixos-24.11.20250523.f09dede\n├──  second\n│   ├──  flake.lock\n│   └──  flake.nix\n└──  third\n    ├──  flake.lock\n    ├──  flake.nix\n    └──  result -> /nix/store/mlszr5ws3xaly8m4q9jslgs31w6w76y2-nixos-system-nixos-24.11.20250523.f09dede\n```\n\n## Simple Example providing an output\n\n```nix\n# flake.nix\n{\n  outputs = { self }: {\n    bada = \"bing\";\n  };\n}\n```\n\nYou can then evaluate this specific output using `nix eval`:\n\n```bash\nnix eval .#bada\n\"bing\"\n```\n\n## Outputs understood by Nix\n\nWhile the attribute set that `outputs` returns may contain arbitrary attributes,\nmeaning any valid Nix value. Some of the standard outputs are understood by\nvarious `nix` utilities. `packages` is one of these:\n\n```nix\n# flake.nix\n{\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs\";\n  };\n\n  outputs = { self, nixpkgs }: {\n    # this is the re-exporting part!\n    packages.x86_64-linux.hello = nixpkgs.legacyPackages.x86_64-linux.hello;\n  };\n}\n```\n\n- Re-exporting happens when you take the value of `hello` in its standard\n  derivation format, exactly as `nixpkgs` produces it and assign it to an\n  attribute in your own flake's outputs.\n\n  - `packages.x86_64-linux.hello`(your flake's output path)\n    `=` ` nixpkgs.legacyPackages.x86_64-linux.hello`(the source from the `nixpkgs`\n    flake's output)\n\n  - We're saying, My flakes `hello` package is exactly the same as the `hello`\n    package found inside the `nixpkgs` input flake.\n\n  - It's important to understand that within the scope of the `outputs` function\n    (i.e. within your flake), `nixpkgs` is available at the top-level (i.e. the\n    `= nixpkgs` part) because we explicitly passed it as an argument but for\n    individual modules outside of this flake the scope is lost, and `inputs.nixpkgs`\n    is needed.\n\nThe following command builds the reexported package:\n\n```bash\nnix build .#hello\n```\n\nor run it with:\n\n```bash\nnix run .#hello\n```\n\nYou might notice `x86_64-linux` appearing in the package path, and there's a good\nreason for it. Flakes are designed to provide _hermetic evaluation_, meaning\ntheir outputs should be identical regardless of the environment where they're\nbuilt. A key factor in any build system is the platform (which combines the\narchitecture and operating system, like `x86_64-linux` or `aarch64-darwin`).\n\nBecause of Nix's commitment to reproducibility across different systems, any\nflake output that involves building software packages must explicitly specify\nthe platform. The standard approach is to structure these outputs as an\nattribute set where the names are platforms, and the values are the outputs\nspecific to that platform. For the packages output, each platform-specific\nvalue is itself an attribute set containing the various packages built for\nthat particular system.\n\n## Exporting Functions\n\nThis example outputs a `sayGoodbye` function, via the `lib` attribute, that takes\na name for its input and outputs a string saying Goodbye very nicely to the person\nwith that name:\n\n```nix\n{\n  outputs = { self }: {\n    lib = {\n      sayGoodbye = name: \"Goodbye F*** Off, ${name}!\";\n    };\n  };\n}\n```\n\nYou could then specify this flake as an input to another flake and use `sayGoodbye`\nhowever you'd like.\n\nOr load it into the `nix repl` like so:\n\n```bash\nnix repl\nnix-repl> :lf .\nnix-repl> lib.sayGoodbye\n«lambda sayGoodbye @ /nix/store/665rwfvkwdx6kwvk9ldijp2a6jvcgv1n-source/flake.nix:4:20»\nnix-repl> lib.sayGoodbye \"Jr\"\n\"Goodbye F*** Off, Jr!\"\n```\n\n- As you can see, specifying `lib.sayGoodbye` without any arguments returns a\n  function. (a lambda function)\n\n## Simplifying Multi-Platform Outputs with flake-utils\n\nManually repeating these platform definitions for every output (`packages`,\n`devShells`, `checks`, etc.) can quickly become verbose. This is where the\nflake-utils helper flake comes in handy. It provides utilities to reduce\nboilerplate when defining outputs for multiple systems.\n\nA commonly used function is `flake-utils.lib.eachDefaultSystem`, which\nautomatically generates outputs for common platforms (like `x86_64-linux`,\n`aarch64-linux`, `x86_64-darwin`, `aarch64-darwin`). This transforms your\noutputs definition from manually listing each system to a more concise structure:\n\n# Example using flake-utils\n\n```nix\n{\n  inputs = {\n    nixpkgs.url = \"github:NixOS/nixpkgs/nixos-unstable\";\n    flake-utils.url = \"github:numtide/flake-utils\"; # Don't forget to add flake-utils to inputs!\n  };\n\n  outputs = {\n    self,\n    nixpkgs,\n    flake-utils,\n    ...\n  }:\n    flake-utils.lib.eachDefaultSystem (\n      system: let\n        pkgs = import nixpkgs {inherit system;};\n      in {\n        packages.hello = pkgs.hello; # Now directly defines 'hello' for the current 'system' # packages.default = self.packages.${system}.hello; # Optional default alias\n        devShells.default = pkgs.mkShell {\n          packages = [pkgs.hello];\n        };\n      }\n    );\n}\n```\n\n- This flake-utils pattern is particularly useful for defining consistent\n  development environments across platforms, which can then be activated simply\n  by running `nix develop` in the flake's directory.\n\n### Adding Formatter, Checks, and Devshell Outputs\n\nThis is a minimal flake for demonstration with a hardcoded `system`, for more\nportability:\n\n```nix\n{\n  description = \"NixOS configuration\";\n\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n    home-manager.url = \"github:nix-community/home-manager\";\n    home-manager.inputs.nixpkgs.follows = \"nixpkgs\";\n    treefmt-nix.url = \"github:numtide/treefmt-nix\";\n   };\n\n  outputs = inputs@{ nixpkgs, home-manager, treefmt-nix, ... }: let\n\n    system = \"x86_64-linux\";\n    host = \"your-hostname-goes-here\";\n      # Define pkgs with allowUnfree\n    pkgs = import inputs.nixpkgs {\n      inherit system;\n      config.allowUnfree = true;\n    };\n\n        # Formatter configuration\n    treefmtEval = treefmt-nix.lib.evalModule pkgs ./lib/treefmt.nix;\n\nin {\n\n    formatter.${system} = treefmtEval.config.build.wrapper;\n\n    # Style check for CI\n    checks.${system}.style = treefmtEval.config.build.check self;\n\n    # Development shell\n    devShells.${system}.default = import ./lib/dev-shell.nix {\n      inherit inputs;\n    };\n\n\n    nixosConfigurations = {\n      hostname = nixpkgs.lib.nixosSystem {\n        system = \"x86_64-linux\";\n        modules = [\n          ./configuration.nix\n          home-manager.nixosModules.home-manager\n          {\n            home-manager.useGlobalPkgs = true;\n            home-manager.useUserPackages = true;\n            home-manager.users.jdoe = ./home.nix;\n\n            # Optionally, use home-manager.extraSpecialArgs to pass\n            # arguments to home.nix\n          }\n        ];\n      };\n    };\n  };\n}\n```\n\nAnd in `lib/treefmt.nix`:\n\n```nix\n# treefmt.nix\n{\n  projectRootFile = \"flake.nix\";\n  programs = {\n    alejandra.enable = true;\n    deadnix.enable = true;\n    # rustfmt.enable = true;\n    # shellcheck.enable = true;\n    # prettier.enable = true;\n    statix.enable = true;\n    keep-sorted.enable = true;\n    # nixfmt = {\n    #   enable = true;\n    #   # strict = true;\n    # };\n  };\n  settings = {\n    global.excludes = [\n      \"LICENSE\"\n      \"README.md\"\n      \".adr-dir\"\n      \"nu_scripts\"\n      # unsupported extensions\n      \"*.{gif,png,svg,tape,mts,lock,mod,sum,toml,env,envrc,gitignore,sql,conf,pem,*.so.2,key,pub,py,narHash}\"\n      \"data-mesher/test/networks/*\"\n      \"nss-datamesher/test/dns.json\"\n      \"*.age\"\n      \"*.jpg\"\n      \"*.nu\"\n      \"*.png\"\n      \".jj/*\"\n      \"Cargo.lock\"\n      \"flake.lock\"\n      \"hive/moonrise/borg-key-backup\"\n      \"justfile\"\n    ];\n    formatter = {\n      deadnix = {\n        priority = 1;\n      };\n      statix = {\n        priority = 2;\n      };\n      alejandra = {\n        priority = 3;\n      };\n    };\n  };\n}\n```\n\nNow we have a few commands available to us in our flake directory:\n\n- `nix fmt`: Will format your whole configuration consistently\n\n- `nix flake check`: While this command was already available, it is now tied\n  to treefmt's check which will check the style of your syntax and provide\n  suggestions.\n\nAnd this is `lib/dev-shell.nix`:\n\n```nix\n{\n  inputs,\n  system ? \"x86_64-linux\",\n}: let\n  # Instantiate nixpkgs with the given system and allow unfree packages\n  pkgs = import inputs.nixpkgs {\n    inherit system;\n    config.allowUnfree = true;\n    overlays = [\n      # Add overlays if needed, e.g., inputs.neovim-nightly-overlay.overlays.default\n    ];\n  };\nin\n  pkgs.mkShell {\n    name = \"nixos-dev\";\n    packages = with pkgs; [\n      # Nix tools\n      nixfmt-rfc-style # Formatter\n      deadnix # Dead code detection\n      nixd # Nix language server\n      nil # Alternative Nix language server\n      nh # Nix helper\n      nix-diff # Compare Nix derivations\n      nix-tree # Visualize Nix dependencies\n\n      # Code editing\n      helix # Your editor\n\n      # General utilities\n      git\n      ripgrep\n      jq\n      tree\n    ];\n\n    shellHook = ''\n      echo \"Welcome to the NixOS development shell!\"\n      echo \"System: ${system}\"\n      echo \"Tools available: nixfmt, deadnix, nixd, nil, nh, nix-diff, nix-tree, helix, git, ripgrep, jq, tree\"\n    '';\n  }\n```\n\nNow you can run `nix develop` in the flake directory and if successfull, you'll\nsee the `echo` commands above and you will have all the tools available in your\nenvironment without having to explicitly install them.\n","number":[6,2],"sub_items":[],"path":"flakes/flake_outputs_4.2.md","source_path":"flakes/flake_outputs_4.2.md","parent_names":["Nix Flakes Explained"]}},{"Chapter":{"name":"Nix Flake Examples","content":"# Nix Flake Examples\n\n<details>\n<summary> ✔️ Click to Expand Table of Contents</summary>\n\n<!-- toc -->\n\n</details>\n\nThis chapter provides practical examples to illustrate the concepts discussed in\n\"Nix Flakes Explained.\"\n\n## Example showing the extensibility of Flakes\n\nNixOS modules and configurations offer us a powerful and composable way\nto define and share system configurations. Imagine we have several independent\n\"players,\" each with their own unique set of configurations or modules. How do\nwe combine these individual contributions into a single, cohesive system\nwithout directly altering each player's original flake?\n\nThis example demonstrates how flakes can extend and compose each other, allowing\nyou to layer configurations on top of existing ones. This is particularly\nuseful when you want to:\n\n- Build upon a base configuration without modifying its source.\n\n- Combine features from multiple independent flakes into a single system.\n\n- Create specialized versions of an existing configuration.\n\nLet's simulate this by creating a players directory with three sub-directories:\n`first`, `second`, and `third`. Each of these will contain its own `flake.nix`.\n\n```bash\nmkdir players\ncd players\nmkdir first\nmkdir second\nmkdir third\ncd first\n```\n\nNow create a `flake.nix` with the following contents:\n\n```nix\n# flake.nix\n{\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-24.11\";\n  };\n\n  outputs = {\n    self,\n    nixpkgs,\n  }: {\n    nixosModules.default = {\n      config,\n      pkgs,\n      lib,\n      ...\n    }: {\n      # Create a file `/etc/first-file`\n      environment.etc.first-file.text = \"Hello player # 1!\";\n      boot.initrd.includeDefaultModules = false;\n      documentation.man.enable = false;\n      boot.loader.grub.enable = false;\n      fileSystems.\"/\".device = \"/dev/null\";\n      system.stateVersion = \"24.11\";\n    };\n    nixosConfigurations.testing = nixpkgs.lib.nixosSystem {\n      system = \"x86_64-linux\";\n      modules = [\n        self.nixosModules.default\n      ];\n    };\n  };\n}\n```\n\n- This demonstrates using `self` to reference this flake from within its own\n  outputs. This is the main use for `self` with flakes. Without `self`, I wouldn't\n  have a direct way to refer to the `nixosModules.default` that's defined within\n  the same flake.\n\nNow in the `players/second` directory create this `flake.nix`:\n\n```nix\n# flake.nix\n{\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-24.11\";\n  };\n\n  outputs = {\n    self,\n    nixpkgs,\n  }: {\n    nixosModules.default = {\n      config,\n      pkgs,\n      lib,\n      ...\n    }: {\n      # Create a file `/etc/second-file`\n      environment.etc.second-file.text = \"Hello player # 2!\";\n    };\n  };\n}\n```\n\n- `nixosModules.default` is a module which is a function that, when called by\n  the NixOS module system, returns an attribute set representing a piece of\n  system configuration.\n\n  - Within that attribute set, it specifies that the file `/etc/second-file`\n    should exist with \"Hello player # 2!\" as its content.\n\nAnd finally in `players/third` create another `flake.nix`:\n\n```nix\n# flake.nix\n{\n  inputs = {\n    first.url = \"/home/jr/players/first\";\n    nixpkgs.follows = \"first/nixpkgs\";\n    second = {\n      url = \"/home/jr/players/second\";\n      inputs.nixpkgs.follows = \"first/nixpkgs\";\n    };\n  };\n\n  outputs = {\n    self,\n    nixpkgs,\n    first,\n    second,\n  }:\n    first.outputs\n    // {\n      nixosConfigurations.testing = first.nixosConfigurations.testing.extendModules {\n        modules = [\n          second.nixosModules.default\n        ];\n      };\n    };\n}\n```\n\n- You'll have to change the locations to where you placed your `players`\n  directory in the `inputs` above.\n\nIn your `third` directory inspect it with:\n\n```bash\n  ~/players/third\n❯ nix flake show\npath:/home/jr/players/third?lastModified=1748271697&narHash=sha256-oNzkC6X9hA0MpOBmJSZ89w4znXxv4Q5EkFhp0ewehY0%3D\n├───nixosConfigurations\n│   └───testing: NixOS configuration\n└───nixosModules\n    └───default: NixOS module\n```\n\nand build it with:\n\n```bash\nnix build .#nixosConfigurations.testing.config.system.build.toplevel\n```\n\n```bash\ncat result/etc/first-file\nHello player # 1!\ncat result/etc/second-file\nHello player # 2!\n```\n\n**Understanding the Extension**\n\nAs you saw in the `flake.nix` for the third player, we leveraged two key flake\nfeatures to combine and extend the previous configurations:\n\n1. **Attribute Set Union** (`//` operator):\n\n```nix\noutputs = { ..., first, second, ... }:\nfirst.outputs // { # ... your extensions here ...\n};\n```\n\nThe `//` (attribute set union) operator allows us to take all the outputs from\n`first.outputs` (which includes its `nixosConfigurations` and `nixosModules`)\nand then overlay or add to them on the right-hand side. This means our third\nflake will inherit all the outputs from first, but we can then modify or add\nnew ones without changing the first flake itself.\n\n2. `config.extendModules`:\n\n```nix\n    nixosConfigurations.testing = first.nixosConfigurations.testing.extendModules {\n      modules = [\n        second.nixosModules.default\n      ];\n    };\n```\n\nThis is the core of the extension. We're taking the testing NixOS configuration\ndefined in the first flake (`first.nixosConfigurations.testing`) and then\ncalling its `extendModules` function. This function allows us to inject\nadditional NixOS modules into an already defined system configuration. In this\ncase, we're adding the default module from the second flake\n(`second.nixosModules.default`).\n\nBy combining these techniques, the third flake successfully creates a NixOS\nconfiguration that includes both the settings from first (like `/etc/first-file`\nand the base system options) and the settings from second (like `/etc/second-file`),\nall without directly altering the first or second flakes. This demonstrates the\nincredible power of flake extensibility for building complex, modular, and\ncomposable systems.\n","number":[6,3],"sub_items":[],"path":"flakes/flake_examples_4.3.md","source_path":"flakes/flake_examples_4.3.md","parent_names":["Nix Flakes Explained"]}},{"Chapter":{"name":"Hack the Helix Flake","content":"# Chapter 4.4\n\n<details>\n<summary> ✔️ Click to Expand Table of Contents</summary>\n\n<!-- toc -->\n\n</details>\n\n![Helix Logo](../images/helix.png)--[helix-editor.com](https://helix-editor.com/)\n\n# Understanding the Helix Flake and Modifying its Behavior\n\nAs we've seen from previous examples, the helix editor repository includes a few\n`.nix` files including a `flake.nix`. Their flake uses a lot of idiomatic Nix\ncode and advanced features. First I will break down their `flake.nix` and\n`default.nix` to understand why they do certain things. And finally, we will\nchange the build to \"debug\" mode demonstrating how easily you can modify the\nbehavior of a package defined within a Nix flake without changing the original\nsource code or the upstream flake directly.\n\n1. Let's clone the Helix repository:\n\n```bash\ngit clone https://github.com/helix-editor/helix.git\ncd helix\n```\n\nWhen you enter the `helix` directory, `direnv` is setup for you already. All you\nwould have to do is `direnv allow` and it will ask you a few questions then you\nare good to go. Looking at their `.envrc` it mentions \"try to use flakes, if it\nfails use normal nix (i.e., shell.nix)\". If it's successful you'll see a long\nlist of environment variables displayed.\n\n2. Enter the Development Shell:\n\nThe Helix project's `flake.nix` includes a `devShells.default` output,\nspecifically designed for development.\n\n```bash\nnix develop\n```\n\n3. You're now in a fully configured development environment:\n\n- When you run `nix develop`, Nix builds and drops you into a shell environment\n  with all the dependencies specified in `devShells.default`. This means you\n  don’t have to manually install or manage tools like Rust, Cargo, or Clang,\n  it’s all handled declaratively through Nix.\n\nYou can now build and run the project using its standard tooling:\n\n```bash\ncargo check\ncargo build\ncargo run\n```\n\n4. Making Changes and Testing Them\n\nSince you're in a reproducible environment, you can confidently hack on the\nproject without worrying about your system setup. Try modifying some code in\n`helix` and rebuilding with Cargo. The Nix shell ensures consistency for every\ncontributor or device you work on.\n\n5. Run Just the Binary\n\nIf you only want to run the compiled program without entering the shell, use the\nnix run command:\n\n```bash\nnix run\n```\n\nThis builds and runs the default package defined by the flake. In the case of\nHelix, this launches the `hx` editor directly.\n\n6. Build Without Running\n\nTo just build the project and get the path to the output binary:\n\n```bash\nnix build\n```\n\nYou’ll find the compiled binary under `./result/bin`.\n\n7. Pinning and Reproducing\n\nBecause the project uses a flake, you can ensure full reproducibility by pinning\nthe inputs. For example, you can clone with `--recurse-submodules` and copy the\n`flake.lock` to ensure you're using the same dependency versions as upstream.\nThis is great for debugging or sharing exact builds.\n\n✅ Recap:\n\nWith flakes, projects like Helix provide everything you need for development and\nrunning in a single `flake.nix`. You can nix develop to get started hacking, nix\nrun to quickly try it out, and nix build to produce binaries all without\ninstalling or polluting your system.\n\n## Understanding the Helix flake.nix\n\nThe helix flake is full of idiomatic Nix code and displays some of the more\nadvanced things a flake can provide:\n\n```nix\n{\n  description = \"A post-modern text editor.\";\n\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n    rust-overlay = {\n      url = \"github:oxalica/rust-overlay\";\n      inputs.nixpkgs.follows = \"nixpkgs\";\n    };\n  };\n\n  outputs = {\n    self,\n    nixpkgs,\n    rust-overlay,\n    ...\n  }: let\n    inherit (nixpkgs) lib;\n    systems = [\n      \"x86_64-linux\"\n      \"aarch64-linux\"\n      \"x86_64-darwin\"\n      \"aarch64-darwin\"\n    ];\n    eachSystem = lib.genAttrs systems;\n    pkgsFor = eachSystem (system:\n      import nixpkgs {\n        localSystem.system = system;\n        overlays = [(import rust-overlay) self.overlays.helix];\n      });\n    gitRev = self.rev or self.dirtyRev or null;\n  in {\n    packages = eachSystem (system: {\n      inherit (pkgsFor.${system}) helix;\n      /*\n      The default Helix build. Uses the latest stable Rust toolchain, and unstable\n      nixpkgs.\n\n      The build inputs can be overridden with the following:\n\n      packages.${system}.default.override { rustPlatform = newPlatform; };\n\n      Overriding a derivation attribute can be done as well:\n\n      packages.${system}.default.overrideAttrs { buildType = \"debug\"; };\n      */\n      default = self.packages.${system}.helix;\n    });\n    checks =\n      lib.mapAttrs (system: pkgs: let\n        # Get Helix's MSRV toolchain to build with by default.\n        msrvToolchain = pkgs.pkgsBuildHost.rust-bin.fromRustupToolchainFile ./rust-toolchain.toml;\n        msrvPlatform = pkgs.makeRustPlatform {\n          cargo = msrvToolchain;\n          rustc = msrvToolchain;\n        };\n      in {\n        helix = self.packages.${system}.helix.override {\n          rustPlatform = msrvPlatform;\n        };\n      })\n      pkgsFor;\n\n    # Devshell behavior is preserved.\n    devShells =\n      lib.mapAttrs (system: pkgs: {\n        default = let\n          commonRustFlagsEnv = \"-C link-arg=-fuse-ld=lld -C target-cpu=native --cfg tokio_unstable\";\n          platformRustFlagsEnv = lib.optionalString pkgs.stdenv.isLinux \"-Clink-arg=-Wl,--no-rosegment\";\n        in\n          pkgs.mkShell {\n            inputsFrom = [self.checks.${system}.helix];\n            nativeBuildInputs = with pkgs;\n              [\n                lld\n                cargo-flamegraph\n                rust-bin.nightly.latest.rust-analyzer\n              ]\n              ++ (lib.optional (stdenv.isx86_64 && stdenv.isLinux) cargo-tarpaulin)\n              ++ (lib.optional stdenv.isLinux lldb)\n              ++ (lib.optional stdenv.isDarwin darwin.apple_sdk.frameworks.CoreFoundation);\n            shellHook = ''\n              export RUST_BACKTRACE=\"1\"\n              export RUSTFLAGS=\"''${RUSTFLAGS:-\"\"} ${commonRustFlagsEnv} ${platformRustFlagsEnv}\"\n            '';\n          };\n      })\n      pkgsFor;\n\n    overlays = {\n      helix = final: prev: {\n        helix = final.callPackage ./default.nix {inherit gitRev;};\n      };\n\n      default = self.overlays.helix;\n    };\n  };\n  nixConfig = {\n    extra-substituters = [\"https://helix.cachix.org\"];\n    extra-trusted-public-keys = [\"helix.cachix.org-1:ejp9KQpR1FBI2onstMQ34yogDm4OgU2ru6lIwPvuCVs=\"];\n  };\n}\n```\n\n**Top-Level Metadata**:\n\n```nix\n{\n  description = \"A post-modern text editor.\";\n}\n```\n\n- This sets a human-readable description for the flake.\n\n## Inputs\n\n```nix\ninputs = {\n  nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n  rust-overlay = {\n    url = \"github:oxalica/rust-overlay\";\n    inputs.nixpkgs.follows = \"nixpkgs\";\n  };\n};\n```\n\n- `nixpkgs`: Uses the `nixos-unstable` branch of the Nixpkgs repository.\n\n- `rust-overlay`: follows the same `nixpkgs`, ensuring compatibility between\n  inputs.\n\n**Outputs Function**:\n\n```nix\noutputs = { self, nixpkgs, rust-overlay, ... }:\n```\n\n- This defines what this flake exports, including `packages`, `devShells`, etc.\n\n**Common Setup**:\n\n```nix\nlet\n  inherit (nixpkgs) lib;\n  systems = [ ... ];\n  eachSystem = lib.genAttrs systems;\n```\n\n- `systems`: A list of the supported systems\n\n- `eachSystem`: A Helper to map over all platforms.\n\n```nix\npkgsFor = eachSystem (system:\n  import nixpkgs {\n    localSystem.system = system;\n    overlays = [(import rust-overlay) self.overlays.helix];\n  });\n```\n\n- This imports `nixpkgs` for each system and applies overlays\n\n📦 `packages`\n\n```nix\npackages = eachSystem (system: {\n  inherit (pkgsFor.${system}) helix;\n  default = self.packages.${system}.helix;\n});\n```\n\n- For each platform:\n  - Includes a `helix` package (defined in `./default.nix`)\n\n  - Sets `default` to `helix` (used by `nix build`, `nix run`)\n\nLet's look at the helix `default.nix`:\n\n```nix\n{\n  lib,\n  rustPlatform,\n  callPackage,\n  runCommand,\n  installShellFiles,\n  git,\n  gitRev ? null,\n  grammarOverlays ? [],\n  includeGrammarIf ? _: true,\n}: let\n  fs = lib.fileset;\n\n  src = fs.difference (fs.gitTracked ./.) (fs.unions [\n    ./.envrc\n    ./rustfmt.toml\n    ./screenshot.png\n    ./book\n    ./docs\n    ./runtime\n    ./flake.lock\n    (fs.fileFilter (file: lib.strings.hasInfix \".git\" file.name) ./.)\n    (fs.fileFilter (file: file.hasExt \"svg\") ./.)\n    (fs.fileFilter (file: file.hasExt \"md\") ./.)\n    (fs.fileFilter (file: file.hasExt \"nix\") ./.)\n  ]);\n\n  # Next we actually need to build the grammars and the runtime directory\n  # that they reside in. It is built by calling the derivation in the\n  # grammars.nix file, then taking the runtime directory in the git repo\n  # and hooking symlinks up to it.\n  grammars = callPackage ./grammars.nix {inherit grammarOverlays includeGrammarIf;};\n  runtimeDir = runCommand \"helix-runtime\" {} ''\n    mkdir -p $out\n    ln -s ${./runtime}/* $out\n    rm -r $out/grammars\n    ln -s ${grammars} $out/grammars\n  '';\nin\n  rustPlatform.buildRustPackage (self: {\n    cargoLock = {\n      lockFile = ./Cargo.lock;\n      # This is not allowed in nixpkgs but is very convenient here: it allows us to\n      # avoid specifying `outputHashes` here for any git dependencies we might take\n      # on temporarily.\n      allowBuiltinFetchGit = true;\n    };\n\n    nativeBuildInputs = [\n      installShellFiles\n      git\n    ];\n\n    buildType = \"release\";\n\n    name = with builtins; (fromTOML (readFile ./helix-term/Cargo.toml)).package.name;\n    src = fs.toSource {\n      root = ./.;\n      fileset = src;\n    };\n\n    # Helix attempts to reach out to the network and get the grammars. Nix doesn't allow this.\n    HELIX_DISABLE_AUTO_GRAMMAR_BUILD = \"1\";\n\n    # So Helix knows what rev it is.\n    HELIX_NIX_BUILD_REV = gitRev;\n\n    doCheck = false;\n    strictDeps = true;\n\n    # Sets the Helix runtime dir to the grammars\n    env.HELIX_DEFAULT_RUNTIME = \"${runtimeDir}\";\n\n    # Get all the application stuff in the output directory.\n    postInstall = ''\n      mkdir -p $out/lib\n      installShellCompletion ${./contrib/completion}/hx.{bash,fish,zsh}\n      mkdir -p $out/share/{applications,icons/hicolor/{256x256,scalable}/apps}\n      cp ${./contrib/Helix.desktop} $out/share/applications/Helix.desktop\n      cp ${./logo.svg} $out/share/icons/hicolor/scalable/apps/helix.svg\n      cp ${./contrib/helix.png} $out/share/icons/hicolor/256x256/apps/helix.png\n    '';\n\n    meta.mainProgram = \"hx\";\n  })\n```\n\n### Breaking Down `helix/default.nix`\n\n<details>\n<summary> ✔️ Click to Expand `helix/default.nix` breakdown </summary>\n\nThis `default.nix` file is a Nix derivation that defines how to build the Helix\neditor itself. It's designed to be called by the main `flake.nix` as part of its\n`packages` output.\n\nHere's a breakdown of its components:\n\n1. **Function Arguments**:\n\n```nix\n{\n  lib,\n  rustPlatform,\n  callPackage,\n  runCommand,\n  installShellFiles,\n  git,\n  gitRev ? null,\n  grammarOverlays ? [],\n  includeGrammarIf ? _: true,\n}:\n```\n\n`lib`: The Nixpkgs `lib` (library) functions, essential for common operations\nlike `fileset` and `strings`.\n\n`rustPlatform`: A helper function from Nixpkgs specifically for building Rust\nprojects. It provides a `buildRustPackage` function, which simplifies the\nprocess significantly.\n\n`callPackage`: A Nixpkgs function used to instantiate a Nix expression (like\n`grammars.nix`) with its dependencies automatically supplied from the current\nNix environment.\n\n`runCommand`: A Nixpkgs primitive that creates a derivation by running a shell\ncommand. It's used here to construct the `runtimeDir`.\n\n`installShellFiles`: A utility from Nixpkgs for installing shell completion\nfiles.\n\n`git`: The Git package, needed for determining the `gitRev`.\n\n`gitRev ? null`: The Git revision of the Helix repository. It's an optional\nargument, defaulting to null. This is passed in from the main `flake.nix`.\n\n`grammarOverlays ? []`: An optional list of overlays for grammars, allowing\ncustomization.\n\n`includeGrammarIf ? _: true`: An optional function to control which grammars are\nincluded.\n\n2. **Local Variables** (`let ... in`)\n\n```nix\nlet\n  fs = lib.fileset;\n\n  src = fs.difference (fs.gitTracked ./.) (fs.unions [\n    ./.envrc\n    ./rustfmt.toml\n    ./screenshot.png\n    ./book\n    ./docs\n    ./runtime\n    ./flake.lock\n    (fs.fileFilter (file: lib.strings.hasInfix \".git\" file.name) ./.)\n    (fs.fileFilter (file: file.hasExt \"svg\") ./.)\n    (fs.fileFilter (file: file.hasExt \"md\") ./.)\n    (fs.fileFilter (file: file.hasExt \"nix\") ./.)\n  ]);\n\n  grammars = callPackage ./grammars.nix { inherit grammarOverlays includeGrammarIf; };\n  runtimeDir = runCommand \"helix-runtime\" {} ''\n    mkdir -p $out\n    ln -s ${./runtime}/* $out\n    rm -r $out/grammars\n    ln -s ${grammars} $out/grammars\n  '';\nin\n```\n\n`fs = lib.fileset;`: Aliases `lib.fileset` for convenient file set operations.\n\n`src`: This is a crucial part. It defines the source files that will be used to\nbuild Helix by:\n\n- Taking all Git-tracked files in the current directory (`fs.gitTracked ./.`).\n\n- Excluding configuration files (e.g., `.envrc`, `flake.lock`), documentation\n  (`.md`), images (`.svg`), and Nix files (`.nix`) using `fs.difference` and\n  `fs.unions`. This ensures a clean build input, reducing Nix store size and\n  avoiding unnecessary rebuilds.\n\n- `grammars`: Builds syntax grammars by calling `grammars.nix`, passing\n  `grammarOverlays` (for customizing grammar builds) and `includeGrammarIf` (a\n  filter for selecting grammars).\n\n- `runtimeDir`: Creates a runtime directory for Helix by:\n  - Symlinking the `runtime` directory from the source.\n\n  - Replacing the `grammars` subdirectory with a symlink to the `grammars`\n    derivation, ensuring Helix uses Nix-managed grammars.\n\n3. **The Build Derivation** (`rustPlatform.buildRustPackage`)\n\nThe core of this `default.nix` is the `rustPlatform.buildRustPackage` call,\nwhich is a specialized builder for Rust projects:\n\n```nix\nin\n  rustPlatform.buildRustPackage (self: {\n    cargoLock = {\n      lockFile = ./Cargo.lock;\n      # ... comments ...\n      allowBuiltinFetchGit = true;\n    };\n```\n\n`cargoLock`: Specifies how Cargo dependencies are handled.\n\n`lockFile = ./Cargo.lock;` Points to the `Cargo.lock` file for reproducible\nbuilds.\n\n`allowBuiltinFetchGit = true`: Allows Cargo to fetch Git dependencies directly\nfrom repositories specified in `Cargo.lock`. This is discouraged in Nixpkgs\nbecause it can break build reproducibility, but it’s used here for convenience\nduring development, eliminating the need to manually specify `outputHashes` for\nGit dependencies.\n\n```nix\nnativeBuildInputs = [\n      installShellFiles\n      git\n    ];\n```\n\n`nativeBuildInputs`: Are tools needed during the build process but not\nnecessarily at runtime.\n\n```nix\nbuildType = \"release\";\n```\n\n`buildType`: Specifies that Helix should be built in \"release\" mode (optimized).\n\n```nix\nname = with builtins; (fromTOML (readFile ./helix-term/Cargo.toml)).package.name;\n    src = fs.toSource {\n      root = ./.;\n      fileset = src;\n    };\n```\n\n`name`: Dynamically sets the package name by reading it from the `Cargo.toml`\nfile.\n\n`src`: Uses the `src` file set defined earlier as the source for the build.\n\n```nix\n# Helix attempts to reach out to the network and get the grammars. Nix doesn't allow this.\n    HELIX_DISABLE_AUTO_GRAMMAR_BUILD = \"1\";\n\n    # So Helix knows what rev it is.\n    HELIX_NIX_BUILD_REV = gitRev;\n```\n\n**Environment Variables**: Sets environment variables that Helix uses.\n\n`HELIX_DISABLE_AUTO_GRAMMAR_BUILD = \"1\"`: Prevents Helix from downloading\ngrammars during the build, as Nix’s sandboxed environment disallows network\naccess. Instead, grammars are provided via the `runtimeDir` derivation.\n\n`HELIX_NIX_BUILD_REV = gitRev`: Embeds the specified Git revision (or `null` if\nunspecified) into the Helix binary, allowing Helix to display its version or\ncommit hash.\n\n```nix\ndoCheck = false;\n   strictDeps = true;\n```\n\n`doCheck = false;`: Skips running tests during the build. This is common for\nfaster builds, especially in CI/CD, but tests are often run in a separate\n`checks` output (as seen in the `flake.nix`).\n\n`strictDeps = true;`: Ensures that all dependencies are explicitly declared.\n\n```nix\n# Sets the Helix runtime dir to the grammars\nenv.HELIX_DEFAULT_RUNTIME = \"${runtimeDir}\";\n```\n\n```nix\n# Sets the Helix runtime dir to the grammars\nenv.HELIX_DEFAULT_RUNTIME = \"${runtimeDir}\";\n```\n\n`env.HELIX_DEFAULT_RUNTIME`: Tells Helix where to find its runtime files\n(including the Nix-managed grammars).\n\n```nix\n# Get all the application stuff in the output directory.\npostInstall = ''\n  mkdir -p $out/lib\n  installShellCompletion ${./contrib/completion}/hx.{bash,fish,zsh}\n  mkdir -p $out/share/{applications,icons/hicolor/{256x256,scalable}/apps}\n  cp ${./contrib/Helix.desktop} $out/share/applications/Helix.desktop\n  cp ${./logo.svg} $out/share/icons/hicolor/scalable/apps/helix.svg\n  cp ${./contrib/helix.png} $out/share/icons/hicolor/256x256/apps/helix.png\n'';\n```\n\n`postInstall`: A shell script that runs after the main build is complete. This\nis used for installing additional files that are part of the Helix distribution\nbut not directly built by Cargo.\n\nInstalls shell completion files (`hx.bash`, `hx.fish`, `hx.zsh`). This enables\ntab completion.\n\nInstalls desktop entry files (`Helix.desktop`) and icons (`logo.svg`,\n`helix.png`) for desktop integration for GUI environments.\n\n```nix\n    meta.mainProgram = \"hx\";\n\n})\n```\n\n`meta.mainProgram`: Specifies the primary executable provided by this package,\nallowing `nix run` to automatically execute `hx`.\n\nA lot going on in this derivation!\n\n</details>\n\n### Making Actual Changes\n\n1. Locate the `packages` output section. It looks like this:\n\n```nix\npackages = eachSystem (system: {\n      inherit (pkgsFor.${system}) helix;\n      /*\n      The default Helix build. Uses the latest stable Rust toolchain, and unstable\n      nixpkgs.\n\n      The build inputs can be overridden with the following:\n\n      packages.${system}.default.override { rustPlatform = newPlatform; };\n\n      Overriding a derivation attribute can be done as well:\n\n      packages.${system}.default.overrideAttrs { buildType = \"debug\"; };\n      */\n      default = self.packages.${system}.helix;\n    });\n```\n\n2. Modify the `default` package. The comments actually tell us exactly how to do\n   this. We want to use `overrideAttrs` to change the `buildType`\n\nChange this line:\n\n```nix\ndefault = self.packages.${system}.helix;\n```\n\nTo this:\n\n```nix\ndefault = self.packages.${system}.helix.overrideAttrs { buildType = \"debug\"; };\n```\n\n- This tells Nix to take the standard Helix package definition and override one\n  of its internal attributes (`buildType`) to \"debug\" instead of \"release\".\n\n3. Build the \"Hacked\" Helix:\n\n```bash\nnix build\n```\n\n- Nix will now rebuild Helix, but this time, it will compile it in debug mode.\n  You'll likely notice the build takes a bit longer, and the resulting binary\n  will be larger due to the included debugging symbols.\n\n4. Run the Debug Binary:\n\n```bash\n./result/bin/hx\n```\n\n- You're now running your custom-built debug version of Helix! This is useful if\n  you were, for example, attatching a debugger.\n\nThis is a simple yet powerful \"hack\" that demonstrates how easily you can modify\nthe behavior of a package defined within a Nix flake without changing the\noriginal source code or the upstream flake directly. You're simply telling Nix\nhow you'd like your version of the package to be built.\n\n### Another way to Modify Behavior\n\nSince we are already familiar with the structure and behavior of Helix’s\n`flake.nix`, we can leverage that understanding to create our own Nix flake. By\nanalyzing how Helix organizes its `inputs`, `outputs`, and package definitions,\nwe gain the confidence to modify and extend a flake’s functionality to suit our\nspecific needs—whether that’s customizing builds, adding overlays, or\nintegrating with home-manager.\n\n1. Create a `flake.nix` in your own directory (outside the helix repo):\n\n```nix\n{\n  description = \"Customized Helix build with debug features\";\n\n  inputs = {\n    helix.url = \"github:helix-editor/helix\";\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n    rust-overlay = {\n      url = \"github:oxalica/rust-overlay\";\n      inputs.nixpkgs.follows = \"nixpkgs\";\n    };\n  };\n  outputs = {\n    self,\n    helix,\n    nixpkgs,\n    rust-overlay,\n  }: let\n    system = \"x86_64-linux\";\n    pkgs = import nixpkgs {\n      system = system;\n      overlays = [rust-overlay.overlay.overlays.default];\n    };\n  in {\n    packages.${system}.default = helix.packages.${system}.helix.overrideAttrs (old: {\n      buildType = \"debug\";\n\n      # Add additional cargo features\n      cargoBuildFlags =\n        (old.cargoBuildFlags or [])\n        ++ [\n          \"--features\"\n          \"tokio-console\"\n        ];\n\n      # Inject custom RUSTFLAGS\n      RUSTFLAGS = (old.RUSTFLAGS or \"\") + \" -C debuginfo=2 -C opt-level=1\";\n    });\n  };\n}\n```\n\nCheck it:\n\n```bash\nnix flake check\nwarning: creating lock file '\"/home/jr/world/flake.lock\"':\n• Added input 'helix':\n    'github:helix-editor/helix/8961ae1dc66633ea6c9f761896cb0d885ae078ed?narHash=sha256-f14perPUk%2BH15GyGRbg0Akqhn3rxFnc6Ez5onqpzu6A%3D' (2025-05-29)\n• Added input 'helix/nixpkgs':\n    'github:nixos/nixpkgs/5135c59491985879812717f4c9fea69604e7f26f?narHash=sha256-Vr3Qi346M%2B8CjedtbyUevIGDZW8LcA1fTG0ugPY/Hic%3D' (2025-02-26)\n• Added input 'helix/rust-overlay':\n    'github:oxalica/rust-overlay/d342e8b5fd88421ff982f383c853f0fc78a847ab?narHash=sha256-3SdPQrZoa4odlScFDUHd4CUPQ/R1gtH4Mq9u8CBiK8M%3D' (2025-02-27)\n• Added input 'helix/rust-overlay/nixpkgs':\n    follows 'helix/nixpkgs'\n• Added input 'nixpkgs':\n    'github:nixos/nixpkgs/96ec055edbe5ee227f28cdbc3f1ddf1df5965102?narHash=sha256-7doLyJBzCllvqX4gszYtmZUToxKvMUrg45EUWaUYmBg%3D' (2025-05-28)\n• Added input 'rust-overlay':\n    'github:oxalica/rust-overlay/405ef13a5b80a0a4d4fc87c83554423d80e5f929?narHash=sha256-k0nhPtkVDQkVJckRw6fGIeeDBktJf1BH0i8T48o7zkk%3D' (2025-05-30)\n• Added input 'rust-overlay/nixpkgs':\n    follows 'nixpkgs'\n```\n\n- The `nix flake check` command will generate a `flake.lock` file if one doesn't\n  exist, and the warnings you see indicate that new inputs are being added and\n  locked to specific versions for reproducibility. This is expected behavior for\n  a new or modified flake.\n\nInspect the outputs:\n\n```bash\nnix flake show\npath:/home/jr/world?lastModified=1748612128&narHash=sha256-WEYtptarRrrm0Jb/0PJ/b5VPqLkCk5iEenjbKYU4Xm8%3D\n└───packages\n    └───x86_64-linux\n        └───default: package 'helix-term'\n```\n\n- The `└───packages` line indicates that our flake exposes a top-level\n  `packages` attribute.\n\n- `└───x86_64-linux`: System architecture specificity\n\n- `└───default: package 'helix-term'` Signifies that within the `x86_64-linux`\n  packages, there's a package named `default`. This is a special name that\n  allows you to omit the package name when using commands like `nix build`.\n\n- `package 'helix-term'` This is the most direct confirmation of our \"hack\". It\n  tells us that our `default` package is `helix-term`. This confirms that our\n  `overrideAttrs` in the `packages.${system}.default` section successfully\n  targeted and modified the Helix editor package, which is internally named\n  `helix-term` by the Helix flake.\n\n**What This Does**:\n\n- `overrideAttrs` lets you change _only_ parts of the derivation without\n  rewriting everything.\n\n- `buildType = \"debug\"` enables debug builds.\n\n- `cargoBuildFlags` adds extra features passed to Cargo, e.g.,\n  `--features tokio-console`\n\n- `RUSTFLAGS` gives you even more control over compiler behavior, optimization\n  levels, etc.\n\n**Run It**:\n\n```bash\nnix run\n```\n\nOr drop into the dev shell:\n\n```bash\nnix develop\n```\n\n- (assuming you also wire in a `devShells` output)\n\n**Adding the `devShells` output**:\n\nSince we already have the helix flake as an input to our own `flake.nix` we can\nnow forward or extend Helix's `devShells` like this:\n\n```nix\noutputs = { self, nixpkgs, helix, rust-overlay, ... }: {\n  devShells = helix.devShells;\n};\n```\n\nOr if you want to pick a specific system:\n\n```nix\noutputs = { self, nixpkgs, helix, rust-overlay ... }:\n  let\n    system = \"x86_64-linux\";\n  in {\n    devShells.${system} = helix.devShells.${system};\n  };\n```\n\n**Optional: Combine with your own** `devShell`\n\nYou can also extend or merge it with your own shell like so:\n\n```nix\noutputs = { self, nixpkgs, helix, rust-overlay, ... }:\n  let\n    system = \"x86_64-linux\";\n    pkgs = import nixpkgs { inherit system; };\n  in {\n    devShells.${system} = {\n      default = pkgs.mkShell {\n        name = \"my-shell\";\n        inputsFrom = [ helix.devShells.${system}.default ];\n        buildInputs = [ pkgs.git ];\n      };\n    };\n  };\n```\n","number":[6,4],"sub_items":[],"path":"flakes/helix_flake_4.4.md","source_path":"flakes/helix_flake_4.4.md","parent_names":["Nix Flakes Explained"]}},{"Chapter":{"name":"Extending Flakes with Custom Packages using Overlays","content":"# Extending Flakes with Custom Packages using Overlays\n\n<details>\n<summary> ✔️ Click to Expand Table of Contents</summary>\n\n<!-- toc -->\n\n</details>\n\n![Pokego Logo](../images/pokego.png)--[pokego repo](https://github.com/rubiin/pokego)\n\nOverlays are Nix functions that accept two arguments, `final` and `prev` and\nreturn a set of packages. Overlays are similar to `packageOverrides` as a way to\ncustomize Nixpkgs, `packageOverrides` acts as an overlay with only the `prev`\nargument. Therefore, `packageOverrides` is appropriate for basic use, but\noverlays are more powerful and easier to distribute.\n\nExample:\n\n```nix\nfinal: prev: {\n  firefox = prev.firefox.overrideAttrs (old: {\n    buildInputs = (old.buildInputs or []) ++ [ prev.vlc ];\n    env.FIREFOX_DISABLE_GMP_UPDATER = \"1\";\n  });\n}\n```\n\nTo see the original derivation, run `nix edit -f \"<nixpkgs>\" firefox`.\n\nThis modifies Firefox by:\n\n- Adding `vlc` to `buildInputs`, useful if a package requires additional\n  dependencies.\n\n- Setting an environment variable (`FIREFOX_DISABLE_GMP_UPDATER=1`) to disable\n  automatic updates of the Gecko Media Plugin.\n\nIt is very common to use overlays in Nix to install packages that aren't\navailable in the standard Nixpkgs repository.\n\n**Overlays** are one of the primary and recommended ways to extend and customize\nyour Nix environment. It's important to remember that Nix overlays are made to\nallow you to modify or extend the package set provided by Nixpkgs (or other Nix\nsources) without directly altering the original package definitions. This is\ncrucial for maintaining reproducibility and avoiding conflicts. Overlays are\nessentially functions that take the previous package set and allow you to add,\nmodify, or remove packages.\n\n- To better understand the structure of my `flake.nix` it may be helpful to\n  first read [This](https://tsawyer87.github.io/posts/nix_flakes_tips/) blog\n  post first.\n\n## Adding the overlays output to your Flake\n\nI'll show the process of adding the `pokego` package that is not in Nixpkgs:\n\n1. In my `flake.nix` I have a custom inputs variable within my let block of my\n   flake like so just showing the necessary parts for brevity:\n\n```nix\n# flake.nix\n  outputs = my-inputs @ {\n    self,\n    nixpkgs,\n    treefmt-nix,\n    ...\n  }: let\n    system = \"x86_64-linux\";\n    host = \"magic\";\n    userVars = {\n      username = \"jr\";\n      gitUsername = \"saylesss88\";\n      editor = \"hx\";\n      term = \"ghostty\";\n      keys = \"us\";\n      browser = \"firefox\";\n      flake = builtins.getEnv \"HOME\" + \"/flake\";\n    };\n\n    inputs =\n      my-inputs\n      // {\n        pkgs = import inputs.nixpkgs {\n          inherit system;\n        };\n        lib = {\n          overlays = import ./lib/overlay.nix;\n          nixOsModules = import ./nixos;\n          homeModules = import ./home;\n          inherit system;\n        };\n      };\n      # ... snip ...\n```\n\n- Why I Created `inputs.lib` in My `flake.nix`. In the above example, you'll\n  notice a `lib` attribute defined within the main `let` block.\n  - This might seem a bit unusual at first, as inputs are typically defined at\n    the top level of a flake. However, this structure provides a powerful way to\n    organize and reuse common Nix functions and configurations across my flake.\n\n  - By bundling my custom logic and modules into `inputs.lib`, I can pass\n    `inputs` (which now includes my custom `lib`) as a `specialArgs` to other\n    modules. This provides a clean way for all modules to access these shared\n    resources. For example, in `configuration.nix`, `inputs.lib.overlays`\n    directly references my custom overlay set.\n\n  - My `inputs.lib` is my own project-specific library, designed to hold\n    functions and attribute sets relevant to my flake's custom configurations.\n    While `nixpkgs.lib` is globally available, my custom `lib` contains my\n    unique additions.\n\nWhile defining `inputs` within the `let` block to achieve this structure is a\npersonal preference and works well for my setup, the core benefit is the\ncreation of a dedicated, centralized `lib` attribute that encapsulates my\nflake's reusable Nix code, leading to a more organized and maintainable\nconfiguration.\n\n## The Actual Overlay\n\n2. In the `overlay.nix` I have this helper function and the defined package:\n\n```nix\n# overlay.nix\n_final: prev: let\n  # Helper function to import a package\n  callPackage = prev.lib.callPackageWith (prev // packages);\n\n  # Define all packages\n  packages = {\n    # Additional packages\n    pokego = callPackage ./pac_defs/pokego.nix {};\n  };\nin\n  packages\n```\n\n1. `_final: prev:`: This is the function definition of the overlay.\n\n- `_final`: This argument represents the final, merged package set after all\n  overlays have been applied. It's often unused within a single overlay, hence\n  the `_` prefix (a Nix convention for unused variables).\n\n- `prev`: This is the crucial argument. It represents the package set before\n  this overlay is applied. This allows you to refer to existing packages and\n  functions from Nixpkgs.\n\n2. `let ... in packages`: This introduces a `let` expression, which defines\n   local variables within the scope of this overlay function. The `in packages`\n   part means that the overlay function will ultimately return the `packages`\n   attribute set defined within the `let` block.\n\n3. `callPackage = prev.lib.callPackageWith (prev // packages)`: This line\n   defines a helper function called `callPackage`.\n\n- `prev.lib.callPackageWith` Is a function provided by Nixpkgs' `lib`.\n  `callPackageWith` is like `prev.lib.callPackage`, but allows the passing of\n  additional arguments that will then be passed to the package definition.\n\n- `(prev // packages)`: This is an attribute set merge operation. It takes the\n  `prev` package set (Nixpkgs before this overlay) and merges it with the\n  `packages` attribute set defined later in this overlay.\n\n- By using `callPackageWith` with this merged attribute set, the `callPackage`\n  function defined here is set up to correctly import package definitions,\n  ensuring they have access to both the original Nixpkgs and any other packages\n  defined within this overlay.\n\n4. `packages = { ... };`: This defines an attribute set named `packages`. This\n   set will contain all the new or modified packages introduced by this overlay.\n\n5. `pokego = callPackages ./pac_defs/pokego.nix { };`: This is the core of how\n   the `pokego` package is added.\n\n- `pokego =`: This defines a new attribute named `pokego` within the packages\n  attribute set. This name will be used to refer to the pokego package later.\n\n- `callPackage ./pac_defs/pokego.nix {}`: This calls the callPackage helper\n  function defined earlier.\n\n- `./pac_defs/pokego.nix`: This is the path to another Nix file(`pokego.nix`)\n  that contains the actual package definition for pokego. This file would define\n  how to fetch, build, and install the pokego software\n\n- `{}`: This is an empty attribute set passed as additional arguments to the\n  `pokego.nix` package definition. If `pokego.nix` expected any specific\n  parameters (like versions or dependencies), you would provide them here. Since\n  it's empty, it implies pokego.nix either has no required arguments or uses\n  default values.\n\n6. `in packages`: As mentioned earlier, the overlay function returns the\n   packages attribute set. When this overlay is applied, the packages defined\n   within this packages set (including pokego) will be added to the overall Nix\n   package set.\n\n## The pokego Package definition\n\nThe following is the `./pac_defs/pokego.nix`:\n\n```nix\n# pokego.nix\n{\n  lib,\n  buildGoModule,\n  fetchFromGitHub,\n}:\nbuildGoModule rec {\n  pname = \"pokego\";\n  version = \"0.3.0\";\n\n  src = fetchFromGitHub {\n    owner = \"rubiin\";\n    repo = \"pokego\";\n    rev = \"v${version}\";\n    hash = \"sha256-cFpEi8wBdCzAl9dputoCwy8LeGyK3UF2vyylft7/1wY=\";\n  };\n\n  vendorHash = \"sha256-7SoKHH+tDJKhUQDoVwAzVZXoPuKNJEHDEyQ77BPEDQ0=\";\n\n  # Install shell completions\n  postInstall = ''\n    install -Dm644 completions/pokego.bash \"$out/share/bash-completion/completions/pokego\"\n    install -Dm644 completions/pokego.fish \"$out/share/fish/vendor_completions.d/pokego.fish\"\n    install -Dm644 completions/pokego.zsh \"$out/share/zsh/site-functions/_pokego\"\n  '';\n\n  meta = with lib; {\n    description = \"Command-line tool that lets you display Pokémon sprites in color directly in your terminal\";\n    homepage = \"https://github.com/rubiin/pokego\";\n    license = licenses.gpl3Only;\n    maintainers = with maintainers; [\n      rubiin\n      jameskim0987\n      vinibispo\n    ];\n    mainProgram = \"pokego\";\n    platforms = platforms.all;\n  };\n}\n```\n\n## Adding the overlay to your configuration\n\nThere are a few places you could choose to put the following, I choose to use my\n`configuration.nix` because of my setup:\n\n```nix\n# configuration.nix\nnixpkgs.overlays = [inputs.lib.overlays]\n```\n\n## Installing Pokego\n\n- If you are managing your entire system configuration with NixOS, you would\n  typically add `pokego` to your `environment.systemPackages`.\n\n```nix\n# configuration.nix\nenvironment.systemPackages = with pkgs; [\n  pokego\n]\n```\n\n- If you prefer home-manager you can install `pokego` with home-manager also:\n\n```nix\n# home.nix\nhome.packages = [\n  pkgs.pokego\n]\n```\n\n### Another Overlay Example\n\n```nix\n{\n  inputs = {\n    nixpkgs.url = \"https://flakehub.com/NixOS/nixpkgs/*.tar.gz\";\n\n    nix.url = \"https://flakehub.com/f/NixOS/nix/2.17.0.tar.gz\";\n  };\n\n  outputs = { self, nixpkgs, nix }:\n\n    let\n      system = \"aarch64-darwin\";\n      pkgs = import nixpkgs {\n        inherit system;\n        overlays = [\n          nix.overlays.default\n        ];\n      };\n    in\n    {\n     # `pkgs` is nixpkgs for the system, with nix's overlay applied\n    };\n}\n```\n\n- Normally,\n  `pkgs = import nixpkgs { }`` imports Nixpkgs with default settings.  However, the example above customizes this import by passing arguments:  `pkgs\n  = import nixpkgs { inherit system; overlays = [\n  nix.overlays.default];}`.  This makes the pkgs variable represent nixpkgs specifically for the `aarch64-darwin`\n  system, with the overlay from the nix flake applied.\n\n- Consequently, any packages built using this customized `pkgs` will now depend\n  on or use the specific nix version (`2.17.0`) provided by the nix flake,\n  instead of the version that comes with the fetched `nixpkgs`. This technique\n  can be useful for ensuring a consistent environment or testing specific\n  package versions.\n\n## Customizing Nixpkgs Imports and Overlays\n\nWhile overlays are typically used to add or modify packages within a single\n`nixpkgs` instance, Nix's lazy evaluation and flake inputs allow for even more\npowerful scenarios. You can have multiple versions of nixpkgs in a single flake,\nand they will only be evaluated when a package from that specific version is\nactually referenced. This complements overlays by giving you fine-grained\ncontrol over which nixpkgs instance an overlay applies to, or which `nixpkgs`\nversion a specific part of your project depends on.\n\nConsider this example where we import nixpkgs with a specific overlay applied\ndirectly at the import site:\n\n```nix\n{\n  inputs = {\n    nixpkgs.url = \"[https://flakehub.com/NixOS/nixpkgs/*.tar.gz](https://flakehub.com/NixOS/nixpkgs/*.tar.gz)\"; # This will be the base nixpkgs\n\n    nix.url = \"[https://flakehub.com/f/NixOS/nix/2.17.0.tar.gz](https://flakehub.com/f/NixOS/nix/2.17.0.tar.gz)\"; # This flake provides an overlay for a specific Nix version\n  };\n\n  outputs = { self, nixpkgs, nix }:\n\n    let\n      system = \"aarch64-darwin\";\n      # Here, we import nixpkgs and apply the 'nix' flake's overlay.\n      # This 'pkgs' variable now holds a customized Nix package set.\n      # In this 'pkgs' set, the 'nix' package (and anything that depends on it)\n      # will be version 2.17.0 as defined by the 'nix' flake's overlay.\n      pkgs_with_custom_nix = import nixpkgs {\n        inherit system;\n        overlays = [\n          nix.overlays.default # Apply the overlay from the 'nix' flake here\n        ];\n      };\n    in\n    {\n      # We can then expose packages or devShells that use this customized `pkgs` set.\n      devShells.${system}.default = pkgs_with_custom_nix.mkShell {\n        packages = [\n          pkgs_with_custom_nix.nix # This 'nix' package is now version 2.17.0 due to the overlay!\n        ];\n        shellHook = ''\n          echo \"Using Nix version: <span class=\"math-inline\">\\(nix \\-\\-version\\)\"\n'';\n};\n# You can also make this customized package set available as a top-level overlay\n# if other parts of your flake or configuration want to use it.\n# overlays.custom-nix-version = final: prev: {\n#   inherit (pkgs_with_custom_nix) nix; # Expose the specific nix package from our overlayed pkgs\n# };\n# You can also import multiple versions of nixpkgs and select packages from them:\n# pkgs-2505 = import (inputs.nixpkgs-2505 or nixpkgs) { inherit system; }; # Example, assuming 2505 is an input\n# packages.</span>{system}.my-tool-2505 = pkgs-2505.myTool; # Using a package from a specific stable version\n    };\n}\n```\n\nNormally, `pkgs = import nixpkgs { }` imports Nixpkgs with default settings.\nHowever, the example above customizes this import by passing arguments:\n`pkgs = import nixpkgs { inherit system; overlays = [ nix.overlays.default];}`.\nThis makes the `pkgs_with_custom_nix` variable represent Nixpkgs specifically\nfor the `aarch64-darwin` system, with the overlay from the nix flake applied at\nthe time of import.\n\nConsequently, any packages built using this customized `pkgs_with_custom_nix`\nwill now depend on or use the specific Nix version (`2.17.0`) provided by the\nnix flake's overlay, instead of the version that comes with the base `nixpkgs`\ninput. This technique is highly useful for ensuring a consistent environment or\ntesting specific package versions without affecting the entire system's\n`nixpkgs` set.\n","number":[6,5],"sub_items":[],"path":"flakes/overlays_4.5.md","source_path":"flakes/overlays_4.5.md","parent_names":["Nix Flakes Explained"]}},{"Chapter":{"name":"NixOS Specialisations For Multiple Profiles","content":"# NixOS Specialisations For Multiple Profiles\n\n<details>\n<summary> ✔️ Click to Expand Table of Contents</summary>\n\n<!-- toc -->\n\n</details>\n\n**NixOS specialisations** are a powerful feature that allow you to define\nalternative system configurations variations within a single NixOS setup. Each\nspecialisation can modify or extend the base configuration, and NixOS will\ngenerate separate boot entries for each, letting you choose at boot time (or\nswitch at runtime) which environment to use. This is ideal for testing,\nhardware-specific tweaks, or separating work and personal environments without\nmaintaining multiple configuration files\n\n## How Specialisations Work\n\nSpecialisations are defined as attributes under the `specialisation` option in\nyour configuration. Each key (e.g., `niri-test`) represents a named\nspecialisation, and its configuration attribute contains the NixOS options to\napply on top of the base system\n\nBy default, a specialisation inherits the parent configuration and applies its\nchanges on top. You can also set `inheritParentConfig = false;` to create a\ncompletely separate configuration.\n\nAfter running `nixos-rebuild boot`, your bootloader will present extra entries\nfor each specialisation. Selecting one boots into the system with that\nspecialisation's settings applied\n\nRuntime Switching: You can switch to a specialisation at runtime using\nactivation scripts, e.g.:\n\n```bash\nnixos-rebuild switch --specialisation niri-test\n```\n\nor\n\n```bash\n/run/current-system/specialisation/niri-test/bin/switch-to-configuration switch\n```\n\n> Note: Some changes (like kernel switches) require a reboot to take effect\n\nExample: Let's create a basic specialisation to try out the Niri Window Manager:\n\nFirst we have to add the `niri-flake` as an input to our `flake.nix` and add the\nmodule to install it:\n\n```nix\n# flake.nix\ninputs = {\n     niri.url = \"github:sodiboo/niri-flake\";\n};\n```\n\n```nix\n# configuration.nix\n{ pkgs, inputs, ... }: {\n# ... snip ...\nimports = [\n    inputs.niri.nixosModules.niri\n];\n\n# This is the top-level overlay\n  nixpkgs.overlays = [inputs.niri.overlays.niri];\n\n# ... snip ...\n\n  specialisation = {\n    niri-test.configuration = {\n      system.nixos.tags = [\"niri\"];\n\n      # Add the Niri overlay for this specialisation\n      nixpkgs.overlays = [inputs.niri.overlays.niri];\n\n      # Enable Niri session\n      programs.niri = {\n        enable = true;\n        package = pkgs.niri-unstable;\n      };\n\n      # Optionally, add a test user and greetd for login\n      users.users.niri = {\n        isNormalUser = true;\n        extraGroups = [\"networkmanager\" \"video\" \"wheel\"];\n        initialPassword = \"test\"; # for testing only!\n        createHome = true;\n      };\n\n      services.greetd = {\n        enable = true;\n        settings = rec {\n          initial_session = {\n            command = lib.mkForce \"${pkgs.niri}/bin/niri\";\n            user = lib.mkForce \"niri\";\n          };\n          default_session = initial_session;\n        };\n      };\n\n      environment.etc.\"niri/config.kdl\".text = ''\n        binds {\n          Mod+T { spawn \"alacritty\"; }\n          Mod+D { spawn \"fuzzel\"; }\n          Mod+Q { close-window; }\n          Mod+Shift+Q { exit; }\n        }\n      '';\n      environment.systemPackages = with pkgs; [\n        alacritty\n        waybar\n        fuzzel\n        mako\n        firefox\n      ];\n\n      programs.firefox.enable = true;\n\n      services.pipewire = {\n        enable = true;\n        alsa.enable = true;\n        pulse.enable = true;\n        # Optionally:\n        jack.enable = true;\n      };\n\n      hardware.alsa.enablePersistence = true;\n\n      networking.networkmanager.enable = true;\n    };\n  };\n}\n```\n\nI chose to use the nightly version so it was required to add the overlay at the\ntop-level as well as inside the `specialisation` block.\n\nOn my system it sped up build times to first run:\n\n```bash\nsudo nixos-rebuild switch --flake .\n# And Then Run\nsudo nixos-rebuild boot --flake .\n```\n\n**What this does**:\n\n- Creates a boot entry called `niri-test` with the Niri Wayland compositor, a\n  test user, and a `greetd` login manager.\n\n- Installs a set of packages and enables PipeWire with ALSA, PulseAudio, and\n  JACK support.\n\n- Provides a custom Niri configuration file for a few keybinds and enables\n  NetworkManager.\n\n## Using Your Specialisation After Boot\n\nOnce you have rebooted and selected your specialisation from the boot menu, you\ncan use your system as usual. If you want to add or remove programs, change\nsettings, or update your environment within a specialisation, simply:\n\n1.  Edit your configuration: Add or remove packages (e.g., add `ghostty` to\n    `environment.systemPackages`) or change any other options inside the\n    relevant `specialisation` block in your NixOS configuration.\n\n2.  Apply changes with a rebuild: Run the standard NixOS rebuild command. If you\n    are currently running the specialisation you want to update, use:\n\n```bash\nsudo nixos-rebuild switch\n```\n\nThis will apply your changes to the current specialisation\n\nIf you want to build and activate a different specialisation from your current\nsession, use:\n\n```bash\nsudo nixos-rebuild switch --specialisation name\n```\n\nOr, you can activate a specialisation directly with:\n\n```bash\nsudo /run/current-system/specialisation/<name>/bin/switch-to-configuration switch\n```\n\nReplace `<name>` with your specialisation’s name.\n\nReboot if needed: Most changes apply immediately, but some (like kernel or\n`initrd` changes) require a reboot for the specialisation to fully take effect\n\n**Tip**:\n\nEach specialisation can have its own set of installed programs. Only those\nlisted in the `environment.systemPackages` (or enabled via modules) inside the\n`specialisation` block will be available when you boot into that context.\n\nYou manage and update your specialisation just like your main NixOS system no\nspecial commands or workflow are required beyond specifying the specialisation\nwhen rebuilding or switching.\n\n## Use Cases for Specialisations\n\n- **Hardware Profiles**: Enable/disable drivers or services for specific\n  hardware (e.g., eGPU, WiFi, or SR-IOV setups)\n\n- **Desktop Environments**: Quickly switch between different desktop\n  environments or compositors (e.g., GNOME, Plasma, Niri)\n\n- **Testing**: Safely try out unstable packages, new kernels, or experimental\n  features without risking your main environment\n\n- **User Separation**: Create profiles for different users, each with their own\n  settings, packages, and auto-login\n\n- **Secure Environments**: Combine with encrypted partitions for more secure,\n  isolated setups\n\n## Securely Separated Contexts with NixOS Specialisations\n\nI will just explain the concept here for completeness, if you want to implement\nthis I recommend following:\n\n[Tweag Hard User Separation with NixOS](https://www.tweag.io/blog/2022-11-01-hard-user-separation-with-nixos/)\n\n<details>\n<summary> ✔️ Click To Expand Section on Separate Contexts </summary>\n\nIf you use the same computer in different contexts such as for work and for your\nprivate life you may worry about the risks of mixing sensitive environments. For\nexample, a cryptolocker received through a compromised work email could\npotentially encrypt your personal files, including irreplaceable family photos.\n\nA common solution is to install two different operating systems and dual-boot\nbetween them, keeping work and personal data isolated. However, this approach\nmeans you have two systems to maintain, update, and configure, which can be a\nsignificant hassle.\n\nNixOS offers a third alternative: With NixOS specialisations, you can manage two\n(or more) securely separated contexts within a single operating system. At boot\ntime, you select which context you want to use work or personal. Each context\ncan have its own encrypted root partition, user accounts, and configuration, but\nboth share the same Nix store for packages. This means:\n\n- No duplicated packages: Both contexts use the same system-wide package store,\n  saving space and simplifying updates.\n\n- Single system to maintain: You update and manage only one NixOS installation,\n  not two.\n\n- Strong security boundaries: Each context can have its own encrypted root, so a\n  compromise in one context (such as malware in your work environment) cannot\n  access the data in the other context.\n\n- Flexible management: You can configure both contexts from either environment,\n  making administration easier.\n\nThis approach combines the security of dual-booting with the convenience and\nefficiency of a single, unified system.\n\n**How It Works**:\n\n- Encrypted Partitions: Each context (work and personal) has its own encrypted\n  root partition. The shared /nix/store partition is also encrypted, but can be\n  unlocked by either context.\n\n- Specialisations at Boot: NixOS generates multiple boot entries, one for each\n  context. You simply choose your desired environment at boot time.\n\n- Separation of Data: Your work and personal home directories, settings, and\n  documents remain isolated from each other, while still benefiting from shared\n  system packages.\n\nBenefits Over Traditional Dual-Boot\n\n- Only one system to update and configure.\n\n- No wasted disk space on duplicate packages.\n\n- Seamless switching between contexts with a reboot.\n\n- Consistent NixOS tooling and workflows in both environments.\n\nWhat You Need\n\n- A physical or virtual machine supported by NixOS.\n\n- Willingness to erase the system disk during setup.\n\n- LVM (Logical Volume Manager) support: This setup requires using LVM for disk\n  partitioning and management. LVM allows you to create multiple logical volumes\n  on a single physical disk, making it possible to securely separate your work\n  and personal environments while sharing a common Nix store. You will use LVM\n  commands such as `pvcreate`, `vgcreate`, and `lvcreate` to prepare your disk\n  layout\n\nIn summary: With NixOS specialisations and careful disk partitioning, you can\nachieve secure, convenient, and efficient context separation—no need to\ncompromise between security and manageability.\n\n</details>\n\n### Tips and Best Practices\n\n- Overriding Values: Use `lib.mkDefault` or `lib.mkForce` to make options\n  overridable or forced in specialisations. I had to do it above because I have\n  greetd setup for my main configuration as well.\n\n- Selective Configuration: If you want certain options only in the default\n  (non-specialised) system, use:\n\n```nix\nconfig = lib.mkIf (config.specialisation != {}) { ... }\n```\n\n- This condition checks if you're in a specialisation.\n\n- Any settings inside this block will **not** be inherited by specialisations,\n  keeping them exclusive to the main system.\n\n- Runtime Limitations: Not all changes (e.g., kernel or `initrd`) can be fully\n  applied at runtime; a reboot is required for those.\n\n- Modularity: Specialisations work well with modular NixOS configs keep\n  hardware, user, and service configs in separate files for easier management\n\nReferences to Official Documentation and Community Resources\n\n- [Tweag: Introduction to NixOS specialisations](https://www.tweag.io/blog/2022-08-18-nixos-specialisations/)\n\n- [NixOS Wiki: Specialisation](https://wiki.nixos.org/wiki/Specialisation)\n\n- [Tweag Hard User Separation with NixOS](https://www.tweag.io/blog/2022-11-01-hard-user-separation-with-nixos/)\n","number":[6,6],"sub_items":[],"path":"flakes/specialisations_4.6.md","source_path":"flakes/specialisations_4.6.md","parent_names":["Nix Flakes Explained"]}}],"path":"Nix_Flakes_Explained_4.md","source_path":"Nix_Flakes_Explained_4.md","parent_names":[]}},{"Chapter":{"name":"Understanding Top-Level Attributes","content":"---\ntitle: My Chapter\ndate: 2025-11-21\nauthor: saylesss88\ndescription: Chapter 5\n---\n\n# Chapter 5\n\n<details>\n<summary> ✔️ Click to Expand Table of Contents</summary>\n\n<!-- toc -->\n\n</details>\n\n![coding1](images/coding1.png)\n\n<!-- <img src=\"images/gruv9.png\" width=\"800\" height=\"600\"> -->\n\n## Understanding Top-Level Attributes in NixOS Modules\n\nThis explanation is based on insights from Infinisil, a prominent figure in the\nNix community, to help clarify the concept of top-level attributes within NixOS\nmodules.\n\n### The Core of a NixOS System: `system.build.toplevel`\n\n<details>\n<summary> ✔️ `system.build.toplevel` Explained (Click to Expand) </summary>\n\nIn a NixOS system, everything is built from a single \"system derivation.\" The\ncommand `nix-build '<nixpkgs/nixos>' -A system` initiates this build process.\n\nThe `-A system` part tells Nix to focus on the `system` attribute defined in the\n`'<nixpkgs/nixos>'` file (which is essentially `./default.nix` within the\nNixpkgs repository).\n\nThis `system` attribute is specifically the NixOS option `system.build.toplevel`\n. Think of `system.build.toplevel` as the **very top of the configuration\nhierarchy** for your entire NixOS system. Almost every setting you configure\neventually influences this top-level derivation, often through a series of\nintermediate steps.\n\n**Key Takeaway:** `system.build.toplevel` is the ultimate output that defines\nyour entire NixOS system.\n\n</details>\n\n### How Options Relate: A Chain of Influence\n\nOptions in NixOS are not isolated; they often build upon each other.\n\n<details>\n<summary>Example: Nginx Option Chain (Click to Expand)</summary>\n\nHere's an example of how a high-level option can lead down to a low-level system\nconfiguration:\n\n- You enable Nginx with `services.nginx.enable = true;`.\n- This setting influences the lower-level option `systemd.services.nginx`.\n- Which, in turn, affects the even lower-level option\n  `systemd.units.\"nginx.service\"`.\n- Ultimately, this leads to the creation of a systemd unit file within\n  `environment.etc.\"systemd/system\"`.\n- Finally, this unit file ends up as `result/etc/systemd/system/nginx.service`\n  within the final `system.build.toplevel` derivation.\n\n</details>\n\n**Key Takeaway:** Higher-level, user-friendly options are translated into\nlower-level system configurations that are part of the final system build.\n\n### The NixOS Module System: Evaluating Options\n\nSo, how do these options get processed and turned into the final system\nconfiguration? That's the job of the **NixOS module system**, located in the\n`./lib` directory of Nixpkgs (specifically in `modules.nix`, `options.nix`, and\n`types.nix`).\n\nInterestingly, the module system isn't exclusive to NixOS; you can use it to\nmanage option sets in your own Nix projects.\n\nHere's a simplified example of using the module system outside of NixOS:\n\n```nix\nlet\n  systemModule = { lib, config, ... }: {\n    options.toplevel = lib.mkOption {\n      type = lib.types.str;\n    };\n\n    options.enableFoo = lib.mkOption {\n      type = lib.types.bool;\n      default = false;\n    };\n\n    config.toplevel = ''\n      Is foo enabled? ${lib.boolToString config.enableFoo}\n    '';\n  };\n\n  userModule = {\n    enableFoo = true;\n  };\n\nin (import <nixpkgs/lib>).evalModules {\n  modules = [ systemModule userModule ];\n}\n```\n\n**You can evaluate the `config.toplevel` option from this example using:**\n\n```bash\nnix-instantiate --eval file.nix -A config.toplevel\n```\n\n**Key Takeaway**: The NixOS module system is responsible for evaluating and\nmerging option configurations from different modules.\n\n### How the Module System Works: A Simplified Overview\n\nThe module system processes a set of \"modules\" through these general steps:\n\n<details>\n<summary> ✔️ Detailed Steps (Click to Expand)</summary>\n\n1. **Importing Modules**: It recursively finds and includes all modules\n   specified in `imports = [ ... ];` statements.\n\n2. **Declaring Options**: It collects all option declarations defined using\n   `options = { ... };` from all the modules and merges them. If the same option\n   is declared in multiple modules, the module system handles this (details\n   omitted for simplicity).\n\n3. **Defining Option Values**: For each declared option, it gathers all the\n   value assignments (defined using `config = { ... };` or directly at the top\n   level if no `options` or `config` are present) from all modules and merges\n   them according to the option's defined type.\n\n> **Important Note**: Option evaluation is lazy, meaning an option's value is\n> only computed when it's actually needed. It can also depend on the values of\n> other options.\n\n</details>\n\n**Key Takeaway**: The module system imports, declares, and then evaluates option\nvalues from various modules to build the final configuration.\n\n**Top-Level Attributes in a Module: `imports`, `options`, and `config`**\n\nWithin a NixOS module (the files that define parts of your system configuration)\n, the attributes defined directly at the top level of the module's function have\nspecific meanings:\n\n- `imports`: This attribute is a list of other module files to include. Their\n  options and configurations will also be part of the evaluation.\n\n- `options`: This attribute is where you declare new configuration options. You\n  define their type, default value, description, etc., using functions like\n  `lib.mkOption` or `lib.mkEnableOption`.\n\n- `config`: This attribute is where you assign values to the options that have\n  been declared (either in the current module or in imported modules).\n\n**Key Takeaway**: The top-level attributes `imports`, `options`, and `config`\nare the primary ways to structure a NixOS module.\n\n**The Rule: Move Non-Option Attributes Under `config`**\n\nIf you define either an `options` or a `config` attribute at the top level of\nyour module, any other attributes that are not option declarations must be moved\ninside the config attribute.\n\n<details>\n<summary> ✔️ Examples of Correct and Incorrect Usage (Click to Expand)</summary>\n\nLet's look at an example of what not to do:\n\n```nix\n{ pkgs, lib, config, ... }:\n{\nimports = [];\n\n# Defining an option at the top level\n\noptions.mine.desktop.enable = lib.mkEnableOption \"desktop settings\";\n\n# This will cause an error because 'environment' and 'appstream'\n\n# are not 'options' and 'config' is also present at the top level.\n\nenvironment.systemPackages =\nlib.mkIf config.appstream.enable [ pkgs.git ];\n\nappstream.enable = true;\n}\n```\n\nThis will result in the error:\n`error: Module has an unsupported attribute 'appstream' This is caused by introducing a top-level 'config' or 'options' attribute. Add configuration attributes immediately on the top level instead, or move all of them into the explicit 'config' attribute`.\n\n**Key Takeaway**: When you have `options` or `config` at the top level, all\nvalue assignments need to go inside the config block.\n\n**The Correct Way**): Using the `config` Attribute\n\nTo fix the previous example, you need to move the value assignments for\n`environment.systemPackages` and `appstream.enable` inside the config attribute:\n\n```nix\n{ pkgs, lib, config, ... }:\n{\nimports = [];\n\n# Defining an option at the top level\n\noptions.mine.desktop.enable = lib.mkEnableOption \"desktop settings\";\n\nconfig = {\nenvironment.systemPackages =\nlib.mkIf config.appstream.enable [ pkgs.git ];\n\n    appstream.enable = true;\n\n};\n}\n```\n\nNow, Nix knows that you are declaring an option (`options.mine.desktop.enable`)\nand then setting values for other options (`environment.systemPackages`,\n`appstream.enable`) within the `config` block.\n\n**Key Takeaway**: The `config` attribute is used to define the values of\noptions.\n\n**Implicit `config`: When `options` is Absent**\n\nIf your module does not define either `options` or `config` at the top level,\nthen any attributes you define directly at the top level are implicitly treated\nas being part of the config.\n\nFor example, this is valid:\n\n```nix\n{ pkgs, lib, config, ... }:\n{\nenvironment.systemPackages =\nlib.mkIf config.appstream.enable [ pkgs.git ];\n\nappstream.enable = true;\n}\n```\n\nNix will implicitly understand that `environment.systemPackages` and\n`appstream.enable` are configuration settings.\n\n**Key Takeaway**: If no explicit options or config are present, top-level\nattributes are automatically considered part of the configuration.\n\n**Removing an Option: What Happens to `config`**\n\nEven if you remove the `options` declaration from a module that has a `config`\nsection, the `config = { environment.systemPackages = ... };` part will still\nfunction correctly, assuming the option it's referencing (`appstream.enable` in\nthis case) is defined elsewhere (e.g., in an imported module).\n\n</details>\n\n**Key Takeaway**: The `config` section defines values for options, regardless of\nwhether those options are declared in the same module.\n\n#### Conclusion\n\nUnderstanding the nuances of top-level attributes within NixOS modules,\nparticularly `imports`, `options`, and `config`, is fundamental to structuring\nand managing your system's configuration effectively. As we've seen, the module\nsystem provides a powerful and declarative way to define and evaluate system\nsettings, ultimately contributing to the construction of the\n`system.build.toplevel` derivation that represents your entire NixOS\nenvironment.\n\nThe concepts of option declaration and value assignment, along with the crucial\nrule of organizing non-option attributes under the `config` attribute when\n`options` is present, provide a clear framework for building modular and\nmaintainable configurations.\n\nNow that we have a solid grasp of how NixOS modules are structured and how they\ncontribute to the final system derivation, it's a natural next step to explore\nthe tangible results of these configurations: the software and system components\nthemselves. These are built and managed by a core concept in Nix, known as\n**derivations**.\n\nIn the next chapter,\n[Package Definitions Explained](https://saylesss88.github.io/Package_Definitions_Explained_6.html)\nwe will shift our focus from the abstract configuration to the concrete software\npackages. We will learn how Nix uses _package definitions_ to create\n_derivations_, which are the actual build plans that produce the software we use\non our NixOS systems. This will bridge the gap between configuring your system\nand understanding how the software within it is managed.\n","number":[7],"sub_items":[],"path":"Understanding_Top-Level_Attributes_5.md","source_path":"Understanding_Top-Level_Attributes_5.md","parent_names":[]}},{"Chapter":{"name":"Package Definitions Explained","content":"---\ntitle: My Chapter\ndate: 2025-11-21\nauthor: saylesss88\ndescription: Chapter 6\n---\n\n# Chapter 6\n\n<details>\n<summary> ✔️ Click to Expand Table of Contents</summary>\n\n<!-- toc -->\n\n</details>\n\n![coding2](images/coding2.png)\n\n<!-- ![gruv1](images/gruv1.png) -->\n\n## Package Definitions Explained\n\nIn Nix, the concept of a **package** can refer to two things:\n\n- A collection of files and data that constitute a piece of software or an\n  artifact.\n\n- A Nix **expression** that describes how to create such a collection. This\n  expression acts as a blueprint before the package exists in a tangible form.\n\nThe process begins with writing a **package definition** using the Nix language.\nThis definition contains the necessary instructions and metadata about the\nsoftware you intend to \"package.\"\n\n## The Journey from Definition to Package\n\n<details>\n<summary> ✔️ Click to Expand</summary>\n\n1.  **Package Definition:**\n    - This is essentially a function written in the Nix language.\n\n    - Nix language shares similarities with JSON but includes the crucial\n      addition of functions.\n\n    - It acts as the blueprint for creating a package.\n\n2.  **Derivation:**\n    - When the package definition is evaluated by Nix, it results in a\n      **derivation**.\n\n    - A derivation is a concrete and detailed build plan.\n\n    - It outlines the exact steps Nix needs to take: fetching source code,\n      building dependencies, compiling code, and ultimately producing the\n      desired output (the package).\n\n3.  **Realization (Building the Package):**\n    - You don't get a pre-built \"package\" directly from the definition or the\n      derivation.\n\n    - The package comes into being when Nix **executes** the derivation. This\n      process is often referred to as \"realizing\" the derivation.\n\n**Analogy:** Think of a package definition as an architectural blueprint, the\nderivation as the detailed construction plan, and the realized package as the\nfinished building.\n\n</details>\n## Skeleton of a Derivation\n\nThe most basic derivation structure in Nix looks like this:\n\n```nix\n{ stdenv }:\n\nstdenv.mkDerivation { }\n```\n\n- This is a function that expects an attribute set containing `stdenv` as its\n  argument.\n\n- It then calls `stdenv.mkDerivation` (a function provided by `stdenv`) to\n  produce a derivation.\n\n- Currently, this derivation doesn't specify any build steps or outputs.\n\n- Further Reading:\n\n- [The Standard Environment](https://ryantm.github.io/nixpkgs/stdenv/stdenv/)\n\n- [Fundamentals of Stdenv](https://nixos.org/guides/nix-pills/19-fundamentals-of-stdenv.html)\n\n## Example: A Simple \"Hello\" Package Definition\n\nHere's a package definition for the classic \"hello\" program:\n\n```nix\n# hello.nix\n{\n  stdenv,\n  fetchzip,\n}:\n\nstdenv.mkDerivation {\n  pname = \"hello\";\n  version = \"2.12.1\";\n\n  src = fetchzip {\n    url = \"[https://ftp.gnu.org/gnu/hello/hello-2.12.1.tar.gz](https://ftp.gnu.org/gnu/hello/hello-2.12.1.tar.gz)\";\n    sha256 = \"\";\n  };\n}\n```\n\n- This is a Nix function that takes stdenv and fetchzip as arguments.\n\n- It uses `stdenv.mkDerivation` to define the build process for the \"hello\"\n  package.\n  - `pname`: The package name.\n\n  - `version`: The package version.\n\n  - `src`: Specifies how to fetch the source code using `fetchzip`.\n\n**Handling Dependencies: Importing Nixpkgs**\n\n- If you try to build `hello.nix` directly with `nix-build hello.nix`, it will\n  fail because `stdenv` and `fetchzip` are part of Nixpkgs, which isn't included\n  in this isolated file.\n\n- To make this package definition work, you need to pass the correct arguments\n  (`stdenv`, `fetchzip`) to the function.\n\nThe recommended approach is to create a `default.nix` file in the same\ndirectory:\n\n```nix\n# default.nix\n\nlet\n  nixpkgs = fetchTarball \"[https://github.com/NixOS/nixpkgs/tarball/nixos-24.05](https://github.com/NixOS/nixpkgs/tarball/nixos-24.05)\";\n  pkgs = import nixpkgs { config = {}; overlays = []; };\nin\n{\n  hello = pkgs.callPackage ./hello.nix { };\n}\n```\n\n- This `default.nix` imports Nixpkgs.\n\n- It then uses `pkgs.callPackage` to call the function in `hello.nix`, passing\n  the necessary dependencies from Nixpkgs.\n\n- You can now build the \"hello\" package using: `nix-build -A hello`. The `-A`\n  flag tells Nix to build the attribute named hello from the top-level\n  expression in default.nix.\n\n**Realizing the Derivation and Handling sha256**\n\n- **Evaluation vs. Realization**: While \"evaluate\" refers to Nix processing an\n  expression, \"realize\" often specifically means building a derivation and\n  producing its output in the Nix store.\n\n- When you first run `nix-build -A hello`, it will likely fail due to a missing\n  sha256 hash for the source file. Nix needs this hash for security and\n  reproducibility. The error message will provide the correct sha256 value.\n\n- **Example Error**:\n\n```bash\n  nix-build -A hello\n  error: hash mismatch in fixed-output derivation '/nix/store/pd2kiyfa0c06giparlhd1k31bvllypbb-source.drv':\n  specified: sha256-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\n  got: sha256-1kJjhtlsAkpNB7f6tZEs+dbKd8z7KoNHyDHEJ0tmhnc=\n  error: 1 dependencies of derivation '/nix/store/b4mjwlv73nmiqgkdabsdjc4zq9gnma1l-hello-2.12.1.drv' failed to build\n```\n\n- Replace the empty `sha256 = \"\";` in `hello.nix` with the provided correct\n  value: `sha256 = \"1kJjhtlsAkpNB7f6tZEs+dbKd8z7KoNHyDHEJ0tmhnc=\";`.\n\n**Building and Running the Result**\n\nAfter updating the `sha256`, you can successfully build the package:\n\n```bash\nnix-build -A hello\n```\n\nThe output will be a result symlink pointing to the built package in the Nix\nstore. You can then run the \"hello\" program:\n\n```bash\n./result/bin/hello\nHello, world!\n```\n\n### Swaytools Package Definition\n\n**Example: The swaytools Package Definition**\n\nLet's examine a more complex, real-world package definition from Nixpkgs:\n`nixpkgs/pkgs/tools/wayland/swaytools/default.nix`.\n\n```nix\n# default.nix\n{\n  lib,\n  setuptools,\n  buildPythonApplication,\n  fetchFromGitHub,\n  slurp,\n}:\n\nbuildPythonApplication rec {\n  pname = \"swaytools\";\n  version = \"0.1.2\";\n\n  format = \"pyproject\";\n\n  src = fetchFromGitHub {\n    owner = \"tmccombs\";\n    repo = \"swaytools\";\n    rev = version;\n    sha256 = \"sha256-UoWK53B1DNmKwNLFwJW1ZEm9dwMOvQeO03+RoMl6M0Q=\";\n  };\n\n  nativeBuildInputs = [ setuptools ];\n\n  propagatedBuildInputs = [ slurp ];\n\n  meta = with lib; {\n    homepage = \"https://github.com/tmccombs/swaytools\";\n    description = \"Collection of simple tools for sway (and i3)\";\n    license = licenses.gpl3Only;\n    maintainers = with maintainers; [ atila ];\n    platforms = platforms.linux;\n  };\n}\n```\n\n### Breakdown of the Above default.nix\n\n<details>\n<summary>Click to Expand</summary>\n\n1 **Function Structure**:\n\n- The file starts with a function taking an attribute set of dependencies from\n  Nixpkgs: `{ lib, setuptools, buildPythonApplication, fetchFromGitHub, slurp }`\n  :.\n\n2. **Derivation Creation**:\n\n- It calls `buildPythonApplication`, a specialized helper for Python packages\n  (similar to `stdenv.mkDerivation` but pre-configured for Python). The `rec`\n  keyword allows attributes within the derivation to refer to each other.\n\n3. **Package Metadata**:\n\n- `pname` and `version` define the package's name and version.\n\n- The `meta` attribute provides standard package information like the homepage,\n  description, license, maintainers, and supported platforms.\n\n4. **Source Specification**:\n\n- The `src` attribute uses `fetchFromGitHub` to download the source code from\n  the specified repository and revision, along with its `sha256` hash for\n  verification.\n\n5. **Build and Runtime Dependencies**:\n\n- `nativeBuildInputs`: Lists tools required during the build process (e.g.,\n  `setuptools` for Python).\n\n- `propagatedBuildInputs`: Lists dependencies needed at runtime (e.g., `slurp`).\n\n6. **Build Format**:\n\n- `format = \"pyproject\";` indicates that the package uses a `pyproject.toml`\n  file for its Python build configuration.\n\n**Integration within Nixpkgs**\n\n- **Location**: The swaytools definition resides in\n  `pkgs/tools/wayland/swaytools/default.nix`.\n\n- **Top-Level Inclusion**: It's made available as a top-level package in\n  `pkgs/top-level/all-packages.nix` like this:\n\n```nix\n# all-packages.nix\nswaytools = python3Packages.callPackage ../tools/wayland/swaytools { };\n```\n\n- `python3Packages.callPackage` is used here because `swaytools` is a Python\npackage, and it ensures the necessary Python-related dependencies are correctly\npassed to the `swaytools` definition.\n</details>\n\n## Conclusion\n\nIn this chapter, we've journeyed through the fundamental concept of package\ndefinitions in Nix. We've seen how these Nix expressions act as blueprints,\nleading to the creation of derivations – the detailed plans for building\nsoftware. Finally, we touched upon the realization process where Nix executes\nthese derivations to produce tangible packages in the Nix store. Examining the\nsimple \"hello\" package and the more complex \"swaytools\" definition provided\npractical insights into the structure and key attributes involved in defining\nsoftware within the Nix ecosystem.\n\nThe crucial step in this process, the transformation from a package definition\nto a concrete build plan, is embodied by the **derivation**. This detailed\nspecification outlines every step Nix needs to take to fetch sources, build\ndependencies, compile code, and produce the final package output. Understanding\nthe anatomy and lifecycle of a derivation is key to unlocking the full power and\nflexibility of Nix.\n\nIn the **next chapter**,\n[Introduction to Nix Derivations](https://saylesss88.github.io/Intro_to_Nix_Derivations_7.html),\nwe will delve deeper into the structure and components of these derivations. We\nwill explore the attributes that define a build process, how dependencies are\nmanaged within a derivation, and how Nix ensures the reproducibility and\nisolation of your software builds through this fundamental concept.\n\n## Resources\n\n- [Packaging Existing Software](https://nix.dev/tutorials/packaging-existing-software.html)\n","number":[8],"sub_items":[],"path":"Package_Definitions_Explained_6.md","source_path":"Package_Definitions_Explained_6.md","parent_names":[]}},{"Chapter":{"name":"Intro to Nix Derivations","content":"# Chapter 7\n\n<details>\n<summary> ✔️ Click to Expand Table of Contents</summary>\n\n<!-- toc -->\n\n</details>\n\n## Introduction to Nix Derivations\n\n![gruv10](images/gruv10.png)\n\nNix's build instructions, known as **derivations**, are defined using the Nix\nLanguage. These derivations can describe anything from individual software\npackages to complete system configurations. The Nix package manager then\ndeterministically \"realizes\" (builds) these derivations, ensuring consistency\nbecause they rely solely on a predefined set of inputs.\n\nMost things in NixOS are built around derivations. Your NixOS system is\ndescribed by such a single system derivation. When you want to apply a new\nconfiguration, `nixos-rebuild` handles the process:\n\nIt first builds this derivation:\n\n```bash\nnix-build '<nixpkgs/nixos>' -A system\n```\n\nThen, once the build is complete, it switches to that new system:\n\n```bash\nresult/bin/switch-to-configuration\n```\n\nAfter the build, `nixos-rebuild` updates a crucial symbolic link:\n`/run/current-system` This symlink always points to the active, running version\nof your system in the Nix store. In essence, the `/run/current-system` path is\nthe currently active system derivation. This design choice gives NixOS its\npowerful atomic upgrade and rollback capabilities: changing your system involves\nbuilding a new system derivation and updating this symlink to point to the\nlatest version.\n\n> ```nix\n>  ls -lsah /run/current-system\n>  0 lrwxrwxrwx 1 root root 85 May 23 12:11 /run/current-system -> /nix/store/\n>  cy2c0kxpjrl7ajlg9v3zh898mhj4dyjv-nixos-system-magic-25.11.20250520.2795c50\n> ```\n\n- The `->` indicates a symlink and it's pointing to a **store path** which is\n  the result of a derivation being built (the system closure)\n\n- For beginners, the analogy of a cooking recipe is helpful:\n  - **Ingredients (Dependencies):** What other software or libraries are needed.\n\n  - **Steps (Build Instructions):** The commands to compile, configure, and\n    install.\n\n  - **Final Dish (Output):** The resulting package or resource.\n\nA Nix derivation encapsulates all this information, telling Nix what inputs to\nuse, how to build it, and what the final output should be.\n\nNix derivations run in **pure**, **isolated environments**, meaning they\n**cannot** access the internet during the build phase. This ensures that builds\nare reproducible -- they don't depend on external sources that might change over\ntime.\n\nThere are `Fixed-output-derivations` that allow fetching resources during the\nbuild process by explicitly specifying the expected hash upfront. Just keep this\nin mind that normal derivations don't have network access.\n\n## Creating Derivations in Nix\n\nThe primary way to define packages in Nix is through the `mkDerivation`\nfunction, which is part of the standard environment (`stdenv`). While a\nlower-level `derivation` function exists for advanced use cases, `mkDerivation`\nsimplifies the process by automatically managing dependencies and the build\nenvironment.\n\n`mkDerivation` (and `derivation`) takes a set of attributes as its argument. At\na minimum, you'll often encounter these essential attributes:\n\n1.  **name:** A human-readable identifier for the derivation (e.g., \"foo\",\n    \"hello.txt\"). This helps you and Nix refer to the package.\n\n2.  **system:** Specifies the target architecture for the build (e.g.,\n    `builtins.currentSystem` for your current machine).\n\n3.  **builder:** Defines the program that will execute the build instructions\n    (e.g., `bash`).\n\n**How do we pass these required attributes to the `derivation` function?**\n\nFunctions in Nix often take a single argument which is an attribute set. For\n`derivation` and `mkDerivation`, this takes the form\n`functionName { attribute1 = value1; attribute2 = value2; ... }`, where the `{}`\nencloses the set of attributes being passed as the function's argument.\n\nRemember that `derivation` and `mkDerivation` take a set (i.e. `{}`) of\nattributes as its first argument. So, in order to pass the required attributes\nyou would do something like this:\n\n```nix\nnix-repl> pkgs = import <nixpkgs> {}\n\nnix-repl> d = derivation {\n            name = \"mydrv\";\n            builder = \"${pkgs.bash}/bin/bash\";\n            args = [\n              \"-c\" # Tells bash to execute the following string as a command\n              ''\n                # Explicitly set PATH to include coreutils bin directory\n                export PATH=\"${pkgs.coreutils}/bin:$PATH\"\n                mkdir $out\n              ''\n            ];\n            system = builtins.currentSystem;\n          }\n\nnix-repl> :b d\n```\n\n- When I was starting out, seeing the above written in the following format made\n  it clearer in my mental map that we were passing these attributes as arguments\n  but both accomplish the same thing.\n\n```nix\nd = derivation { name = \"myname\"; builder = \"${coreutils}/bin/true\"; system = builtins.currentSystem; }\n```\n\n- When you write `pkgs = import <nixpkgs> {};`, you are importing the Nixpkgs\n  `default.nix` file, which resolves to a function. Calling that function by\n  passing it an empty attribute set `{}` as its argument. The function then\n  evaluates and returns the entire `pkgs` attribute set. To specify a different\n  system for example, you could do something like:\n\n```nix\npkgsForAarch64 = import <nixpkgs> { system = \"aarch64-linux\"; };\n```\n\nSo when you see:\n\n```nix\nimport <nixpkgs> { overlays = []; config = {}; }\n```\n\n- Instead, these empty sets explicitly override any global or implicit\n  overlays/configurations that Nix might otherwise pick up from environment\n  variables (like `NIXPKGS_CONFIG`), default locations (like\n  `~/.config/nixpkgs/config.nix` or `~/.config/nixpkgs/overlays`), or other\n  mechanisms.\n\n- This is to prevent accidental partial application from other parts of your\n  configuration and is saying \"Do not pass any custom configuration options for\n  this particular import\"\n\n- `derivation` is a pre-made, built-in function in the Nix language. Here, we\n  are passing it an attribute set as argument with the three required\n  attributes. (`name`, `builder`, `system`, and we added an extra argument\n  `args`.)\n\n## The Hello World Derivation\n\nFor this example, first create a `hello` directory and add the\n[Hello tarball](https://ftp.gnu.org/gnu/hello/hello-2.12.1.tar.gz) to said\ndirectory.\n\nNow lets create the classic Hello derivation:\n\n```nix\n# hello.nix\nlet\n  pkgs = import <nixpkgs> { };\nin\nderivation {\n  name = \"hello\";\n  builder = \"${pkgs.bash}/bin/bash\";\n  args = [ ./hello_builder.sh ];\n  inherit (pkgs)\n    gnutar\n    gzip\n    gnumake\n    gcc\n    coreutils\n    gawk\n    gnused\n    gnugrep\n    ;\n  bintools = pkgs.binutils.bintools;\n  src = ./hello-2.12.1.tar.gz;\n  system = builtins.currentSystem;\n}\n```\n\n- As you can see, this isn't the only required file but is a recipe outlining\n  how to build the `hello` package. The `tar.gz` package can be found\n  [here](https://ftp.gnu.org/gnu/hello/hello-2.12.1.tar.gz) You would just place\n  the tarball in the same directory as the derivation along with the following\n  `hello_builder.sh`:\n\n```bash\n# hello_builder.sh\nexport PATH=\"$gnutar/bin:$gcc/bin:$gnumake/bin:$coreutils/bin:$gawk/bin:$gzip/bin:$gnugrep/bin:$gnused/bin:$bintools/bin\"\ntar -xzf $src\ncd hello-2.12.1\n./configure --prefix=$out\nmake\nmake install\n```\n\nAnd build it with:\n\n```bash\nnix-build hello.nix\n```\n\nFinally execute it with:\n\n```bash\n./result/bin/hello\nHello, world!\n```\n\n## Simple Rust Derivation\n\nCreate a `simple.rs` with the following contents:\n\n```rust\nfn main() {\n  println!(\"Simple Rust!\")\n}\n```\n\nAnd a `rust_builder.sh` like this (this is our builder script):\n\n```bash\n# rust_builder.sh\n# Set up the PATH to include rustc coreutils and gcc\nexport PATH=\"$rustc/bin:$coreutils/bin:$gcc/bin\"\n\n# IMPORTANT: Create the $out directory BEFORE rustc tries to write to it\nmkdir -p \"$out\"\n\n# Compile the Rust source code and place the executable inside $out\nrustc -o \"$out/simple_rust\" \"$src\"\n```\n\nNow we'll enter the `nix repl` and build it:\n\n```bash\n❯ nix repl\nNix 2.28.3\nType :? for help.\n\nnix-repl> :l <nixpkgs>\nadded 3950 variables.\n\n# Define the variables for rustc, coreutils, bash, AND gcc from the loaded nixpkgs\nnix-repl> rustc = pkgs.rustc\n\nnix-repl> coreutils = pkgs.coreutils\n\nnix-repl> bash = pkgs.bash\n\nnix-repl> gcc = pkgs.gcc\n\n# Now define the derivation\nnix-repl> simple_rust_program = derivation {\n            name = \"simple-rust-program\";\n            builder = \"${bash}/bin/bash\";\n            args = [ ./rust_builder.sh ];\n            rustc = rustc;\n            coreutils = coreutils;\n            gcc = gcc;\n            src = ./simple.rs;\n            system = builtins.currentSystem;\n          }\n\nnix-repl> :b simple_rust_program\nThis derivation produced the following outputs:\nout -> /nix/store/fmyqr2d3ph0lpnxd0xppwvwyhv3iyb7y-simple-rust-program\n```\n\n```bash\nnix-store -r /nix/store/fmyqr2d3ph0lpnxd0xppwvwyhv3iyb7y-simple-rust-program\n\nwarning: you did not specify '--add-root'; the result might be removed by the garbage collector\n/nix/store/fmyqr2d3ph0lpnxd0xppwvwyhv3iyb7y-simple-rust-program\n```\n\nThis simple Rust example, built with a direct derivation call, illustrates:\n\n- How Nix explicitly manages every single tool in your build environment\n  (`bash`, `rustc`, `gcc`, `coreutils`).\n\n- The strict isolation of Nix builds, where nothing is implicitly available.\n\n- The deterministic mapping of inputs to unique output paths in the Nix store.\n\n- The above example shows the fundamental structure of a Nix derivation, how\n  it's defined within the `nix-repl`.\n\n- `.drv` files are intermediate files that describe how to build a derivation;\n  it's the bare minimum information.\n\n## When Derivations are Built\n\nNix doesn't build derivations during the evaluation of your Nix expressions.\nInstead, it processes your code in two main phases (and why you need to use\n`:b simple_rust_program` or `nix-store -r` to actually build or realize it):\n\n1.  Evaluation/Instantiate Phase: This is when Nix parses and interprets your\n    .nix expression. The result is a precise derivation description (often\n    represented as a .drv file on disk), and the unique \"out paths\" where the\n    final built products will go are calculated. No actual code is compiled or\n    executed yet. Achieved with `nix-instantiate`\n\n2.  Realize/Build Phase: Only after a derivation has been fully described does\n    Nix actually execute its build instructions. It first ensures all the\n    derivation's inputs (dependencies) are built, then runs the builder script\n    in an isolated environment, and places the resulting products into their\n    designated \"out paths\" in the Nix store. Achieved with `nix-store -r`\n\n## Referring to other derivations\n\nThe way that we can refer to other packages/derivations is to use the `outPath`.\n\nThe `outPath` describes the location of the files of that derivation. Nix can\nthen convert the derivation set into a string:\n\n```bash\nnix repl\nnix-repl> :l <nixpkgs>\nnix-repl> fzf\n«derivation /nix/store/vw1zag9q4xvf10z24j1qybji7wfsz78v-fzf-0.62.0.drv»\nnix-repl> fzf.outPath\n\"/nix/store/z3ayhjslz72ldiwrv3mn5n7rs96p2g8a-fzf-0.62.0\"\nnix-repl> builtins.toString fzf\n\"/nix/store/z3ayhjslz72ldiwrv3mn5n7rs96p2g8a-fzf-0.62.0\"\n```\n\n- As long as there is an `outPath` attribute, Nix will do the \"set to string\n  conversion\".\n\n## Produce a development shell from a derivation\n\nBuilding on the concept of a derivation as a recipe, let's create our first\npractical derivation. This example shows how to define a temporary development\nenvironment (a shell) using stdenv.mkDerivation, which is the primary function\nfor defining packages in Nix.\n\n```nix\n# my-shell.nix\n# We use a `let` expression to bring `pkgs` and `stdenv` into scope.\n# This is a recommended practice over `with import <nixpkgs> {}`\n# for clarity and to avoid potential name collisions.\nlet\n  pkgs = import <nixpkgs> {};\n  stdenv = pkgs.stdenv; # Access stdenv from the imported nixpkgs\nin\n\n# Make a new \"derivation\" that represents our shell\nstdenv.mkDerivation {\n  name = \"my-environment\";\n\n  # The packages in the `buildInputs` list will be added to the PATH in our shell\n  buildInputs = [\n    # cowsay is an arbitrary package\n    # see https://nixos.org/nixos/packages.html to search for more\n    pkgs.cowsay\n    pkgs.fortune\n  ];\n}\n```\n\n**Usage**\n\n```bash\nnix-shell my-shell.nix\nfortune | cowsay\n _________________________________________\n/ \"Lines that are parallel meet at        \\\n| Infinity!\" Euclid repeatedly, heatedly, |\n| urged.                                  |\n|                                         |\n| Until he died, and so reached that      |\n| vicinity: in it he found that the       |\n| damned things diverged.                 |\n|                                         |\n\\ -- Piet Hein                            /\n -----------------------------------------\n        \\   ^__^\n         \\  (oo)\\_______\n            (__)\\       )\\/\\\n                ||----w |\n                ||     ||\n```\n\n- To exit type: `exit`\n\nThis Nix expression defines a temporary development shell. Let's break it down:\n\n- `pkgs = import <nixpkgs> {};`: Standard way to get access to all the packages\n  and helper functions (i.e. `nixpkgs.lib`)\n\n- `stdenv = pkgs.stdenv;`: `stdenv` provides us `mkDerivation` and is from the\n  `nixpkgs` collection.\n\n- `stdenv.mkDerivation { ... };`: This is the core function for creating\n  packages.\n  - `stdenv` provides a set of common build tools and conventions.\n\n- `mkDerivation` takes an attribute set (a collection of key-value pairs) as its\n  argument.\n\n- `name = \"my-environment\";`: This gives your derivation a human-readable name.\n\n- `buildInputs = [ pkgs.cowsay ];`: This is a list of dependencies that will be\n  available in the build environment of this derivation (or in the `PATH` if you\n  enter the shell created by this derivation). `pkgs.cowsay` refers to the\n  `cowsay` package from the imported `pkgs` collection.\n\nThe command `nix-instantiate --eval my-shell.nix` evaluates the Nix expression\nin the file. It does not build the derivation. Instead, it returns the Nix value\nthat the expression evaluates to.\n\n```bash\nnix-instantiate --eval my-shell.nix\n```\n\nThis value is a structured data type that encapsulates all the attributes (like\n`name`, `system`, `buildInputs`, etc.) required to build the derivation. Your\noutput shows this detailed internal representation of the derivation's \"recipe\"\nas understood by Nix. This is useful for debugging and inspecting the\nderivation's definition.\n\n## Our Second Derivation: Understanding the Builder\n\n<details>\n<summary> Understanding the Builder (Click to Expand) </summary>\n\n- To understand how derivations work, let's create a very basic example using a\n  bash script as our `builder`.\n\n### Why a Builder Script?\n\n- The `builder` attribute in a derivation tells Nix _how_ to perform the build\n  steps. A simple and common way to define these steps is with a bash script.\n\n### The Challenge with Shebangs in Nix\n\n- In typical Unix-like systems, you might start a bash script with a shebang\n  (`#!/bin/bash` or `#!/usr/bin/env bash`) to tell the system how to execute it.\n  However, in Nix derivations, we generally avoid this.\n\n- **Reason:** Nix builds happen in an isolated environment where the exact path\n  to common tools like `bash` isn't known beforehand (it resides within the Nix\n  store). Hardcoding a path or relying on the system's `PATH` would break Nix's\n  stateless property.\n\n### The Importance of Statelessness in Nix\n\n- **Stateful Systems (Traditional):** When you install software traditionally,\n  it often modifies the core system environment directly. This can lead to\n  dependency conflicts and makes rollbacks difficult.\n\n- **Stateless Systems (Nix):** Nix takes a different approach. When installing a\n  package, it creates a unique, immutable directory in the Nix store. This\n  means:\n  - **No Conflicts:** Different versions of the same package can coexist without\n    interfering with each other.\n\n  - **Reliable Rollback:** You can easily switch back to previous versions\n    without affecting system-wide files.\n\n  - **Reproducibility:** Builds are more likely to produce the same result\n    across different machines if they are \"pure\" (don't rely on external system\n    state).\n\n### The Isolated Nix Build Environment: A Quick Overview\n\nWhen Nix executes a builder script, it sets up a highly controlled and pristine\nenvironment to ensure **reproducibility** and **isolation**. Here's what\nhappens:\n\n1.  **Fresh Start:** Nix creates a temporary, empty directory for the build and\n    makes it the current working directory.\n\n2.  **Clean Environment:** It completely clears the environment variables from\n    your shell.\n\n3.  **Controlled Inputs:** Nix then populates the environment with _only_ the\n    variables essential for the build, such as:\n    - `$NIX_BUILD_TOP`: The path to the temporary build directory.\n\n    - `$PATH`: Carefully set to include only the explicit `buildInputs` you've\n      specified, preventing reliance on arbitrary system tools.\n\n    - `$HOME`: Set to `/homeless-shelter` to prevent programs from reading\n      user-specific configuration files.\n\n    - Variables for each declared output (`$out`, etc.), indicating where the\n      final results should be placed in the Nix store.\n\n4.  **Execution & Logging:** The builder script is run with its specified\n    arguments. All its output (stdout/stderr) is captured in a log.\n\n5.  **Clean Up & Registration:** If successful, the temporary directory is\n    removed. Nix then scans the build outputs for references to other store\n    paths, ensuring all dependencies are correctly tracked for future use and\n    garbage collection. Finally, it normalizes file permissions and timestamps\n    in the output for consistent hashing.\n\nThis meticulous setup ensures that your builds are independent of the machine\nthey run on and always produce the same result, given the same inputs.\n\n## Our builder Script\n\n- For our first derivation, we'll create a simple `builder.sh` file in the\n  current directory:\n\n```bash\n# builder.sh\ndeclare -xp\necho foo > $out\n```\n\n- The command `declare -xp` lists exported variables (it's a bash builtin\n  function).\n\n- Nix needs to know where the final built product (the \"cake\" in our earlier\n  analogy) should be placed. So, during the derivation process, Nix calculates a\n  unique output path within the Nix store. This path is then made available to\n  our builder script as an environment variable named `$out`. The `.drv` file,\n  which is the recipe, contains instructions for the builder, including setting\n  up this `$out` variable. Our builder script will then put the result of its\n  work (in this case, the \"foo\" file) into this specific `$out` directory.\n\n- As mentioned earlier we need to find the nix store path to the bash\n  executable, common way to do this is to load Nixpkgs into the repl and check:\n\n```bash\nnix-repl> :l <nixpkgs>\nAdded 3950 variables.\nnix-repl> \"${bash}\"\n\"/nix/store/ihmkc7z2wqk3bbipfnlh0yjrlfkkgnv6-bash-4.2-p45\"\n```\n\nSo, with this little trick we are able to refer to `bin/bash` and create our\nderivation:\n\n```bash\nnix-repl> d = derivation { name = \"foo\"; builder = \"${bash}/bin/bash\";\n args = [ ./builder.sh ]; system = builtins.currentSystem; }\nnix-repl> :b d\n[1 built, 0.0 MiB DL]\n\nthis derivation produced the following outputs:\n  out -> /nix/store/gczb4qrag22harvv693wwnflqy7lx5pb-foo\n```\n\n- The contents of the resulting store path (`/nix/store/...-foo`) now contain\n  the file `foo`, as intended. We have successfully built a derivation!\n\n- Derivations are the primitive that Nix uses to define packages. “Package” is a\n  loosely defined term, but a derivation is simply the result of calling\n  `builtins.derivation`.\n\n</details>\n\n## Our Last Derivation\n\nCreate a new directory and a `hello.nix` with the following contents:\n\n```nix\n# hello.nix\n{\n  stdenv,\n  fetchzip,\n}:\n\nstdenv.mkDerivation {\n  pname = \"hello\";\n  version = \"2.12.1\";\n\n  src = fetchzip {\n    url = \"https://ftp.gnu.org/gnu/hello/hello-2.12.1.tar.gz\";\n    sha256 = \"\";\n  };\n}\n```\n\nSave this file to `hello.nix` and run `nix-build` to observe the build failure:\n\n- Click to expand output:\n\n```nix\n$ nix-build hello.nix\n~error: cannot evaluate a function that has an argument without a value ('stdenv')\n~       Nix attempted to evaluate a function as a top level expression; in\n~       this case it must have its arguments supplied either by default\n~       values, or passed explicitly with '--arg' or '--argstr'. See\n~       https://nix.dev/manual/nix/stable/language/constructs.html#functions.\n~\n~       at /home/nix-user/hello.nix:3:3:\n~\n~            2| {\n~            3|   stdenv,\n~             |   ^\n~            4|   fetchzip,\n```\n\n**Problem**: The expression in `hello.nix` is a _function_, which only produces\nit's intended output if it is passed the correct _arguments_.(i.e. `stdenv` is\navailable from `nixpkgs` so we need to import `nixpkgs` before we can use\n`stdenv`):\n\nThe recommended way to do this is to create a `default.nix` file in the same\ndirectory as the `hello.nix` with the following contents:\n\n```nix\n# default.nix\nlet\n  nixpkgs = fetchTarball \"https://github.com/NixOS/nixpkgs/tarball/nixos-24.05\";\n  pkgs = import nixpkgs { config = {}; overlays = []; };\nin\n{\n  hello = pkgs.callPackage ./hello.nix { };\n}\n```\n\nThis allows you to run `nix-build -A hello` to realize the derivation in\n`hello.nix`, similar to the current convention used in Nixpkgs:\n\n- Click to expand Output:\n\n```nix\nnix-build -A hello\n~error: hash mismatch in fixed-output derivation '/nix/store/pd2kiyfa0c06giparlhd1k31bvllypbb-source.drv':\n~         specified: sha256-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\n~            got:    sha256-1kJjhtlsAkpNB7f6tZEs+dbKd8z7KoNHyDHEJ0tmhnc=\n~error: 1 dependencies of derivation '/nix/store/b4mjwlv73nmiqgkdabsdjc4zq9gnma1l-hello-2.12.1.drv' failed to build\n```\n\n- Another way to do this is with\n  [nix-prefetch-url](https://nix.dev/manual/nix/2.24/command-ref/nix-prefetch-url)\n  It is a utility to calculate the sha beforehand.\n\n```bash\nnix-prefetch-url https://ftp.gnu.org/gnu/hello/hello-2.12.1.tar.gz\npath is '/nix/store/pa10z4ngm0g83kx9mssrqzz30s84vq7k-hello-2.12.1.tar.gz'\n086vqwk2wl8zfs47sq2xpjc9k066ilmb8z6dn0q6ymwjzlm196cd\n```\n\n- When you use `nix-prefetch-url`, you get a Base32 hash when nix needs SRI\n  format.\n\nRun the following command to convert from Base32 to SRI:\n\n```bash\nnix hash to-sri --type sha256 086vqwk2wl8zfs47sq2xpjc9k066ilmb8z6dn0q6ymwjzlm196cd\nsha256-jZkUKv2SV28wsM18tCqNxoCZmLxdYH2Idh9RLibH2yA=\n```\n\n- This actually fetched a different sha than the Nix compiler returned in the\n  example where we replace the empty sha with the one Nix gives us. The\n  difference was that `fetchzip` automatically extracts archives before\n  computing the hash and slight differences in the metadata cause different\n  results. I had to switch from `fetchzip` to `fetchurl` to get the correct\n  results.\n  - Extracted archives can differ in timestamps, permissions, or compression\n    details, causing different hash values.\n\n  - A simple takeaway is to use `fetchurl` when you need an exact match, and\n    `fetchzip` when working with extracted contents.\n\n  - [fetchurl](https://nixos.org/manual/nixpkgs/stable/#fetchurl)\n\n  - `fetchurl` returns a `fixed-output derivation`(FOD): A derivation where a\n    cryptographic hash of the output is determined in advance using the\n    outputHash attribute, and where the builder executable has access to the\n    network.\n\nLastly replace the empty sha256 placeholder with the returned value from the\nlast command:\n\n```nix\n# hello.nix\n{\n  stdenv,\n  fetchzip,\n}:\n\nstdenv.mkDerivation {\n  pname = \"hello\";\n  version = \"2.12.1\";\n\n  src = fetchzip {\n    url = \"https://ftp.gnu.org/gnu/hello/hello-2.12.1.tar.gz\";\n    sha256 = \"sha256-1kJjhtlsAkpNB7f6tZEs+dbKd8z7KoNHyDHEJ0tmhnc=\";\n  };\n}\n```\n\nRun `nix-build -A hello` again and you'll see the derivation successfully\nbuilds.\n\n## Best Practices\n\n**Reproducible source paths**: If we built the following derivation in\n`/home/myuser/myproject` then the store path of `src` will be\n`/nix/store/<hash>-myproject` causing the build to no longer be reproducible:\n\n```nix\nlet pkgs = import <nixpkgs> {}; in\n\npkgs.stdenv.mkDerivation {\n  name = \"foo\";\n  src = ./.;\n}\n```\n\n> ❗ TIP: Use `builtins.path` with the `name` attribute set to something fixed.\n> This will derive the symbolic name of the store path from the `name` instead\n> of the working directory:\n>\n> ```nix\n> let pkgs = import <nixpkgs> {}; in\n>\n> pkgs.stdenv.mkDerivation {\n>   name = \"foo\";\n>   src = builtins.path { path = ./.; name = \"myproject\"; };\n> }\n> ```\n\n### Conclusion\n\nIn this chapter, we've laid the groundwork for understanding Nix derivations,\nthe fundamental recipes that define how software and other artifacts are built\nwithin the Nix ecosystem. We've explored their key components – inputs, builder,\nbuild phases, and outputs – and how they contribute to Nix's core principles of\nreproducibility and isolated environments. Derivations are the workhorses behind\nthe packages and tools we use daily in Nix.\n\nAs you've learned, derivations offer a powerful and principled approach to\nsoftware management. However, the way we organize and manage these derivations,\nalong with other Nix expressions and dependencies, has evolved over time.\nTraditionally, Nix projects often relied on patterns involving `default.nix`\nfiles, channel subscriptions, and manual dependency management.\n\nA more recent and increasingly popular approach to structuring Nix projects and\nmanaging dependencies is through Nix Flakes. Flakes introduce a standardized\nproject structure, explicit input tracking, and a more robust way to ensure\nreproducible builds across different environments.\n\nIn our next chapter,\n[Comparing Flakes and Traditional Nix](https://saylesss88.github.io/Comparing_Flakes_and_Traditional_Nix_8.html),\nwe will directly compare and contrast these two approaches. We'll examine the\nstrengths and weaknesses of traditional Nix practices in contrast to the\nbenefits and features offered by Nix Flakes. This comparison will help you\nunderstand the motivations behind Flakes and when you might choose one approach\nover the other for your Nix projects.\n\nAs you can see below, there is a ton of information on derivations freely\navailable.\n\n#### Links To Articles about Derivations\n\n<details>\n<summary> Click To Expand Resources </summary>\n\n- [NixPillsOurFirstDerivation](https://nixos.org/guides/nix-pills/06-our-first-derivation)\n\n- [NixPills-WorkingDerivation](https://nixos.org/guides/nix-pills/07-working-derivation)\n\n- [nix.dev-Derivations](https://nix.dev/manual/nix/2.24/language/derivations)\n\n- [nix.dev-packagingExistingSoftware](https://nix.dev/tutorials/packaging-existing-software)\n\n- [howToLearnNix-MyFirstDerivation](https://ianthehenry.com/posts/how-to-learn-nix/my-first-derivation/)\n\n- [howToLearnNix-DerivationsInDetail](https://ianthehenry.com/posts/how-to-learn-nix/derivations-in-detail/)\n\n- [Sparky/blog-creatingASuperSimpleDerivation](https://www.sam.today/blog/creating-a-super-simple-derivation-learning-nix-pt-3) #\n  How to learn Nix\n\n- [Sparky/blog-Derivations102](https://www.sam.today/blog/derivations-102-learning-nix-pt-4)\n\n- [ScriveNixWorkshop-nixDerivationBasics](https://scrive.github.io/nix-workshop/04-derivations/01-derivation-basics.html)\n\n- [zeroToNix-Derivations](https://zero-to-nix.com/concepts/derivations/)\n\n- [Tweag-derivationOutputs](https://www.tweag.io/blog/2021-02-17-derivation-outputs-and-output-paths/)\n\n- [theNixLectures-Derivations](https://ayats.org/blog/nix-tuto-2)\n\n- [bmcgee-whatAreFixed-OutputDerivations](https://bmcgee.ie/posts/2023/02/nix-what-are-fixed-output-derivations-and-why-use-them/)\n\n</details>\n","number":[9],"sub_items":[{"Chapter":{"name":"Builders and Autotools","content":"# Builders and Autotools\n","number":[9,1],"sub_items":[],"path":"drv/builders_and_autotools.md","source_path":"drv/builders_and_autotools.md","parent_names":["Intro to Nix Derivations"]}}],"path":"Intro_to_Nix_Derivations_7.md","source_path":"Intro_to_Nix_Derivations_7.md","parent_names":[]}},{"Chapter":{"name":"Comparing Flakes and Traditional Nix","content":"# Chapter 8\n\n<details>\n<summary> ✔️ Click to Expand Table of Contents</summary>\n\n<!-- toc -->\n\n</details>\n\n<!-- ![nixWinter](images/nixWinter.png) -->\n\n## Comparing Flakes and Traditional Nix\n\n- This post is based on notes from Nix-Hour #4, comparing Traditional Nix and\n  Flakes, focusing on achieving pure build results. See the\n  [YouTube video](https://www.youtube.com/watch?v=atmoYyBAhF4) for the original\n  content. This guide adapts the information for clarity and ease of\n  understanding.\n\n<details>\n<summary> What is Purity in Nix? (click here) </summary>\n\n- A key benefit of Nix Flakes is their _default_ enforcement of **pure\n  evaluation**.\n\n- In Nix, an **impure operation** depends on something _outside_ its explicit\n  inputs. Examples include:\n  - User's system configuration\n  - Environment variables\n  - Current time\n\n- Impurity leads to unpredictable builds that may differ across systems or time.\n\n</details>\n\n## Building a Simple \"hello\" Package: Flakes vs. Traditional Nix\n\n- We'll demonstrate building a basic \"hello\" package using both Flakes and\n  Traditional Nix to highlight the differences in handling purity.\n\n## Using Nix Flakes\n\n<details>\n<summary> Building Hello with Flakes (click here) </summary>\n\n1.  **Setup:**\n\n    ```bash\n    mkdir hello && cd hello/\n    ```\n\n2.  **Create `flake.nix` (Initial Impure Example):**\n\n    ```nix\n    # flake.nix\n    {\n      outputs = { self, nixpkgs }: {\n        myHello = (import nixpkgs {}).hello;\n      };\n    }\n    ```\n\n    - Note: Flakes don't have access to `builtins.currentSystem` directly.\n\n3.  **Impure Build (Fails):**\n\n    ```bash\n    nix build .#myHello\n    ```\n\n    - This fails because Flakes enforce purity by default.\n\n4.  **Force Impure Build:**\n\n    ```bash\n    nix build .#myHello --impure\n    ```\n\n5.  **Making the Flake Pure:**\n\n    ```nix\n    # flake.nix\n    {\n      inputs = {\n        nixpkgs.url = \"github:NixOS/nixpkgs\";\n        flake-utils.url = \"github:numtide/flake-utils\";\n      };\n\n      outputs = { self, nixpkgs, flake-utils }:\n        flake-utils.lib.eachDefaultSystem (system:\n          let\n            pkgs = nixpkgs.legacyPackages.${system};\n          in {\n            packages.myHello = pkgs.hello;\n          }\n        );\n    }\n    ```\n\n    - `flake-utils` simplifies making flakes system-agnostic and provides the\n      `system` attribute.\n\n6.  **Pure Build (Success):**\n    ```bash\n    nix build .#myHello\n    ```\n\n  </details>\n\n## Using Traditional Nix\n\n<details>\n<summary> Building hello with Traditional Nix </summary>\n\n1.  **Setup:**\n\n    ```bash\n    mkdir hello2 && cd hello2/\n    ```\n\n2.  **Create `default.nix` (Initial Impure Example):**\n\n    ```nix\n    # default.nix\n    { myHello = (import <nixpkgs> { }).hello; }\n    ```\n\n3.  **Build (Impure):**\n\n    ```bash\n    nix-build -A myHello\n    ```\n\n4.  **Impurity Explained:**\n\n    ```bash\n    nix repl\n    nix-repl> <nixpkgs>\n    /nix/var/nix/profiles/per-user/root/channels/nixos\n    ```\n\n    - `<nixpkgs>` depends on the user's environment (Nixpkgs channel), making it\n      impure. Even with channels disabled, it relies on a specific Nixpkgs\n      version in the store.\n\n5.  **Achieving Purity: Using `fetchTarball`**\n    - GitHub allows downloading repository snapshots at specific commits,\n      crucial for reproducibility.\n\n    - **Get Nixpkgs Revision from `flake.lock` (from the Flake example):**\n\n    ```nix\n    # flake.lock\n    \"nixpkgs\": {\n      \"locked\": {\n        \"lastModified\": 1746372124,\n        \"narHash\": \"sha256-n7W8Y6bL7mgHYW1vkXKi9zi/sV4UZqcBovICQu0rdNU=\",\n        \"owner\": \"NixOS\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"f5cbfa4dbbe026c155cf5a9204f3e9121d3a5fe0\",\n        \"type\": \"github\"\n      },\n    ```\n\n6.  **Modify `default.nix` for Purity:**\n\n    ```nix\n    # default.nix\n    let\n      nixpkgs = fetchTarball {\n        url = \"[https://github.com/NixOS/nixpkgs/archive/f5cbfa4dbbe026c155cf5a9204f3e9121d3a5fe0.tar.gz](https://github.com/NixOS/nixpkgs/archive/f5cbfa4dbbe026c155cf5a9204f3e9121d3a5fe0.tar.gz)\";\n        sha256 = \"0000000000000000000000000000000000000000000000000000\"; # Placeholder\n      };\n    in {\n      myHello = (import nixpkgs {}).hello;\n    }\n    ```\n\n    - Replace `<nixpkgs>` with `fetchTarball` and a specific revision. A\n      placeholder `sha256` is used initially.\n\n7.  **Build (Nix provides the correct `sha256`):**\n\n    ```bash\n    nix-build -A myHello\n    ```\n\n8.  **Verification:** Both Flake and Traditional Nix builds now produce the same\n    output path.\n\n9.  **Remaining Impurities in Traditional Nix:**\n    - Default arguments to `import <nixpkgs> {}` can introduce impurity:\n      - `overlays`: `~/.config/nixpkgs/overlays` (user-specific)\n      - `config`: `~/.config/nixpkgs/config.nix` (user-specific)\n      - `system`: `builtins.currentSystem` (machine-specific)\n\n10. **Making Traditional Nix Fully Pure:**\n\n    ```nix\n    # default.nix\n    {system ? builtins.currentSystem}:\n    let\n      nixpkgs = fetchTarball {\n        url =\n          \"[https://github.com/NixOS/nixpkgs/archive/0243fb86a6f43e506b24b4c0533bd0b0de211c19.tar.gz](https://github.com/NixOS/nixpkgs/archive/0243fb86a6f43e506b24b4c0533bd0b0de211c19.tar.gz)\";\n        sha256 = \"1qvdbvdza7hsqhra0yg7xs252pr1q70nyrsdj6570qv66vq0fjnh\";\n      };\n    in {\n      myHello = (import nixpkgs {\n        overlays = [];\n        config = {};\n        inherit system;\n      }).hello;\n    }\n    ```\n\n    - Override impure defaults for `overlays`, `config`, and make `system` an\n      argument.\n\n11. **Building with a Specific System:**\n\n    ```bash\n    nix-build -A myHello --argstr system x86_64-linux\n    ```\n\n12. **Pure Evaluation Mode in Traditional Nix:**\n\n    ```bash\n    nix-instantiate --eval --pure-eval --expr 'fetchGit { url = ./.; rev = \"b4fe677e255c6f89c9a6fdd3ddd9319b0982b1ad\"; }'\n    ```\n\n    - Example of using `--pure-eval`.\n\n    ```bash\n    nix-build --pure-eval --expr '(import (fetchGit { url = ./.; rev = \"b4fe677e255c6f89c9a6fdd3ddd9319b0982b1ad\"; }) { system = \"x86_64-linux\"; }).myHello'\n    ```\n\n    - Building with a specific revision and system.\n\n  </details>\n\n### Updating Nixpkgs\n\n<details>\n<summary> Updating Nixpkgs with Flakes </summary>\n\n```bash\nnix flake update\n```\n\n```nix\nnix build .#myHello --override-input nixpkgs github:NixOS/nixpkgs/nixos-24.11\n```\n\n</details>\n\n### Updating Traditional Nix (using `niv`)\n\n<details>\n<summary> Updating with niv </summary>\n\n```nix\nnix-shell -p niv\nniv init\n```\n\n```nix\n# default.nix\n{ system ? builtins.currentSystem,\n  sources ? import nix/sources.nix,\n  nixpkgs ? sources.nixpkgs,\n  pkgs ? import nixpkgs {\n    overlays = [ ];\n    config = { };\n    inherit system;\n  }, }: {\n  myHello = pkgs.hello;\n}\n```\n\nAnd build it with:\n\n```bash\nnix-build -A myHello\n```\n\n```bash\nniv update nixpkgs --branch=nixos-unstable\nnix-build -A myHello\n```\n\n</details>\n\n<details>\n<summary> Adding Home-Manager with Flakes (click here) </summary>\n\n```nix\n# flake.nix\n{\n  inputs = {\n    nixpkgs.url = \"github:NixOS/nixpkgs\";\n    flake-utils.url = \"github:numtide/flake-utils\";\n    home-manager.url = \"github:nix-community/home-manager\";\n  };\n\n  outputs = { self, nixpkgs, flake-utils, home-manager, ... }:\n    flake-utils.lib.eachDefaultSystem (system:\n      let pkgs = nixpkgs.legacyPackages.${system};\n      in {\n        packages.myHello = pkgs.hello;\n        packages.x86_64-linux.homeManagerDocs =\n          home-manager.packages.x86_64-linux.docs-html;\n      });\n}\n```\n\n```bash\nnix flake update\nnix flake show github:nix-community/home-manager\n```\n\n```nix\nhome-manager.inputs.follows = \"nixpkgs\";\n```\n\n</details>\n\n#### Adding Home-Manager with Traditional Nix\n\n<details>\n<summary> Adding Home-Manager with Traditional Nix (click here) </summary>\n```nix\nniv add nix-community/home-manager\n```\n\n```nix\nnix repl\nnix-repl> s = import ./nix/sources.nix\nnix-repl> s.home-manager\n```\n\n```nix\n{ system ? builtins.currentSystem, sources ? import nix/sources.nix\n  , nixpkgs ? sources.nixpkgs, pkgs ? import nixpkgs {\n    overlays = [ ];\n    config = { };\n    inherit system;\n  }, }: {\n  homeManagerDocs = (import sources.home-manager { pkgs = pkgs; }).docs;\n\n  myHello = pkgs.hello;\n}\n```\n\n```bash\nnix-build -A homeManagerDocs\n```\n\n</details>\n\n#### Conclusion\n\nIn this chapter, we've explored the key differences between traditional Nix and\nNix Flakes, particularly focusing on how each approach handles purity,\ndependency management, and project structure. We've seen that while traditional\nNix can achieve purity with careful configuration, Flakes enforce it by default,\noffering a more robust and standardized way to build reproducible environments.\nFlakes also streamline dependency management and provide a more structured\nproject layout compared to the often ad-hoc nature of traditional Nix projects.\n\nHowever, regardless of whether you're working with Flakes or traditional Nix,\nunderstanding how to debug and trace issues within your Nix code is crucial.\nWhen things go wrong, you'll need tools and techniques to inspect the evaluation\nprocess, identify the source of errors, and understand how your modules and\nderivations are being constructed.\n\nIn our next chapter,\n[Debugging and Tracing Modules](https://saylesss88.github.io/Debugging_and_Tracing_NixOS_Modules_9.html),\nwe will delve into the world of Nix debugging. We'll explore various techniques\nand tools that can help you understand the evaluation process, inspect the\nvalues of expressions, and trace the execution of your Nix code, enabling you to\neffectively troubleshoot and resolve issues in both Flake-based and traditional\nNix projects.\n","number":[10],"sub_items":[],"path":"Comparing_Flakes_and_Traditional_Nix_8.md","source_path":"Comparing_Flakes_and_Traditional_Nix_8.md","parent_names":[]}},{"Chapter":{"name":"Debugging and Tracing NixOS Modules","content":"# Chapter 9\n\n<details>\n<summary> ✔️ Click to Expand Table of Contents</summary>\n\n<!-- toc -->\n\n</details>\n\n## Debugging and Tracing NixOS Modules\n\n![404](images/coding4.png)\n\n<!-- ![gruv17](images/gruv17.png) -->\n\n- Other related post if you haven't read my previous post on modules, that may\n  be helpful before reading this one:\n  - [nix-modules-explained](https://saylesss88.github.io/posts/nix_modules_explained/)\n\n  - This post is my notes following Nix Hour 40. If it seems a little chaotic,\n    try watching one. They are hard to follow if you're not extremely familiar\n    with the concepts.\n\n  - [Nix Hour 40](https://www.youtube.com/watch?v=aLy8id4wr-M&t=2120s)\n\nNix Code is particularly hard to **debug** because of (e.g. lazy evaluation,\ndeclarative nature, layered modules)\n\n- The following simple Nix code snippet illustrates a basic NixOS module\n  definition and how options are declared and configured. We'll use this example\n  to demonstrate fundamental debugging techniques using `nix-instantiate`.\n\n```nix\nlet\n  lib = import <nixpkgs/lib>;\nin\nlib.evalModules {\n  modules = [\n    ({ lib, ... }: {\n      options.foo = lib.mkOption {\n        # type = lib.types.raw;\n        type = lib.types.anything;\n        # default = pkgs;\n      };\n      config.foo = {\n        bar = 10;\n        list = [1 2 3 ];\n        baz = lib.mkDefault \"baz\";\n      };\n    })\n    {\n      foo.baz = \"bar\";\n    }\n  ];\n}\n```\n\n- In the above code, adding `lib` to the function arguments isn't required but\n  if you were to move the module to another file it would fail without it\n  because `lib` comes from outside of it. So it's good practice to refer to\n  `lib` in the modules themselves.\n\n- You should **always** assign a type to your options, if you don't know which\n  type to use you could use `raw`. `raw` is a type that doesn't do any\n  processing. So if you were to assign the entire packages set to the option\n  e.g. `default = pkgs;` it wouldn't recurseinto all the packages and try to\n  evaluate them. There is also `anything`, that is useful if you do want to\n  recurse into the values.\n\n- The following is an example of how you would run this inside vim/neovim, the\n  rest of the examples will be from the command line:\n\n```vim\n:!nix-instantiate --eval -A config.foo --strict\n```\n\n**Output**:\n\n<details>\n<summary> Click to Expand the Output </summary>\n\n```bash\n{ bar = 10; baz = \"bar\"; list = [ 1 2 3 ]; }\n```\n\nTo show the difference you could uncomment the `raw` type and comment the\n`anything` type and run the above command again you'll see that you get an\nerror:\n\n```bash\nerror: The option 'foo' is defined multiple times while it's expected to be\nunique\n```\n\nTo execute this command on the command line:\n\n```bash\nnix-instantiate --eval --strict -A config.foo\n```\n\nIt will show you the start of a trace. To get the full trace add:\n\n```bash\nnix-instantiate --eval --strict -A config.foo --show-trace\n```\n\n</details>\n\n## Example 2\n\n<details>\n<summary> Click to Expand Example 2 </summary>\n\nIn the previous example, we looked at a simplified module. Now, let's examine a\nmore realistic scenario involving a basic NixOS configuration file\n(`configuration.nix`).\n\nThis example will demonstrate how to use `nix-instantiate` to evaluate an entire\nsystem configuration and how `--show-trace` helps in diagnosing errors within\nthis context.\n\nConsider the following `configuration.nix` file:\n\n```nix\n# configuration.nix\n{ lib, ... }: {\n  boot.loader.grub.device = \"nodev\";\n  fileSystems.\"/\".device = \"/devst\";\n  system.stateVersion = \"24.11\";\n}\n```\n\n- This configuration snippet sets the GRUB bootloader device, defines a root\n  filesystem, and specifies the expected NixOS state version. To evaluate this\n  entire system configuration, you can use `nix-instantiate` and point it to the\n  `<nixpkgs/nixos>` entrypoint, providing our `configuration.nix` file as an\n  argument. The `-A system` flag selects the top-level `system` attribute, which\n  represents the instantiated system configuration.\n\n**Run** it in with:\n\n```bash\nnix-instantiate '<nixpkgs/nixos>' --arg configuration ./configuration.nix -A system\n```\n\n**Output**:\n\n```bash\n/nix/store/kfcwvvpdbsb3xcks1s76id16i1mc3l5k-nixos-system-nixos-25.05pre-git.drv\n```\n\nOk, we can see that this successfully _instantiates_. Let's introduce an error\nto trace:\n\n```nix\n{ lib, ... }: {\n  boot.loader.grub.device = \"nodev\";\n  fileSystems.\"/\".device = \"/devst\";\n  system.stateVersion = builtins.genList \"24.11\" null;\n}\n```\n\n**Output**:\n\n```bash\n(stack trace truncated; use '--show-trace' to show the full, detailed trace)\nerror: expected an integer but found null: null\n```\n\nRerun the command with `--show-trace` appended:\n\nOr on the command line\n\n```bash\nnix-instantiate '<nixpkgs/nixos>' --arg configuration ./configuration.nix -A system --show-trace\n```\n\n- This outputs a much longer trace than the first example. It shows you the file\n  the error occured in and you can see that in this case they are a lot of\n  internal functions. (e.g.\n  `at /nix/store/ccfwxygjrarahgfv5865x2f828sjr5h0- source/lib/attrsets.nix:1529:14:`)\n\nTo show your own error message you could do something like this:\n\n```nix\n{lib, ...}: {\n  boot.loader.grub.device = \"nodev\";\n  fileSystems.\"/\".device = \"/devst\";\n  system.stateVersion = builtins.addErrorContext \"AAAAAAAAAAAAAAAAA\" (builtins.genList \"24.11\" null);\n}\n```\n\nRun it:\n\n```bash\nnix-instantiate '<nixpkgs/nixos>' --arg configuration ./configuration.nix -A system --show-trace`\n```\n\n**Output**:\n\n```bash\n … while evaluating the attribute 'value'\n     at /nix/store/ccfwxygjrarahgfv5865x2f828sjr5h0-source/lib/modules.nix:770:21:\n      769|             inherit (module) file;\n      770|             inherit value;\n         |                     ^\n      771|           }) module.config\n\n   … AAAAAAAAAAAAAAAAA\n\n   … while calling the 'genList' builtin\n     at /home/jr/tests/configuration.nix:4:71:\n        3|   fileSystems.\"/\".device = \"/devst\";\n        4|   system.stateVersion = builtins.addErrorContext \"AAAAAAAAAAAAAAAAA\"\n         (builtins.genList \"24.11\" null);\n         |                                                                       ^\n        5| }\n\n   … while evaluating the second argument passed to builtins.genList\n\n   error: expected an integer but found null: null\n```\n\n- In the latest nix they actually inverted the error messages so the most\n  relevant parts will be at the bottom.\n\n</details>\n\n## Example 3\n\n<details>\n<summary> Click to Expand Example 3 </summary>\n\nLet's consider another example, this time demonstrating the definition of\nconfiguration options using `lib.mkOption` within a module structure.\n\n```nix\n# default.nix\nlet\n  lib = import <nixpkgs/lib>;\nin\nlib.evalModules {\n  modules = [\n    ({ lib, ... }: {\n      options.ints = lib.mkOption {\n        type = lib.types.attrsOf lib.types.int;\n      };\n      options.strings = lib.mkOption {\n        type = lib.types.string;\n        # type = lib.types.attrsOf lib.types.string;\n        default = \"foo\";\n      };\n    })\n  ];\n}\n```\n\n**Instantiate** this with:\n\n```bash\nnix-instantiate --eval --strict -A config.strings\n```\n\n**Output**:\n\n```bash\nevaluation warning: The type `types.string` is deprecated.\nSee https://github.com/NixOS/nixpkgs/pull/66346 for better alternative types.\n\"foo\"\n```\n\n- Unfortunately you won't get the same depreciation warning from `lib.attrsOf`\n\nBelow is an interesting way to provide nixpkgs run it on the command line:\n\n```bash\nexport NIX_PATH=nixpkgs=channel:nixpkgs-unstable\necho $NIX_PATH\n```\n\n**Output**:\n\n```bash\nnixpkgs=channel:nixpkgs-unstable\n```\n\nThe next two commands are to check that after using the above way to provide\n`nixpkgs-unstable` that they both point to the same store path, the following\ncommand will fetch nixpkgs from the channel above:\n\n```bash\nnix-instantiate --find-file nixpkgs\n```\n\n**Output** 1️⃣\n\n```bash\n/nix/store/ydrgwsibghsyx884qz97zbs1xs93yk11-source\n```\n\n```bash\nnix-instantiate --eval channel:nixpkgs-unstable -A path\n```\n\n**Output**: 2️⃣\n\n```bash\n/nix/store/ydrgwsibghsyx884qz97zbs1xs93yk11-source\n```\n\n- As you can see both commands produce the same store path\n\n## Example 4\n\nIn our previous example, we encountered a deprecation warning for\n`lib.types.string`. This next example delves deeper into why that type was\ndeprecated and demonstrates the consequences of its behavior, along with the\nrecommended fix.\n\n```nix\n# default.nix\nlet\n  lib = import <nixpkgs/lib>;\nin\n  lib.evalModules {\n    modules = [\n      ({lib, ...}: {\n        options.ints = lib.mkOption {\n          type = lib.types.attrsOf lib.types.int;\n        };\n        options.strings = lib.mkOption {\n          # type = lib.types.string;\n          type = lib.types.attrsOf lib.types.string;\n          default = {\n            x = \"foo\";\n          };\n        };\n        config = {\n          strings = lib.mkOptionDefault {\n            x = \"bar\";\n          };\n        };\n      })\n    ];\n  }\n```\n\nEvaluate it with:\n\n```bash\nnix-instantiate --eval --strict -A config.strings\n```\n\n- `types.string` depricated because it silently concatenates strings\n\n- The above command has two options with the same priority level and evaluates\n  to `{ x = \"foobar\"; }`\n\n**Output:**\n\n```bash\nevaluation warning: The type `types.string` is deprecated. See https://github.\ncom/NixOS/nixpkgs/pull/66346 for better alternative types.\n{ x = \"foobar\"; }\n```\n\n- `types.str` was the replacement for the depricated `types.string`:\n\n```nix\n# default.nix\nlet\n  lib = import <nixpkgs/lib>;\nin\n  lib.evalModules {\n    modules = [\n      ({lib, ...}: {\n        options.ints = lib.mkOption {\n          type = lib.types.attrsOf lib.types.int;\n        };\n        options.strings = lib.mkOption {\n          # type = lib.types.string;\n          type = lib.types.attrsOf lib.types.str;\n          # Sets the value with a lower priority: lib.mkOptionDefault\n          default = {\n            x = \"foo\";\n          };\n        };\n        config = {\n          strings = lib.mkOptionDefault {\n            x = \"bar\";\n          };\n        };\n      })\n    ];\n  }\n```\n\n**Output:**\n\n```bash\nerror:\n… while evaluating the attribute 'x'\n\n… while evaluating the attribute 'value'\n at /nix/store/ydrgwsibghsyx884qz97zbs1xs93yk11-source/lib/modules.nix:1148:41:\n 1147|\n 1148|     optionalValue = if isDefined then { value = mergedValue; } else { };\n     |                                         ^\n 1149|   };\n\n… while calling the 'foldl'' builtin\n at /nix/store/ydrgwsibghsyx884qz97zbs1xs93yk11-source/lib/options.nix:508:8:\n  507|     else\n  508|       (foldl' (\n     |        ^\n  509|         first: def:\n\n(stack trace truncated; use '--show-trace' to show the full, detailed trace)\n\nerror: The option `strings.x' has conflicting definition values:\n- In `<unknown-file>': \"foo\"\n- In `<unknown-file>': \"bar\"\nUse `lib.mkForce value` or `lib.mkDefault value` to change the priority on any of these definitions.\n\nshell returned 1\n```\n\n</details>\n\n## Summary\n\n- So types in the module system aren't just types in the conventional sense but\n  they also specify the emerging behavior of these values.\n\n- If we switch the type in the above example to `types.lines` you get this\n  returned, `{ x = \"foo\\nbar\"; }`\n\n- `mkOptionDefault` isn't typically something you should generally use, instead\n  options have a `default` setting\n\n- If you want to make sure that you set a default but if the user specifies it,\n  it shouldn't get overridden. You should not set it in the following:\n\n```nix\noptions.strings = lib.mkOption {\n  type = lib.types.attrsOf lib.types.lines;\n  default = {\n    x = \"foo\";\n  };\n}\n```\n\nBecause the above uses `mkOptionDefault` but instead in under the `config`\nattribute like the following:\n\n```nix\n# ...snip...\noptions.strings = lib.mkOption {\n  type = lib.types.attrsOf lib.types.lines;\n  # default = {\n    # x = \"foo\";\n  # };\n};\nconfig = {\n  strings = {\n    x = lib.mkDefault \"foo\";\n  };\n};\n# ...snip...\n```\n\n```nix\nlet\n  lib = import <nixpkgs/lib>;\nin\n  lib.evalModules {\n    modules = [\n      ({lib, ...}: {\n        options.ints = lib.mkOption {\n          type = lib.types.attrsOf lib.types.int;\n        };\n        options.strings = lib.mkOption {\n          # type = lib.types.string;\n          type = lib.types.attrsOf lib.types.str;\n          # Sets the value with a lower priority: lib.mkOptionDefault\n          #default = {\n          #  x = \"foo\";\n          #};\n        };\n        config.strings = {\n          x = \"foo\";\n        };\n      })\n      {\n        config.strings = {\n          y = \"bar\";\n        };\n      }\n    ];\n  }\n```\n\n**Output**:\n\n- This works now because there's no difference between `x` and `y`\n\n```bash\n{ x = \"foo\"; y = \"bar\"; }\n```\n\n## More Functionality between modules\n\n```nix\nlet\n  lib = import <nixpkgs/lib>;\nin\n  lib.evalModules {\n    modules = [\n      ({lib, ...}: {\n        options.ints = lib.mkOption {\n          type = lib.types.attrsOf lib.types.int;\n        };\n        options.strings = lib.mkOption {\n          # type = lib.types.string;\n          type = lib.types.attrsOf lib.types.str;\n          # Sets the value with a lower priority: lib.mkOptionDefault\n          #default = {\n          #  x = \"foo\";\n          #};\n        };\n        config.strings = {\n          x = lib.mkDefault \"foo\";\n        };\n      })\n      {\n        config.strings = {\n          x = \"x\";\n          y = \"bar\";\n        };\n      }\n    ];\n  }\n```\n\n- The above command would cause a conflict without the `x = lib.mkDefault foo`\n  And this is typically what you want to do for defaults and modules in things\n  like nested configuration.\n\n**Output:**\n\n```bash\n{ x = \"x\"; y = \"bar\"; }\n```\n\n### Infinite recursion error\n\n1. A common pitfall is to introduce a hard to debug error `infinite recursion`\n   when shadowing a name. The simplest example for this is:\n\n> ```nix\n> let a = 1; in rec { a = a; }\n> ```\n\n> 💡**TIP**: Avoid `rec`. Use `let ... in` Example:\n>\n> ```nix\n> let\n>  a = 1;\n> in {\n>  a = a;\n>  b = a + 2;\n> }\n> ```\n\n<details>\n<summary> Click to Expand a more involved infinite recursion error </summary>\n\nWe'll separate the logic for this example, this will be the `default.nix` this\nis where having `lib` defined in your inline modules is helpful because you can\njust delete the section and paste it into your `modules.nix`:\n\n```nix\n# default.nix\nlet\n  lib = import <nixpkgs/lib>;\nin\n  lib.evalModules {\n    modules = [\n      ./module.nix\n    ];\n  }\n```\n\nAnd in the `module.nix`:\n\n```nix\n# module.nix\n{ lib, pkgs, ...}: {\n  options.etc = lib.mkOption {\n    type = lib.types.attrsOf lib.types.path;\n    default = { };\n    description = ''\n      Specifies which paths are is /etc/\n    '';\n  };\n\n  config._module.args.pkgs = import <nixpkgs> {\n    config = {};\n    overlays = [];\n  };\n  config.etc.foo = pkgs.writeText \"foo\" ''\n    foo configuration\n  '';\n}\n```\n\n- If you evaluate this with the following you will get an infinite recursion\n  error.\n\n```bash\nnix-instantiate --eval --strict -A config.etc\n```\n\n- This happens because `--strict` evaluates the `etc`, then it goes into the\n  `attrsOf`, and the `path`\n\n```bash\nnix repl\nnix-repl> :l <nixpkgs>\nnix-repl> hello.out.out.out\n```\n\nIn this example:\n\n- `:l <nixpkgs>` loads the Nixpkgs library into the repl environment, making its\n  definitions available.\n\n- `hello` refers to the `hello` package definition within Nixpkgs. Packages in\n  Nixpkgs are defined as _derivations_.\n\n- `.out` is a common attribute name for the _main output_ of a derivation (e.g.,\n  the installed package). Some packages, especially those with complex build\n  processes or multiple outputs, might have nested output attributes. In the\n  case of `hello`, accessing `.out.out.out` ultimately leads us to the\n  _derivation_ itself.\n\nThe key takeaway here is that when you evaluate a package in the `nix repl`,\nyou're often interacting with its derivation or one of its output paths in the\nNix store. The `«derivation ...»` indicates that `hello.out.out.out` evaluates\nto a derivation – the blueprint for building the `hello` package. This is in\ncontrast to `--eval --strict`, which tries to fully evaluate values, potentially\nleading to infinite recursion if it encounters a derivation that refers back to\nitself indirectly during attribute evaluation.\n\n**Output:**\n\n```bash\n«derivation /nix/store/b1vcpm321dwbwx6wj4n13l35f4y2wrfv-hello-2.12.1.drv»\n```\n\n- So it recurses through the entire thing and tries to evaluate its string.\n\nSo we want to change the command from `--eval --strict` which is only based on\nevaluation to at least `nix-instantiate` which is based on derivations:\n\n```bash\nnix-instantiate -A config.etc\n```\n\n**Output:**\n\n```bash\nwarning: you did not specify '--add-root'; the result might be removed by the garbage collector\n/nix/store/abyfp1rxk73p0n5kfilv7pawxwvc7hsg-foo.drv\n```\n\n- We don't really have a derivation yet for example:\n\n```nix\n# module.nix\n{\n  lib,\n  pkgs,\n  ...\n}: {\n  options.etc = lib.mkOption {\n    type = lib.types.attrsOf (lib.types.attrsOf lib.types.path);\n    default = {};\n    description = ''\n      Specifies which paths are in /etc/\n    '';\n  };\n\n  config._module.args.pkgs = import <nixpkgs> {\n    config = {};\n    overlays = [];\n  };\n  config.etc.foo.bar = pkgs.writeText \"foo\" ''\n    foo configuration\n  '';\n}\n```\n\nTry to evaluate the above command with `nix-instantiate -A config.etc` and Nix\ndoesn't even try to build it. With nested `attrsOf`\n\n```bash\nnix repl -f default.nix\nnix-repl> config.etc\n{\n  foo = { ... };\n}\nnix-repl> config.etc.foo\n{\n  bar = «derivation /nix/store/abyfp1rxk73p0n5kfilv7pawxwvc7hsg-foo.drv»;\n}\n```\n\n- So `config.foo` is an attribute set and `config.etc.foo` is also an attribute\n  set but it's not a derivation by itself. So `nix-instantiate` does this one\n  level of recursion here and it would have built `foo` value if it were a\n  derivation.\n\n</details>\n\n### Example 5\n\n<details>\n<summary> Click to Expand Example 5 </summary>\n\nWe'll use the same `module.nix` and `default.nix` from the previous example.\n\nBuilding More Complex Configurations with Modules In this next example, we'll\nfocus on a common task in system configuration: managing files within the\n`/etc/` directory. We'll define a module that allows us to specify the content\nof arbitrary files in `/etc/` and then use a special Nix function to combine\nthese individual file definitions into a single, manageable entity.\n\nWe'll introduce a new option, `options.etc`, which will allow us to define the\ncontent of files within `/etc/`. Then, we'll use `pkgs.linkFarm` to create a\nderivation that represents the entire `/etc/` directory as a collection of\nsymbolic links pointing to the individual file contents we've defined. This\ndemonstrates how modules can abstract away the details of creating complex\nsystem configurations, providing a declarative and reproducible way to manage\neven fundamental aspects of the operating system.\n\nLet's show how we can use Nix modules to declaratively manage the `/etc/`\ndirectory\n\n```nix\n# default.nix\nlet\n  lib = import <nixpkgs/lib>;\nin\n  lib.evalModules {\n    modules = [\n      ./module.nix\n    ];\n  }\n\n```\n\n```nix\n# module.nix\n{\n  lib,\n  pkgs,\n  config,\n  ...\n}: {\n  options.etc = lib.mkOption {\n    type = lib.types.attrsOf (lib.types.attrsOf lib.types.path);\n    default = {};\n    description = ''\n      Specifies which paths are in /etc/\n    '';\n  };\n  options.etcCombined = lib.mkOption {\n    type = lib.types.package;\n    default =\n      pkgs.linkFarm \"etc\"\n      (lib.mapAttrsToList (name: value: {\n        name = name;\n        path = value;\n      }) config.etc);\n  };\n\n  config._module.args.pkgs = import <nixpkgs> {\n    config = {};\n    overlays = [];\n  };\n  config.etc.foo = pkgs.writeText \"foo\" ''\n    foo configuration\n  '';\n  config.etc.bar = pkgs.writeText \"bar\" ''\n    bar configuration\n  '';\n}\n\n```\n\nRun it with:\n\n```bash\nnix-instantiate -A config.etcCombined\n```\n\n**Output**:\n\n```bash\n/nix/store/3da61nmfk546qn2zpxsm57mq6vz6fjx8-etc.drv\n```\n\n- So we can see that it will instantiate, lets see if it will build:\n\n```bash\nnix-build -A config.etcCombined\n```\n\n**Output**:\n\n```bash\nthese 3 derivations will be built:\n/nix/store/41yfxq4af1vrs0rrgfk5gc36kmjc7270-bar.drv\n/nix/store/abyfp1rxk73p0n5kfilv7pawxwvc7hsg-foo.drv\n/nix/store/3da61nmfk546qn2zpxsm57mq6vz6fjx8-etc.drv\nbuilding '/nix/store/41yfxq4af1vrs0rrgfk5gc36kmjc7270-bar.drv'...\nbuilding '/nix/store/abyfp1rxk73p0n5kfilv7pawxwvc7hsg-foo.drv'...\nbuilding '/nix/store/3da61nmfk546qn2zpxsm57mq6vz6fjx8-etc.drv'...\n/nix/store/ca3wyk5m3qhy8n1nbn0181m29qvp1klp-etc\n```\n\n```bash\nnix-build -A config.etcCombined && ls result/ -laa\n```\n\n**Output**:\n\n```bash\n/nix/store/ca3wyk5m3qhy8n1nbn0181m29qvp1klp-etc\ndr-xr-xr-x - root 31 Dec  1969  .\ndrwxrwxr-t - root 16 May 15:13  ..\nlrwxrwxrwx - root 31 Dec  1969  bar -> /nix/store/1fsjyc2hmilab1qw6jfkf6cb767kz858-bar\nlrwxrwxrwx - root 31 Dec  1969  foo -> /nix/store/wai5dycp0zx1lxg0rhpdxnydhiadpk05-foo\n```\n\n- We can see that `foo` and `bar` link to different derivations\n\n- When trying to figure out which `default` to use for `etcCombined` infinisil\n  went to the Nixpkgs Reference Manual. Make sure to go to the correct version.\n  - [24.11pre-git](https://nixos.org/manual/nixpkgs/stable/)\n\n  - [25.05pre-git](https://nixos.org/manual/nixpkgs/unstable/) (i.e. unstable)\n\n  - Once at the website press `Ctrl+f` and type `symlinkjoin` and hit enter.\n\nOr in your local copy of Nixpkgs you could go to\n`nixpkgs/pkgs/build-support/ trivial-builders/default.nix`. Then use your\neditors search feature, with nvim and helix you press `/symlinkjoin` or\n`/linkFarm` hit enter then press `n` to cycle to the next match. It will bring\nyou to comments and up to date information.\n\n```bash\n# linkFarm \"myexample\" [ { name = \"hello-test\"; path = pkgs.hello; }\n# { name = \"foobar\"; path = pkgs.stack; } ]\n```\n\n</details>\n\n### Tests\n\n<details>\n<summary> Click to Expand Test Example </summary>\n\n- How to create a Derivation with `passthru.tests` outside of Nixpkgs and then\n  run tests available to your package set?\n\n```bash\nmkdir passthru-tests && cd passthru-tests\n```\n\nCreate a `default.nix` with the following:\n\n```nix\n# default.nix\nlet\n  pkgs = import <nixpkgs> {};\n\n  package = pkgs.runCommand \"foo\" {\n    passthru.tests.simple = pkgs.runCommand \"foo-test\" {} ''\n      if [[ \"$(cat ${package})\" != \"foo\" ]]; then\n        echo \"Result is not foo\"\n        exit 1\n      fi\n      touch $out\n  '';\n  } ''\n    echo foo > $out\n  '';\nin\npackage\n```\n\nSee if it will build:\n\n```bash\nnix-build\n```\n\nTry running the test:\n\n```bash\nnix-build -A passthru.tests\n```\n\n```bash\nthis derivation will be built:\n/nix/store/pqpqq9x1wnsabzbsb52z4g4y4zy6p7yx-foo-test.drv\nbuilding '/nix/store/pqpqq9x1wnsabzbsb52z4g4y4zy6p7yx-foo-test.drv'...\n/nix/store/7bbw2ban0mgkh4d59yz3cnai4aavwvb6-foo-test\n```\n\n### Test 2\n\n- `passthru.tests` is the convention for defining tests associated with a\n  derivation. The attributes in `passthru` are preserved and accessible after\n  the derivation is built.\n\n```nix\nlet\n  pkgs = import <nixpkgs> {};\n\n  package =\n    pkgs.runCommand \"foo\" {\n      passthru.tests.simple = pkgs.runCommand \"foo-test\" {} ''\n        if [[ \"$(cat ${package})\" != \"foo\" ]]; then\n          echo \"Result is not foo\"\n          exit 1\n        fi\n        touch $out\n      '';\n\n      passthru.tests.version = pkgs.testers.testVersion {\n         package = package;\n         version = \"1.2\";\n     };\n\n      # pkgs.writeShellApplication\n      script = ''\n        #!${pkgs.runtimeShell}\n        echo \"1.2\"\n      '';\n      passAsFiles = [ \"script\" ];\n\n    } ''\n      cp \"$scriptPath\" \"$out\"\n    '';\nin\n  package\n```\n\nTry to build it:\n\n```bash\nnix-build -A passthru.tests\n```\n\n- `testers.testVersion` checks if an executable outputs a specific version\n  string.\n\n- `nix-build -A passthru.tests` specifically targets the derivations defined\n  within the tests attribute of the main derivation.\n\n```bash\nthese 3 derivations will be built:\n  /nix/store/lyz86bd78p7f3yjy1qky6annmggymcwd-foo.drv\n  /nix/store/s4iawjy5zpv89dbkc3zz7z3ngz4jq2cv-foo-test.drv\n  /nix/store/z3gi4pb8jn2h9rvk4dhba85fiphp5g4z-foo-test-version.drv\nbuilding '/nix/store/lyz86bd78p7f3yjy1qky6annmggymcwd-foo.drv'...\ncp: cannot stat '': No such file or directory\nerror: builder for '/nix/store/lyz86bd78p7f3yjy1qky6annmggymcwd-foo.drv'\n failed with exit code 1;\n     last 1 log lines:\n     > cp: cannot stat '': No such file or directory\n     For full logs, run:\n       nix log /nix/store/lyz86bd78p7f3yjy1qky6annmggymcwd-foo.drv\nerror: 1 dependencies of derivation '/nix/store/z3gi4pb8jn2h9rvk4dhba85fiphp5g4z\n-foo-test-version.drv' failed to build\nerror: build of '/nix/store/s4iawjy5zpv89dbkc3zz7z3ngz4jq2cv-foo-test.drv',\n '/nix/store/z3gi4pb8jn2h9rvk4dhba85fiphp5g4z-foo-test-version.drv' failed\n```\n\nRun `nix-build` with no arguments:\n\n```bash\nnix-build\n```\n\n```bash\nnix derivation show /nix/store/lyz86bd78p7f3yjy1qky6annmggymcwd-foo.drv | jq '.[].env'\n```\n\n**Output**:\n\n```json\n{\n  \"__structuredAttrs\": \"\",\n  \"buildCommand\": \"cp \\\"$scriptPath\\\" \\\"$out\\\"\\n\",\n  \"buildInputs\": \"\",\n  \"builder\": \"/nix/store/xg75pc4yyfd5n2fimhb98ps910q5lm5n-bash-5.2p37/bin/bash\",\n  \"cmakeFlags\": \"\",\n  \"configureFlags\": \"\",\n  \"depsBuildBuild\": \"\",\n  \"depsBuildBuildPropagated\": \"\",\n  \"depsBuildTarget\": \"\",\n  \"depsBuildTargetPropagated\": \"\",\n  \"depsHostHost\": \"\",\n  \"depsHostHostPropagated\": \"\",\n  \"depsTargetTarget\": \"\",\n  \"depsTargetTargetPropagated\": \"\",\n  \"doCheck\": \"\",\n  \"doInstallCheck\": \"\",\n  \"enableParallelBuilding\": \"1\",\n  \"enableParallelChecking\": \"1\",\n  \"enableParallelInstalling\": \"1\",\n  \"mesonFlags\": \"\",\n  \"name\": \"foo\",\n  \"nativeBuildInputs\": \"\",\n  \"out\": \"/nix/store/9mcrnddb6lf1md14v4lj6s089i99l5k7-foo\",\n  \"outputs\": \"out\",\n  \"passAsFile\": \"buildCommand\",\n  \"passAsFiles\": \"script\",\n  \"patches\": \"\",\n  \"propagatedBuildInputs\": \"\",\n  \"propagatedNativeBuildInputs\": \"\",\n  \"script\": \"#!/nix/store/xg75pc4yyfd5n2fimhb98ps910q5lm5n-bash-5.2p37/bin/bash\\necho \\\"1.2\\\"\\n\",\n  \"stdenv\": \"/nix/store/lgydi1gl5wqcw6k4gyjbaxx7b40zxrsp-stdenv-linux\",\n  \"strictDeps\": \"\",\n  \"system\": \"x86_64-linux\"\n}\n```\n\n```bash\nnix derivation show /nix/store/lyz86bd78p7f3yjy1qky6annmggymcwd-foo.drv | jq\n '.[].env.buildCommand'\n```\n\n**Output:**\n\n```bash\n\"cp \\\"$scriptPath\\\" \\\"$out\\\"\\n\"\n```\n\n- raw mode below\n\n```bash\nnix derivation show /nix/store/lyz86bd78p7f3yjy1qky6annmggymcwd-foo.drv | jq\n '.[].env.buildCommand' -r\n```\n\n**Output**:\n\n```bash\ncp \"$scriptPath\" \"$out\"\n```\n\n- It turns out the correct command was `passAsFile` not `passAsFiles` but that\n  change wasn't enough to fix it. `passAsFiles` expects a list of files, not a\n  single file path. Running `nix-build -A passthru.tests` failed saying\n  `> foo --version returned a non-zero exit code.`\n\n```nix\nlet\n  pkgs = import <nixpkgs> {};\n\n  package =\n    pkgs.runCommand \"foo\" {\n      #passthru.tests.simple = pkgs.runCommand \"foo-test\" {} ''\n      #  if [[ \"$(cat ${package})\" != \"foo\" ]]; then\n      #    echo \"Result is not foo\"\n      #    exit 1\n      #  fi\n      #  touch $out\n      #'';\n\n      passthru.tests.version = pkgs.testers.testVersion {\n        package = package;\n        version = \"1.2\";\n      };\n\n      # pkgs.writeShellApplication\n      script = ''\n        #!${pkgs.runtimeShell}\n        echo \"1.2\"\n      '';\n      passAsFile = [\"script\"];\n    } ''\n      mkdir -p \"$out/bin\"\n      cp \"$scriptPath\" \"$out/bin/foo\"\n      chmod +x \"$out/bin/foo\"\n    '';\nin\n  package\n```\n\nBuild it:\n\n```bash\nnix-build -A passthru.tests\n```\n\n**Output:**\n\n```bash\nthese 2 derivations will be built:\n  /nix/store/lqrlcd64dmpzkggcfzlnsnwjd339czd3-foo.drv\n  /nix/store/c3kw4xbdlrig08jrdm5wis1dmv2gnqsd-foo-test-version.drv\nbuilding '/nix/store/lqrlcd64dmpzkggcfzlnsnwjd339czd3-foo.drv'...\nbuilding '/nix/store/c3kw4xbdlrig08jrdm5wis1dmv2gnqsd-foo-test-version.drv'...\n1.2\n/nix/store/zsbk5zawak68ailvkwi2gad2bqbqmdz9-foo-test-version\n```\n\n</details>\n\n### Key Takeaways for Debugging NixOS Modules\n\n- **`nix-instantiate` is Your Friend:** Use `nix-instantiate` to evaluate your\n  NixOS modules and pinpoint errors.\n\n- **Unlock Details with `--show-trace`:** When errors occur, always append\n  `--show-trace` to get a comprehensive stack trace, revealing the origin of the\n  problem. Remember that in newer Nix versions, the most relevant parts of the\n  trace are often at the bottom.\n\n- **Understand Option Types:** Nix option types (`raw`, `anything`,\n  `string`/`str`, `lines`, `attrsOf`) are not just about data types; they also\n  dictate how values are merged and processed within the module system.\n\n- **Be Mindful of `mkOptionDefault`:** While useful in specific scenarios,\n  `mkOptionDefault` sets a lower priority default. For standard defaults that\n  can be overridden by user configuration, define them directly within the\n  `config` attribute using `lib.mkDefault`.\n\n- **Use `builtins.addErrorContext`:** Enhance your custom error messages by\n  providing specific context relevant to your module's logic using\n  `builtins.addErrorContext`.\n\n- **Derivations vs. Evaluation:** Be aware of the difference between evaluating\n  expressions (`--eval --strict`) and instantiating derivations\n  (`nix-instantiate`). Strict evaluation can trigger infinite recursion if it\n  encounters unevaluated derivations with cyclic dependencies during attribute\n  access.\n\n- **Explore with `nix repl`:** The `nix repl` allows you to interactively\n  explore Nix expressions and the outputs of derivations, providing insights\n  into the structure and values within Nixpkgs.\n\n#### Conclusion\n\nThis chapter has equipped you with essential techniques for debugging and\ntracing NixOS modules. We've explored how to use `nix-instantiate` and\n`--show-trace` to pinpoint errors, how to interpret Nix's often-verbose error\nmessages, and how to leverage the `nix repl` for interactive exploration.\nUnderstanding option types and the nuances of `mkOptionDefault` is crucial for\nwriting robust and predictable modules. We've also touched upon the distinction\nbetween evaluation and instantiation, and how that impacts debugging.\n\nWhile these tools and techniques are invaluable for understanding and\ntroubleshooting your own Nix configurations, they also become essential when you\nwant to contribute to or modify the vast collection of packages and modules\nwithin **Nixpkgs** itself. Nixpkgs is where the majority of Nix packages and\nNixOS modules reside, and learning how to navigate and contribute to it opens up\na whole new level of control and customization within the Nix ecosystem.\n\nIn the next chapter,\n[Working with Nixpkgs Locally](https://saylesss88.github.io/Working_with_Nixpkgs_Locally_10.html),\nwe'll shift our focus to exploring and modifying Nixpkgs. We'll cover how to\nclone Nixpkgs, how to make changes to package definitions, and how to test those\nchanges locally before contributing them back upstream. This chapter will\nempower you to not just use existing Nix packages, but also to customize and\nextend them to fit your specific needs.\n","number":[11],"sub_items":[],"path":"Debugging_and_Tracing_NixOS_Modules_9.md","source_path":"Debugging_and_Tracing_NixOS_Modules_9.md","parent_names":[]}},{"Chapter":{"name":"Working with Nixpkgs Locally","content":"# Chapter 10\n\n<details>\n<summary> ✔️ Click to Expand Table of Contents</summary>\n\n<!-- toc -->\n\n</details>\n\n![server_rack](images/server_rack.cleaned.png)\n\n<!-- ![gruv18](images/gruv18.png) -->\n\n## Working with Nixpkgs Locally: Benefits and Best Practices\n\n- Nixpkgs, the package repository for NixOS, is a powerful resource for building\n  and customizing software.\n\n- Working with a local copy enhances development, debugging, and contribution\n  workflows.\n\n- This post covers setting up a local Nixpkgs repository, searching for\n  dependencies, and leveraging its advantages, incorporating tips from the Nix\n  community.\n\n# I. Why Work with Nixpkgs Locally?\n\n- A local Nixpkgs repository offers significant advantages for Nix developers:\n\n  ## A. Faster Development Cycle\n  - Local searches for packages and dependencies are significantly quicker than\n    querying remote repositories or channels.\n\n  - This speedup is crucial for efficient debugging and rapid prototyping of Nix\n    expressions.\n\n  ## B. Enhanced Version Control\n  - By pinning your local repository to specific commits or branches (e.g.,\n    `nixos-unstable`), you ensure build reproducibility.\n\n  - This prevents unexpected issues arising from upstream changes in Nixpkgs.\n\n  ## C. Flexible Debugging Capabilities\n  - You can directly test and modify package derivations within your local copy.\n\n  - This allows for quick fixes to issues like missing dependencies without\n    waiting for upstream updates or releases.\n\n  ## D. Streamlined Contribution Workflow\n  - Developing and testing new packages or patches locally is essential before\n    submitting them as pull requests to Nixpkgs.\n\n  - A local setup provides an isolated environment for experimentation.\n\n  ## E. Up-to-Date Documentation Source\n  - The source code and comments within the Nixpkgs repository often contain the\n    most current information about packages.\n  - This can sometimes be more up-to-date than official, external documentation.\n\n  ## F. Optimized Storage and Performance\n  - Employing efficient cloning strategies (e.g., shallow clones) and avoiding\n    unnecessary practices (like directly using Nixpkgs as a flake for local\n    development) minimizes disk usage and build times.\n\n# II. Flake vs. Non-Flake Syntax for Local Nixpkgs\n\n- When working with Nixpkgs locally, the choice between Flake and non-Flake\n  syntax has implications for performance and storage:\n\n  ## A. Flake Syntax (`nix build .#<package>`)\n  - Treats the current directory as a flake, requiring evaluation of\n    `flake.nix`.\n\n  - For local Nixpkgs, this evaluates the flake definition in the repository\n    root.\n\n  - **Performance and Storage Overhead:** Flakes copy the entire working\n    directory (including Git history if present) to `/nix/store` for evaluation.\n    This can be slow and storage-intensive for large repositories like Nixpkgs.\n\n  ## B. Non-Flake Syntax (`nix-build -f . <package>` or `nix build -f . <package>`)\n  - `-f .` specifies the Nix expression (e.g., `default.nix` or a specific file)\n    in the current directory.\n\n  - **Efficiency:** Evaluates the Nix expression directly _without_ copying the\n    entire worktree to `/nix/store`. This is significantly faster and more\n    storage-efficient for local development on large repositories.\n\n## III. Setting Up a Local Nixpkgs Repository Efficiently\n\n<details>\n<summary>Click To See How to set up Nixpkgs Locally</summary>\n\n- Cloning Nixpkgs requires careful consideration due to its size.\n\n## A.a Initial Clone: Shallow Cloning\n\nIt is common to place your local clone in the `/src` directory:\n\n```bash\nmkdir src && cd src\n```\n\n> ❗ Warning, A shallow clone (`--depth 1`) is not recommended for general\n> development or contributing changes back to Nixpkgs via pull requests. It's\n> primarily suitable for:\n>\n> - Quick checks or builds: If you only need to verify a package's current state\n>   or build a specific version without needing historical context.\n> - CI/CD environments: Where disk space and clone time are critical, and only\n>   the latest commit is needed for automated tests or builds.\n\nWith that said, to avoid downloading the entire history, perform a shallow\nclone:\n\n```bash\ngit clone [https://github.com/NixOS/nixpkgs](https://github.com/NixOS/nixpkgs) --depth 1\ncd nixpkgs\n```\n\n## A.b A few Examples exploring Nixpkgs\n\nWhile in the `nixpkgs` directory, you can check the version of a package:\n\n```bash\nnix-instantiate --eval -A openssl.version\n\"3.4.1\"\n```\n\nOr to directly edit the file you can use `nix edit`:\n\n```bash\nnix edit nixpkgs#openssl\n```\n\nIt uses the nix registry and `openssl.meta.position` to locate the file.\n\n```bash\nman nix3 registry\n```\n\nThe above command will open the `openssl/default.nix` in your `$EDITOR`.\n\n## A.1 Full Fork and Clone of Nixpkgs\n\nIf you want to contribute to Nixpkgs, you need to set up a local version\nfollowing the\n[Contributing guide](https://github.com/NixOS/nixpkgs/blob/master/CONTRIBUTING.md)\n\nYou'll need to, this is directly from the `Contributing.md`:\n\n1. [Fork](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/working-with-forks/fork-a-repo#forking-a-repository)\n   the [Nixpkgs repository](https://github.com/nixos/nixpkgs/)\n\n2. [Clone the forked repo](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/working-with-forks/fork-a-repo#cloning-your-forked-repository)\n   into a local `nixpkgs` directory.\n\n3. [Configure the upstream Nixpkgs repo](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/working-with-forks/fork-a-repo#configuring-git-to-sync-your-fork-with-the-upstream-repository)\n\n## B. Managing Branches with Worktrees\n\n- Use Git worktrees to manage different branches efficiently:\n\n  ```bash\n  git fetch --all --prune --depth=1\n  git worktree add -b nixos-unstable nixos-unstable # For just unstable\n  ```\n\n- **Explanation of `git worktree`:** Allows multiple working directories\n  attached to the same `.git` directory, sharing history and objects but with\n  separate checked-out files.\n\n- `git worktree add`: Creates a new working directory for the specified branch\n  (`nixos-unstable` in this case).\n\n</details>\n\n# IV. Debugging Missing Dependencies: A Practical Example\n\n<details>\n<summary> Click to see icat Example </summary>\n\n- Let's say you're trying to build `icat` locally and encounter a missing\n  dependency error:\n\n```nix\nnix-build -A icat\n# ... (Error log showing \"fatal error: X11/Xlib.h: No such file or directory\")\n```\n\n- The error `fatal error: X11/Xlib.h: No such file or directory` indicates a\n  missing X11 dependency.\n\n## A. Online Search with `search.nixos.org`\n\n- The Nixpkgs package search website\n  ([https://search.nixos.org/packages](https://search.nixos.org/packages)) is a\n  valuable first step.\n- However, broad terms like \"x11\" can yield many irrelevant results.\n- **Tip:** Utilize the left sidebar to filter by package sets (e.g., \"xorg\").\n\n## B. Local Source Code Search with `rg` (ripgrep)\n\n- Familiarity with searching the Nixpkgs source code is crucial for finding\n  dependencies.\n- Navigate to your local `nixpkgs/` directory and use `rg`:\n\n  ```bash\n  rg \"x11 =\" pkgs # Case-sensitive search\n  ```\n\n  **Output:**\n\n  ```\n  pkgs/tools/X11/primus/default.nix\n  21:  primus = if useNvidia then primusLib_ else primusLib_.override { nvidia_x11 = null; };\n  22:  primus_i686 = if useNvidia then primusLib_i686_ else primusLib_i686_.override { nvidia_x11 = null; };\n\n  pkgs/applications/graphics/imv/default.nix\n  38:    x11 = [ libGLU xorg.libxcb xorg.libX11 ];\n  ```\n\n- Refining the search (case-insensitive):\n  ```bash\n  rg -i \"libx11 =\" pkgs\n  ```\n  **Output:**\n  ```\n  # ... (Output showing \"xorg.libX11\")\n  ```\n- The key result is `xorg.libX11`, which is likely the missing dependency.\n\n </details>\n\n# V. Local Derivation Search with `nix-locate`\n\n<details>\n<summary> Click to Expand nix-locate command Example</summary>\n\n- `nix-locate` (from the `nix-index` package) allows searching for derivations\n  on the command line.\n\n  > **Note:** Install `nix-index` and run `nix-index` to create the initial\n  > index.\n\n  ```bash\n  nix-locate libx11\n  # ... (Output showing paths related to libx11)\n  ```\n\n- Combining online and local search tools (`search.nixos.org`, `rg`,\n  `nix-locate`) provides a comprehensive approach to finding dependencies.\n\n</details>\n\n# VI. Key Benefits of Working with Nixpkgs Locally (Recap)\n\n- **Speed:** Faster searches and builds compared to remote operations.\n\n- **Control:** Full control over the Nixpkgs version.\n\n- **Up-to-Date Information:** Repository source often has the latest details.\n\n# VII. Best Practices and Tips from the Community\n\n<details>\n<summary> ✔️ Click To Expand Best Practices and Tips from the community</summary>\n\n- **Rebasing over Merging:** Never merge upstream changes into your local\n  branch. Always rebase your branch onto the upstream (e.g., `master` or\n  `nixos-unstable`) to avoid accidental large-scale pings in pull requests (Tip\n  from `soulsssx3` on Reddit).\n\n- **Tip from `ElvishJErrico`:** Avoid using Nixpkgs directly as a flake for\n  local development due to slow copying to `/nix/store` and performance issues\n  with garbage collection on large numbers of small files. Use\n  `nix build -f . <package>` instead of `nix build .#<package>`.\n\n- **Edge Cases for Flake Syntax:** Flake syntax might be necessary in specific\n  scenarios, such as NixOS installer tests where copying the Git history should\n  be avoided.\n\n- **Base Changes on `nixos-unstable`:** For better binary cache hits, base your\n  changes on the `nixos-unstable` branch instead of `master`. Consider the\n  merge-base for staging branches as well.\n\n- **Consider `jujutsu`:** Explore [jj-vcs](https://github.com/jj-vcs/jj), a\n  Git-compatible alternative that can offer a more intuitive workflow,\n  especially for large monorepos like Nixpkgs. While it has a learning curve, it\n  can significantly improve parallel work and branch management.\n\n- [Intro-To-Jujutsu](https://saylesss88.github.io/vcs/jujutsu.html)\n\n</details>\n","number":[12],"sub_items":[{"Chapter":{"name":"Fork, Clone, Contribute","content":"# Fork, Clone, Contribute\n\n- In the [Nixpkgs](https://github.com/NixOS/nixpkgs) Repository.\n\n- Click Fork, then Create a new Fork.\n\n- Uncheck the box \"Only fork the `master` branch\", for development we will need\n  more branches.\n  - If you only fork master, you won't have the `nixos-XX.YY` release branches\n    available on your fork when you later try to create a PR against them, or\n    when you want to create a feature branch from them on your fork.\n\n- Click `<> Code` and Clone the Repo. `sayls8` is the name of my GitHub, yours\n  will obviously be different.\n\n```bash\ngit clone git@github.com:sayls8/nixpkgs.git\n```\n\nFigure out the branch that should be used for this change by going through\n[this section](https://github.com/NixOS/nixpkgs/blob/master/CONTRIBUTING.md#branch-conventions)\n\nWhen in doubt use `master`, that's where most changes should go. This can be\nchanged later by\n[rebasing](https://github.com/NixOS/nixpkgs/blob/master/CONTRIBUTING.md#rebasing-between-branches-ie-from-master-to-staging)\n\nAdd [Nixpkgs](https://github.com/NixOS/nixpkgs) as your upstream:\n\n```bash\ncd nixpkgs\n\ngit remote add upstream https://github.com/NixOS/nixpkgs.git\n# Make sure you have the latest changes from upstream Nixpkgs\ngit fetch upstream\n# Show currently configured remote repository\ngit remote -v\norigin  git@github.com:sayls8/nixpkgs.git (fetch)\norigin  git@github.com:sayls8/nixpkgs.git (push)\nupstream        https://github.com/NixOS/nixpkgs.git (fetch)\nupstream        https://github.com/NixOS/nixpkgs.git (push)\n```\n\n**Understanding Your Remotes**\n\nThis output confirms that:\n\n- `origin` is your personal fork on GitHub (`sayls8/nixpkgs.git`). When you\n  `git push origin ...`, your changes go here.\n\n- `upstream` is the official Nixpkgs repository (`NixOS/nixpkgs.git`). When you\n  `git fetch upstream`, you're getting the latest updates from the main project.\n\nThis setup ensures you can easily pull updates from the original project and\npush your contributions to your own fork.\n\n```bash\n# Shows a ton of remote branches\ngit branch -r | grep upstream\n# Narrow it down\ngit branch -r | grep upstream | grep nixos-\n```\n\nNext Steps for Contributing\n\n1. Ensure `master` is up to date with `upstream`\n\n```bash\ngit checkout master\ngit pull upstream master\ngit push origin master\n```\n\n- `git pull upstream master` is equivalent to running `git fetch upstream`\n  followed by `git merge upstream/master` into your current branch (`master`).\n\n- `git push origin master` updates your forks remote with the fetched changes.\n\nThis keeps your fork in sync to avoid conflicts.\n\nIf targeting another branch, replace `master` with `nixos-24.11` for example.\n\n2. Create a Feature Branch\n\n```bash\ngit checkout master\ngit checkout -b my-feature-branch # name should represent the feature\n```\n\n3. Make and Test Changes\n\n[Packaging Conventions](https://github.com/NixOS/nixpkgs/blob/master/pkgs/README.md#conventions)\n\n**New package**: Add to\n`pkgs/by-name/<first-two-letters>/<package-name>/default.nix`.\n\n**Example structure**:\n\n```nix\n{ lib, stdenv, fetchFromGitHub }: stdenv.mkDerivation {\npname = \"xyz\"; version = \"1.2.3\"; src = fetchFromGitHub { ... }; ... }\n```\n\n**Update package**: Edit version and `sha256` in the package’s `default.nix`.\nUse `nix-prefetch-url` to update hashes:\n\n```bash\nnix-prefetch-url <source-url>\n```\n\n**Fix a bug**: Modify files in `pkgs/`, `nixos/modules/`, or elsewhere.\n\n**Test locally**:\n\nBuild:\n\n```bash\nnix-build -A <package-name>\n```\n\n**Test in a shell**:\n\n```bash\nnix-shell -p <package-name>\n```\n\nFor NixOS modules:\n\n```bash\nnixos-rebuild test\n```\n\nFollow the Nixpkgs Contributing Guide.\n\n4. **Commit and Push**\n\nCommit with a clear message, make sure to follow\n[commit conventions](https://github.com/NixOS/nixpkgs/blob/master/CONTRIBUTING.md#commit-conventions):\n\n**Commit Conventions**\n\n- Create a commit for each logical unit.\n\n- Check for unnecessary whitespace with `git diff --check` before committing.\n\n- If you have commits `pkg-name: oh, forgot to insert whitespace`: squash\n  commits in this case. Use `git rebase -i`. See\n  [Squashing Commits](https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History#_squashing)\n  for additional information.\n\n- For consistency, there should not be a period at the end of the commit\n  message's summary line (the first line of the commit message).\n\n- When adding yourself as maintainer in the same pull request, make a separate\n  commit with the message maintainers: `add <handle>`. Add the commit before\n  those making changes to the package or module. See\n  [Nixpkgs Maintainers](https://github.com/NixOS/nixpkgs/blob/master/maintainers/README.md)\n  for details.\n\nFormat the commit messages in the following way:\n\n```bash\n(pkg-name): (from -> to | init at version | refactor | etc)\n\n(Motivation for change. Link to release notes. Additional information.)\n```\n\na) For example, for the `airshipper` package:\n\n```bash\ngit add pkgs/by-name/ai/airshipper/\ngit commit -m \"airshipper: init at 0.1.0\"\n\nAdds the airshipper tool for managing game assets.\nUpstream homepage: https://github.com/someuser/airshipper\"\n```\n\nb) Updating `airshipper` to a new version\n\n```bash\ngit add pkgs/by-name/ai/airshipper/\ngit commit -m \"airshipper: 0.1.0 -> 0.2.0\n\nUpdated airshipper to version 0.2.0. This release includes:\n- Improved asset fetching logic\n- Bug fixes for network errors\n\nRelease notes: https://github.com/someuser/airshipper/releases/tag/v0.2.0\"\n```\n\nc) Fixing a bug in `airshipper`'s package definition\n\n```bash\ngit add pkgs/by-name/ai/airshipper/\ngit commit -m \"airshipper: fix: build with latest glibc\n\nResolved build failures on unstable channel due to changes in glibc.\nPatched source to use updated API calls.\n\"\n```\n\nExamples:\n\n- `nginx: init at 2.0.1`\n\n- `firefox: 122.0 -> 123.0`\n\n- `vim: fix build with gcc13`\n\nPush:\n\n```bash\ngit push origin my-feature-branch\n```\n\nWhen you push your feature branch, it will output a link that you can follow to\ncomplete the PR on GitHub.\n\nIf you have the `gh-cli` set up you can also do this from the command line:\n\n```bash\ngh pr create --repo NixOS/nixpkgs --base master --head sayls8:feat/my-package\n```\n\n5. Create a Pull Request\n\nGo to <https://github.com/sayls8/nixpkgs>. (your fork) Click the PR prompt for\nmy-feature-branch. Set the base branch to `NixOS/nixpkgs:master` (or\n`nixos-24.11`). Write a PR description: Purpose of the change. Related issues\n(e.g., Fixes #1234). Testing steps (e.g., `nix-build -A <package-name>`). Submit\nand respond to feedback.\n\n6. Handle Updates\n\nFor reviewer feedback or upstream changes:\n\nEdit, commit, and push:\n\n```bash\ngit add . git commit -m \"<package-name>: address feedback\" git push origin my-feature-branch\n```\n\nRebase if needed:\n\n```bash\ngit fetch upstream\ngit rebase upstream/master  # or upstream/nixos-24.11\ngit push origin my-feature-branch --force\n```\n\n7. Cleanup\n\nAfter PR merge:\n\nDelete branch:\n\n```bash\ngit push origin --delete my-feature-branch\n```\n\nSync master:\n\n```bash\ngit checkout master\ngit pull upstream master\ngit push origin master\n```\n\nAddressing the Many Branches\n\n- No need to manage all branches: The `nixos-branches` are just metadata from\n  upstream. You only check out the one you need (e.g., `master` or\n  `nixos-24.11`).\n\n- Focus on relevant branches: The filter (`grep nixos-`) shows the key release\n  branches. Ignore -small branches and older releases unless specifically\n  required. Confirm latest stable: If you’re targeting a stable branch,\n  `nixos-24.11` is likely the latest (or `nixos-25.05` if it’s active). Verify\n  via NixOS status.\n","number":[12,1],"sub_items":[],"path":"nixpkgs/fork_clone_contribute.md","source_path":"nixpkgs/fork_clone_contribute.md","parent_names":["Working with Nixpkgs Locally"]}},{"Chapter":{"name":"Build a local package within a Nixpkgs Clone","content":"# Creating and Building a Local Package within a Nixpkgs Clone\n\nThis chapter demonstrates the fundamental pattern for creating a package. Every\npackage recipe is a file that declares a function. This function takes the\npackages dependencies as argument.\n\nIn this example we'll make a simple package with `coreutils` and build it.\nDemonstrating the process of building and testing a local package.\n\nThis chapter will assume you have already have a cloned fork of Nixpkgs. I\nchoose to clone mine to the `~/src/` directory.\n\nYou can check out the `nixpkgs/pkgs/README.md`\n[Here](https://github.com/NixOS/nixpkgs/tree/master/pkgs)\n\nThe Nixpkgs Contributing Guide can be found\n[Here](https://github.com/NixOS/nixpkgs/blob/master/CONTRIBUTING.md)\n\n## Create your Package directory and a `default.nix`\n\nFor this example, we'll create a package called `testPackage` and will place it\nin the `nixpkgs/pkgs/misc` directory.\n\n```bash\ncd ~/src/nixpkgs/pkgs/misc\nmkdir testPackage && cd testPackage\nhx default.nix\n```\n\n```nix\n# default.nix\n{\n  runCommand,\n  coreutils,\n}:\nrunCommand \"testPackage\" {\n  nativeBuildInputs = [\n    coreutils\n  ];\n} ''\n\n  echo 'This is a Test' > $out\n''\n```\n\nNow we need to add our `testPackage` to `all-packages.nix`\n\n```bash\ncd pkgs/top-level\nhx all-packages.nix\n```\n\n`all-packages.nix` is a centralized module that defines all available package\nexpressions.\n\nWe'll add our package in the list alphabetically:\n\n```nix\n# all-packages.nix\n# `/msc` # editor search inside file\n# Scroll down to t's\n# snip ...\ntermusic = callPackage ../applications/autio/termusic { };\n\n# we add our package here\ntestPackage = callPackage ../misc/testPackage { };\n\ntfk8s = callPackage ../applications/misc/tfk8s { };\n# snip ...\n```\n\n> `callPackage` is a core utility in Nixpkgs. It takes a Nix expression (like\n> our `default.nix` file, which defines a function) and automatically provides\n> the function with any arguments it declares, by looking them up within the\n> `pkgs` set (or the scope where `callPackage` is invoked). This means you only\n> need to list the dependencies your package needs in its `default.nix` function\n> signature, and `callPackage` will \"inject\" the correct versions of those\n> packages. This is what the `callPackage` Nix Pill demonstrates at a lower\n> level.\n\n## Understanding `pkgs/by-name/` and other locations\n\nNixpkgs uses different conventions for package placement:\n\n- **Older categories (e.g., `pkgs/misc/`, `pkgs/applications/`):** Packages\n  within these directories typically use `default.nix` as their definition file\n  (e.g., `pkgs/misc/testPackage/default.nix`). **These packages are NOT\n  automatically included** in the top-level `pkgs` set; they _must_ be This\n  chapter will assume you have already have a cloned fork of Nixpkgs. explicitly\n  added via a `callPackage` entry in `pkgs/top-level/all-packages.nix`. This is\n  the method demonstrated in this chapter for our `testPackage`.\n\n- **The new `pkgs/by-name/` convention:** This is the _preferred location for\n  new packages_.\n\n  - Packages here are placed in a directory structure like\n    `pkgs/by-name/<first-two-letters>/<package-name>/`.\n\n  - Crucially, their main definition file is named `package.nix` (e.g.,\n    `pkgs/by-name/te/testPackage/package.nix`).\n\n  - **Packages placed within `pkgs/by-name/` are automatically discovered and\n    exposed** by Nixpkgs' top-level `pkgs` set. They **do not** require a manual\n    `callPackage` entry in `all-packages.nix`. This results in a more modular\n    and scalable approach, reducing manual maintenance.\n\n> ❗ : While this example uses `pkgs/misc/` to demonstrate explicit\n> `callPackage` usage, when contributing a _new_ package to Nixpkgs, you should\n> nearly always place it within `pkgs/by-name/` and name its definition file\n> `package.nix`.\n\n- [pkgs/by-name/README](https://github.com/NixOS/nixpkgs/blob/master/pkgs/by-name/README.md)\n\n- There are some\n  [Limitations](https://github.com/NixOS/nixpkgs/blob/master/pkgs/by-name/README.md#limitations)\n  to this approach.\n\n- [nixpkgs-vet](https://github.com/NixOS/nixpkgs-vet)\n\nPreviously, packages were manually added to `all-packages.nix`. While this is no\nlonger needed in most cases, understanding the old method provides useful\ncontext for troubleshooting legacy configurations or custom integrations.\n\n## Try Building the Package\n\nMove to the root directory of Nixpkgs:\n\n```bash\ncd ~/src/nixpkgs\n```\n\nTry building it:\n\n```bash\nnix-build -A testPackage\nthis derivation will be built:\nthis derivation will be built:\n  /nix/store/yrbjsxmgzkl24n75sqjfxbpv5cs3b9hc-testPackage.drv\nbuilding '/nix/store/yrbjsxmgzkl24n75sqjfxbpv5cs3b9hc-testPackage.drv'...\n/nix/store/3012zlv30vn6ifihr1jxbg5z3ysw0hl3-testPackage\n```\n\n`runCommand` is a simple builder, it takes 3 arguments. The first is the package\nname the second is the derivation attributes, and the third is the script to\nrun.\n\n```bash\ncat ~/src/nixpkgs/result\n───────┬──────────────────────────────\n       │ File: result\n───────┼──────────────────────────────\n   1   │ This is a Test\n───────┴──────────────────────────────\n```\n\n```bash\nnix-instantiate --eval -A testPackage.meta.position\n\"/home/jr/src/nixpkgs/pkgs/misc/testPackage/default.nix:6\"\n```\n\nTools like `nix search` and the Nixpkgs website use the `meta` information for\ndocumentation and discoverability. It can also be useful for debugging and helps\nto provide better error messages. The above command shows that the\n`meta.position` attribute points to the file and line where the package\ndefinition begins, which is very useful for debugging.\n\nTypically a file will have a `meta` attribute that looks similar to the\nfollowing:\n\n```nix\nmeta = with lib; {\n    homepage = \"https://www.openssl.org/\";\n    description = \"A cryptographic library that implements the SSL and TLS protocols\";\n    license = licenses.openssl;\n    platforms = platforms.all;\n} // extraMeta;\n```\n\nFor example, the following shows how Nix is able to discover different parts of\nyour configuration:\n\nLaunch the `nix repl` and load your local flake:\n\n```bash\ncd /src\nnix repl\nnix-repl> :lf nixpkgs\nnix-repl> outputs.legacyPackages.x86_64-linux.openssl.meta.position\n\"/nix/store/syvnmj3hhckkbncm94kfkbl76qsdqqj3-source/pkgs/development/libraries/openssl/default.nix:303\"\nnix-repl> builtins.unsafeGetAttrPos \"description\" outputs.legacyPackages.x86_64-linux.openssl.meta\n{\n  column = 9;\n  file = \"/nix/store/syvnmj3hhckkbncm94kfkbl76qsdqqj3-source/pkgs/development/libraries/openssl/default.nix\";\n  line = 303;\n}\n```\n\nLets create just the `meta.description` for demonstration purposes.\n\n## Adding the meta attribute\n\nSince we don't have a `meta` attribute this points to a default value that's\nincorrect.\n\nLet's add the `meta` attribute and try it again:\n\n```nix\n# default.nix\n{\n  runCommand,\n  coreutils,\n}:\nrunCommand \"testPackage\" {\n  nativeBuildInputs = [\n    coreutils\n  ];\n\n  meta = {\n    description = \"test package\";\n};\n} ''\n\n  echo 'This is a Test' > $out\n''\n```\n\n```nix\nnix-instantiate --eval -A testPackage.meta.position\n\"/home/jr/src/nixpkgs/pkgs/misc/testPackage/default.nix:11\"\n```\n\nNow it points us to the 11'th line, right where our `meta.description` is.\n\nLet's stage our package so nix recognises it:\n\n```bash\ncd ~/nixpkgs\ngit add pkgs/misc/testPackage/\nnix edit .#testPackage\n```\n\nI used `nix edit` here to ensure it was picked up properly.\n\nThe `default.nix` that we've been working on should open in your `$EDITOR`\n","number":[12,2],"sub_items":[],"path":"nixpkgs/local_package.md","source_path":"nixpkgs/local_package.md","parent_names":["Working with Nixpkgs Locally"]}},{"Chapter":{"name":"Nixpkgs Overlays to Override Version","content":"# Nixpkgs Overlays\n\nThe following is done with a local clone of Nixpkgs located at `~/src/nixpkgs`.\n\nIn this example, we will create an overlay to override the version of\n`btrfs-progs`. In the root directory of our local clone of Nixpkgs\n(i.e.`~/src/nixpkgs`) we can run the following command to locate `btrfs-progs`\nwithin Nixpkgs:\n\n```bash\nfd 'btrfs-progs' .\n./pkgs/by-name/bt/btrfs-progs/\n```\n\nOpen the `package.nix` in the above directory and copy the `src` block within\nthe `stdenv.mkDerivation` block like so:\n\n```nix\n# package.nix\n  version = \"6.14\";\n\n  src = fetchurl {\n    url = \"mirror://kernel/linux/kernel/people/kdave/btrfs-progs/btrfs-progs-v${version}.tar.xz\";\n    hash = \"sha256-31q4BPyzbikcQq2DYfgBrR4QJBtDvTBP5Qzj355+PaE=\";\n  };\n```\n\nWhen we use the above `src` block in our overlay we'll need to add\n`src = self.fetchurl` for our overlay to have access to `fetchurl`.\n\nWe will replace the version with our desired version number. To find another\nversion that actually exists we need to check their github repos\n[btrfs-progs Releases](https://github.com/kdave/btrfs-progs/releases). I can see\nthat the previous version was `v6.13`, lets try that.\n\n```bash\ncd ~/src/nixpkgs\nhx overlay.nix\n```\n\nWe will change the version to `6.13` for demonstration purposes. All that is\nreally required is changing the version and 1 character in the `hash` which\nwould cause a refetch and recalculation of the hash. We will use an empty string\nto follow convention:\n\n```nix\n# overlay.nix\nself: super: {\n  btrfs-progs = super.btrfs-progs.overrideAttrs (old: rec {\n      version = \"6.13\";\n\n      # Notice the `self` added here\n      src = self.fetchurl {\n        url = \"mirror://kernel/linux/kernel/people/kdave/btrfs-progs/btrfs-progs-v${version}.tar.xz\";\n        hash = \"\";\n      };\n    };\n  });\n}\n```\n\nTo build this with the file right from the root of the local Nixpkgs (i.e.\n`~/src/nixpkgs`) you could run the following. Running the command this way\navoids the impurity of looking it up in the `~/.config` directory:\n\n```bash\nnix-build -A btrfs-progs --arg overlays '[ (import ./overlay.nix) ]'\n```\n\nThe compiler will give you back the correct `hash`:\n\n```bash\nspecified: sha256-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\ngot:    sha256-ZbPyERellPgAE7QyYg7sxqfisMBeq5cTb/UGx01z7po=\n```\n\nReplace the empty `hash` with the new hash value we just got from the compiler\nso the `overlay.nix` would look like this:\n\n```nix\nself: super: {\n  btrfs-progs = super.btrfs-progs.overrideAttrs (old: rec {\n    version = \"6.13\";\n\n    src = self.fetchurl {\n      url = \"mirror://kernel/linux/kernel/people/kdave/btrfs-progs/btrfs-progs-v${version}.tar.xz\";\n      hash = \"sha256-ZbPyERellPgAE7QyYg7sxqfisMBeq5cTb/UGx01z7po=\";\n    };\n  });\n}\n```\n\nTry building it again:\n\n```bash\nnix-build -A btrfs-progs --arg overlays '[ (import ./overlay.nix) ]'\nchecking for references to /build/ in /nix/store/szd6lizahidjniz85a0g1wsrfknirhwb-btrfs-progs-6.13...\ngzipping man pages under /nix/store/szd6lizahidjniz85a0g1wsrfknirhwb-btrfs-progs-6.13/share/man/\npatching script interpreter paths in /nix/store/szd6lizahidjniz85a0g1wsrfknirhwb-btrfs-progs-6.13\n/nix/store/szd6lizahidjniz85a0g1wsrfknirhwb-btrfs-progs-6.13/bin/fsck.btrfs: interpreter directive changed from \"#!/bin/sh -f\" to \"/nix/store/xy4jjgw87sbgwylm5kn047d9gkbhsr9x-bash-5.2p37/bin/sh -f\"\nstripping (with command strip and flags -S -p) in  /nix/store/szd6lizahidjniz85a0g1wsrfknirhwb-btrfs-progs-6.13/lib /nix/store/szd6lizahidjniz85a0g1wsrfknirhwb-btrfs-progs-6.13/bin\n/nix/store/szd6lizahidjniz85a0g1wsrfknirhwb-btrfs-progs-6.13\n```\n\nWe can inspect it with the repl:\n\n```bash\ncd ~/src/nixpkgs\nnix repl\nnix-repl> :a import ./. { overlays = [ (import ./overlay.nix) ]; }\nnix-repl> btrfs-progs\n«derivation /nix/store/6yxhj84cwcsnrd87rcxbd6w08l9ikc6p-btrfs-progs-6.13.drv»\nnix-repl> btrfs-progs.drvAttrs.buildInputs\n[\n  «derivation /nix/store/yg4llzkcla5rppv8r1iikyamfxg3g4sg-acl-2.3.2.drv»\n  «derivation /nix/store/vqczbcwjnid6bs4cv3skl7kyd6kkzcfx-attr-2.5.2.drv»\n  «derivation /nix/store/xrvx0azszpdh2x0lnldakqx25vfxab19-e2fsprogs-1.47.2.drv»\n  «derivation /nix/store/iil4b8adk615zhp6wmzjx16z1v2f8f4j-util-linux-minimal-2.41.drv»\n  «derivation /nix/store/wwld8wp91m26wz69gp8vzh090sh5ygxd-lzo-2.10.drv»\n  «derivation /nix/store/w4ncw24gdfkbx9779xpgjli5sagi506m-systemd-minimal-libs-257.5.drv»\n  «derivation /nix/store/dmh4lvmq6n8hy56q93kplvnfnlwqzzv5-zlib-1.3.1.drv»\n  «derivation /nix/store/h8iwhnr636dwb72qqcyzp111ajjxgzr2-zstd-1.5.7.drv»\n]\nnix-repl> btrfs-progs.drvAttrs.version\n\"6.13\"\nnix-repl> btrfs-progs.drvAttrs.src\n«derivation /nix/store/y5nkz1xczxha4xl93qq3adndyc46dcvf-btrfs-progs-v6.13.tar.xz.drv»\n```\n\nUsing `:a` adds the attributes from the resulting set into scope and avoids\nbringing the entire `nixpkgs` set into scope.\n\nTo see whats available, you can for example type `btrfs-progs.drvAttrs.` then\nhit `TAB`.\n\nAnother way to do this is to move our overlay to the\n`~/.config/nixpkgs/overlays` directory and rename the file like the following,\nagian this adds an impurity because it relies on your `~/.config` directory\nwhich is different from user to user:\n\n```bash\nmv overlay.nix ~/.config/nixpkgs/overlays/btrfs-progs.nix\ncd ~/src/nixpkgs\nnix-build -A btrfs-progs\nchecking for references to /build/ in /nix/store/szd6lizahidjniz85a0g1wsrfknirhwb-btrfs-progs-6.13...\ngzipping man pages under /nix/store/szd6lizahidjniz85a0g1wsrfknirhwb-btrfs-progs-6.13/share/man/\npatching script interpreter paths in /nix/store/szd6lizahidjniz85a0g1wsrfknirhwb-btrfs-progs-6.13\n/nix/store/szd6lizahidjniz85a0g1wsrfknirhwb-btrfs-progs-6.13/bin/fsck.btrfs: interpreter directive changed from \"#!/bin/sh -f\" to \"/nix/store/xy4jjgw87sbgwylm5kn047d9gkbhsr9x-bash-5.2p37/bin/sh -f\"\nstripping (with command strip and flags -S -p) in  /nix/store/szd6lizahidjniz85a0g1wsrfknirhwb-btrfs-progs-6.13/lib /nix/store/szd6lizahidjniz85a0g1wsrfknirhwb-btrfs-progs-6.13/bin\n/nix/store/szd6lizahidjniz85a0g1wsrfknirhwb-btrfs-progs-6.13\n```\n\n## Overlays with Flakes\n\nIn a flake, overlays are defined in the `outputs.overlays` attribute set of the\n`flake.nix`.\n\nThey are then applied to `nixpkgs` inputs using\n`inputs.nixpkgs.follows = \"nixpkgs\";` (or similar) and the overlays attribute on\nthe input.\n\nExample of flake usage:\n\n```nix\n# flake.nix\n{\n  description = \"My NixOS flake with custom overlays\";\n\n  inputs = {\n    nixpkgs.url = \"github:NixOS/nixpkgs/nixos-unstable\";\n  };\n\n  outputs = { self, nixpkgs, ... }: {\n\n    overlays.myCustomOverlay = final: prev: {\n      btrfs-progs = prev.btrfs-progs.overrideAttrs (old: rec {\n        version = \"6.13\";\n        src = self.fetchurl {\n          url = \"mirror://kernel/linux/kernel/people/kdave/btrfs-progs/btrfs-progs-v${version}.tar.xz\";\n          hash = \"sha256-ZbPyERellPgAE7QyYg7sxqfisMBeq5cTb/UGx01z7po=\";\n        };\n      });\n    };\n\n    nixosConfigurations.my-system = nixpkgs.lib.nixosSystem {\n      system = \"x86_64-linux\";\n      modules = [\n        # Apply the overlay\n        { nixpkgs.overlays = [ self.overlays.myCustomOverlay ]; }\n        ./configuration.nix\n      ];\n    };\n  };\n}\n```\n\n```bash\nnix flake show\npath:/home/jr/btrfs-progs?lastModified=1749655369&narHash=sha256-ln6dLiqo7TxStQSXgcIwfbdt7STGw4ZHftZRfWpY/JQ%3D\n├───nixosConfigurations\n│   └───my-system: NixOS configuration\n└───overlays\n    └───myCustomOverlay: Nixpkgs overlay\n```\n","number":[12,3],"sub_items":[],"path":"nixpkgs/overlay.md","source_path":"nixpkgs/overlay.md","parent_names":["Working with Nixpkgs Locally"]}}],"path":"Working_with_Nixpkgs_Locally_10.md","source_path":"Working_with_Nixpkgs_Locally_10.md","parent_names":[]}},{"Chapter":{"name":"Nix Pull Requests","content":"# Chapter 11\n\n<details>\n<summary> ✔️ Click to Expand Table of Contents</summary>\n\n<!-- toc -->\n\n</details>\n\n![gruv16](images/gruv16.png)\n\n## Nix Pull Requests\n\n**Pull requests** communicate changes to a branch in a repository. Once a pull\nrequest is opened, you can review changes with collaborators and add follow-up\ncommits.\n\n- A **pull request** is a proposal to merge a set of changes from one branch\n  into another. In a pull request, collaborators can review and discuss the\n  proposed set of changes before they integrate the changes into the main\n  codebase.\n\n- Pull requests display the differences, or diffs, between the content in the\n  source branch and the content in the target branch.\n\n```mermaid\ngraph LR\n    A[Your Local Repository] --> B(Feature Branch);\n    B --> C{GitHub Repository};\n    C -- \"Open Pull Request\" --> D[Pull Request on GitHub];\n    D -- \"Review & Discussion\" --> D;\n    D -- \"Merge\" --> E(Main Branch on GitHub);\n    E --> F[Nixpkgs Users];\n```\n\n**Explanation of the Diagram**:\n\n<details>\n<summary> ✔️ Click to see Explanation </summary>\n\n- **A[Your Local Repository]**: This represents the copy of the Nixpkgs repo on\n  your computer where you make changes.\n\n- **B (Feature Branch)**: You create a dedicated branch (e.g.`my-pack-update`)\n  to isolate your changes.\n\n- **C {GitHub Repository}**: This is the central online repo for Nixpkgs on\n  Github. You push your feature branch to this repo.\n\n- **C -- \"Open Pull Request\" -- D [Pull Request on Github]**: You initiate a\n  pull request from your feature branch to the main branch (usually `master` or\n  `main`) through the GitHub interface.\n\n- **D [Pull Request on GitHub]**: This is where collaborators can see your\n  proposed changes, discuss them, and provide feedback.\n\n- **D -- \"Review & Discussion\" --> D**: The pull request facilitates communication\n  and potential revisions based on the review.\n\n- **D -- \"Merge\" --> E (Main Branch on GitHub)**: Once the changes are approved,\n  they are merged into the main branch of the Nixpkgs repository.\n\n- **E (Main Branch on GitHub)**: The main branch now contains the integrated\n  changes.\n\n- **E --> F [Nixpkgs Users]**): Eventually, these changes become available to all\n  Nixpkgs users through updates to their Nix installations.\n\n</details>\n\nFlakes often rely on having access to the full history of the Git repository\nto correctly determine dependencies, identify specific revisions of inputs,\nand evaluate the flake. Not in all situations will a shallow clone work and\nthis is one of them.\n\nIf you have any changes to your local copy of Nixpkgs make sure to stash them\nbefore the following:\n\n```bash\ngit stash -u\n```\n\n- This command saves your uncommited changes (including staged files)\n  temporarily. You can restore them later with `git stash pop`\n\n**Step 1 Clone Nixpkgs Locally**\n\nIf you don't have Nixpkgs locally, you'll need to clone it:\n\n```bash\ngit clone https://github.com/NixOS/nixpkgs.git\n```\n\n**Step 2 Find a Relevant Pull Request**\n\nTo find specifig commits and releases:\n\n[status.nixos.org](https://status.nixos.org/) provides the latest tested commits\nfor each release - use when pinning to specific commits. List of active release\nchannels - use when tracking latest channel versions.\n\nThe complete list of channels is available at [nixos.org/channels](https://channels.nixos.org/)\n\nTo find a relevant PR you can go to:\n\n- [Nixpkgs Pull Requests](https://github.com/NixOS/nixpkgs/pulls)\n\n- The following example actually uses the [Nix Pull Requests](https://github.com/NixOS/nix/pulls)\n  the process is the same, but that is an important distinction.\n\n- In the Filters enter `stack trace` for this example.\n\n- The pull request I chose was [8623](https://github.com/nixos/nix/pull/8623)\n\n**Step 3 Add the Remote Repository (if necessary)**\n\nIf the pull request is from a different repository than your local clone\n(as in the case of the `nix` PR while working in a `nixpkgs` clone), you need to\nadd that repository as a remote. It's common to name the main Nixpkgs remote\n`origin` and other related repositories like `nix` as `upstream`.\n\nAssuming you are in your `nixpkgs` clone and want to test a PR from the `nix`\nrepository:\n\n```bash\ngit remote add upstream https://github.com/NixOS/nix.git\n```\n\n**Step 4 Fetch the Pull Request Changes**\n\nFetch the Pull Request Information:\n\n```bash\ngit fetch upstream refs/pull/8623/head:pr-8623\n```\n\n- This command fetches the branch named `head` from the pull request `8623` in\n  the `upstream` remote and creates a local branch named `pr-8623` that tracks it.\n\n**Output**:\n\n<details>\n<summary> ✔️ Output (Click to Enlarge) </summary>\n\n```\nremote: Enumerating objects: 104651, done.\nremote: Counting objects: 100% (45/45), done.\nremote: Compressing objects: 100% (27/27), done.\nremote: Total 104651 (delta 33), reused 20 (delta 18), pack-reused 104606 (from 1)\nReceiving objects: 100% (104651/104651), 61.64 MiB | 12.56 MiB/s, done.\nResolving deltas: 100% (74755/74755), done.\nFrom https://github.com/NixOS/nix\n * [new ref]             refs/pull/8623/head -> pr-8623\n * [new tag]             1.0                 -> 1.0\n * [new tag]             1.1                 -> 1.1\n * [new tag]             1.10                -> 1.10\n * [new tag]             1.11                -> 1.11\n * [new tag]             1.11.1              -> 1.11.1\n * [new tag]             1.2                 -> 1.2\n * [new tag]             1.3                 -> 1.3\n * [new tag]             1.4                 -> 1.4\n * [new tag]             1.5                 -> 1.5\n * [new tag]             1.5.1               -> 1.5.1\n * [new tag]             1.5.2               -> 1.5.2\n * [new tag]             1.5.3               -> 1.5.3\n * [new tag]             1.6                 -> 1.6\n * [new tag]             1.6.1               -> 1.6.1\n * [new tag]             1.7                 -> 1.7\n * [new tag]             1.8                 -> 1.8\n * [new tag]             1.9                 -> 1.9\n * [new tag]             2.0                 -> 2.0\n * [new tag]             2.2                 -> 2.2\n```\n\n</details>\n\n**Step 5 Checkout the Local Branch:**\n\n```bash\ngit checkout pr-8623\n```\n\nOr with the `gh` cli:\n\n```bash\ngh pr checkout 8623\n```\n\n## Build and Test the Changes\n\n- Now we want to see if the code changes introduced by the pull request actually\n  build correctly within the Nix ecosystem.\n\n```bash\nnix build\n```\n\n**Output:**\n\n<details>\n<summary> ✔️ Output (Click to Enlarge) </summary>\n\n```bash\nerror: builder for '/nix/store/rk86daqgf6a9v6pdx6vcc5b580lr9f09-nix-2.20.0pre20240115_20b4959.drv' failed with exit code 2;\n   last 25 log lines:\n   >\n   >         _NIX_TEST_ACCEPT=1 make tests/functional/lang.sh.test\n   >\n   >     to regenerate the files containing the expected output,\n   >     and then view the git diff to decide whether a change is\n   >     good/intentional or bad/unintentional.\n   >     If the diff contains arbitrary or impure information,\n   >     please improve the normalization that the test applies to the output.\n   > make: *** [mk/lib.mk:90: tests/functional/lang.sh.test] Error 1\n   > make: *** Waiting for unfinished jobs....\n   > ran test tests/functional/selfref-gc.sh... [PASS]\n   > ran test tests/functional/store-info.sh... [PASS]\n   > ran test tests/functional/suggestions.sh... [PASS]\n   > ran test tests/functional/path-from-hash-part.sh... [PASS]\n   > ran test tests/functional/gc-auto.sh... [PASS]\n   > ran test tests/functional/path-info.sh... [PASS]\n   > ran test tests/functional/flakes/show.sh... [PASS]\n   > ran test tests/functional/fetchClosure.sh... [PASS]\n   > ran test tests/functional/completions.sh... [PASS]\n   > ran test tests/functional/build.sh... [PASS]\n   > ran test tests/functional/impure-derivations.sh... [PASS]\n   > ran test tests/functional/build-delete.sh... [PASS]\n   > ran test tests/functional/build-remote-trustless-should-fail-0.sh... [PASS]\n   > ran test tests/functional/build-remote-trustless-should-pass-2.sh... [PASS]\n   > ran test tests/functional/nix-profile.sh... [PASS]\n   For full logs, run:\n     nix log /nix/store/rk86daqgf6a9v6pdx6vcc5b580lr9f09-nix-2.20.0pre20240115_20b4959.drv\n```\n\n</details>\n\n- **`nix build`** (Part of the Nix Unified CLI):\n\n  - Declarative: when used within a Nix flake (`flake.nix`), `nix build` is a\n    bit more declarative. It understands the outputs defined in your flake.\n\n  - Clearer Output Paths: `nix build` typically places build outputs in the\n    `./result` directory by default (similar to `nix-build`'s `result` symlink)\n\n  - Better Error Reporting: It gives more informative error messages.\n\n  - Future Direction\n\n**Benefits of using `nix build`:**\n\n- **Flake Integration:** `nix build` naturally understands the flake's outputs.\n\n- **Development Shells:** When you are in a `nix develop` shell, `nix build` is\n  the more idiomatic way to build packages defined in your dev environment.\n\n- **Consistency:** Using the unified CLI promotes a more consistent workflow.\n\n## Next Steps\n\nAs you can see this build failed, as for why the build failed, the key part of\nthe error message is:\n\n```bash\nmake: *** [mk/lib.mk:90: tests/functional/lang.sh.test] Error 1\n```\n\n- This suggests that one of the functional tests (`lang.sh.test`) failed. This\n  happens when the expected output of the test doesn't match the actual output.\n\nThis can heppen when:\n\n1. The test expectations are outdated due to changes in the codebase.\n\n2. The test captures environment-specific or transient outputs that are not\n   properly normalized.\n\n3. The test includes impure or non-deterministic information, making it hard to\n   verify.\n\nTo address this, \\_NIX_TEST_ACCEPT=1 is used as an override mechanism that tells\nthe test framework: > \"Accept whatever output is generated as the new expected\nresult.\"\n\nThe message advises running:\n\n```bash\n_NIX_TEST_ACCEPT=1 make tests/functional/lang.sh.test\n```\n\n- This will regenerate the expected output files, allowing you to inspect what\n  changed with `git diff`:\n\n```bash\ngit diff tests/functional/lang.sh.test\n```\n\n- **Verifies if Changes are Intentional:** If the difference is reasonable and\n  expected (due to a legitimate update in the logic), you can commit these changes\n  to update the test suit. If not, you have to refine the test normalization process\n  further.\n\nIf the changes seem valid, commit them:\n\n```bash\ngit add tests/functional/lang.sh.test\ngit commit -m \"Update expected test output for lang.sh.test\"\n```\n\nRunning the following will provide the full logs:\n\n```bash\nnix log /nix/store/rk86daqgf6a9v6pdx6vcc5b580lr9f09-nix-2.20.0pre20240115_20b4959.drv\n```\n\n### Conclusion\n\nTesting Nixpkgs pull requests is a vital part of contributing to a healthy and\nreliable Nix ecosystem. By following these steps, you can help ensure that\nchanges are well-vetted before being merged, ultimately benefiting all Nix users.\nYour efforts in testing contribute significantly to the quality and stability\nof Nixpkgs.\n","number":[13],"sub_items":[],"path":"Nix_Pull_Requests_11.md","source_path":"Nix_Pull_Requests_11.md","parent_names":[]}},{"Chapter":{"name":"Intro to Nushell on NixOS","content":"# Chapter 12\n\n<details>\n<summary> ✔️ Click to Expand Table of Contents</summary>\n\n<!-- toc -->\n\n</details>\n\n![Nu](images/nu.png)\n\n## Intro to Nushell on NixOS\n\n- **TL;DR**:I recently switched default shells from zsh to nushell, this post is\n  about some of the challenges and advantages of using nushell with NixOS.\n\n- While the average user might not immediately see significant advantages, those\n  who frequently work with structured data formats like JSON, YAML, and CSV –\n  such as developers interacting with APIs, system administrators managing\n  configurations, and data professionals – will likely find Nushell's native\n  data handling and powerful pipeline capabilities a plus. Additionally, users\n  who value a more consistent and safer scripting experience might appreciate\n  Nushell's language-first design and features like strong typing.\n\n- I'll start with some of the unique build design choices and unique features\n  that I think make Nushell special, then show an example using Nushell to\n  manipulate JSON data. Finally, I will highlight some of the visually appealing\n  aspects of Nushell and lastly I share some resources for learning more.\n\n## The Good\n\n- Nushell borrows concepts from many shells and languages and is itself both a\n  programming language and a shell. Because of this, it has its own way of\n  working with files, directories, websites, and more.\n\n- Nushell is powerful and has many essential commands built directly into the\n  shell (\"internal\" commands) rather than a link to an executable. You can use\n  this set of commands across different operating systems, having this\n  consistency is helpful when creating cross-platform code.\n\n- When internal Nushell commands (like `ls`, `open`, `where`, `get`, `sort-by`,\n  etc.) produce output, they generally do so in Nushell's structured data format\n  (tables or records). This is the shell's native way of representing\n  information.\n\n- Beyond these foundational strengths, Nushell offers a range of unique features\n  that enhance its functionality and make it particularly well-suited for\n  data-heavy tasks. Here are some highlights that showcase its versatility.\n\n**Some Unique Features**:\n\n- Besides the built-in commands, Nushell has a\n  [standard library](https://www.nushell.sh/book/standard_library.html) Nushell\n  operates on _structured data_. You could call it a \"data-first\" shell and\n  programming language.\n\n- Also included, is a full-featured dataframe processing engine using\n  [Polars](https://github.com/pola-rs/polars) if you want to process large data\n  efficiently directly in your shell, check out the\n  [Dataframes-Docs](https://www.nushell.sh/book/dataframes.html)\n\n- **Multi-Line Editing**:\n\n- When writing a long command you can press Enter to add a newline and move to\n  the next line. For example:\n\n```nu\nls            |    # press enter\nwhere name =~ |    # press enter, comments after pipe ok\nget name      |    # press enter\nmv ...$in ./backups/\n```\n\n- This allows you to cycle through the entire multi-line command using the up\n  and down arrow keys and then customize different lines or sections of the\n  command.\n\n- You can manually insert a newline using `Alt+Enter` or `Shift+Enter`.\n\n- The [Reedline-Editor](https://www.nushell.sh/book/line_editor.html) is\n  powerful and provides good `vi-mode` or `emacs` support built in.\n\n- It's default `Ctrl+r` history command is nice to work with out of the box.\n\n- The [explore](https://www.nushell.sh/book/explore.html#parameters) command, is\n  nu's version of a table pager, just like `less` but for table structured data:\n\n```nu\n$nu | explore --peek\n```\n\n- With the above command you can navigate with vim keybinds or arrow keys.\n\n- These features demonstrate Nushell’s user-friendly interface, but what truly\n  sets it apart is its underlying design as a structured data scripting\n  language. This “language-first” approach powers many of its distinctive\n  capabilities.\n\n![explore](images/explore.png)\n\n**Unique design**:\n\n- **Fundamentally designed as a structured data scripting language**: and then\n  it acts as a shell on top of that foundation. This \"language first\" approach\n  is what gives it many of its distinctive features and makes it a powerful\n  scripting language. I reiterate this here because of the implications of this.\n  A few of those features are:\n  - **Pipelines of structured data**: Unlike traditional shells that primarily\n    deal with plain text streams, Nushell pipelines operate on tables of\n    structured data. Each command can understand and manipulate this structured\n    data directly.\n\n  - **Consistent syntax**: Its syntax is more consistent and predictable\n    compared to the often quirky syntax of Bash and Zsh, drawing inspiration\n    from other programming languages.\n\n  - **Strong typing** Nushell has a type system, which helps catch errors early\n    and allows for more robust scripting.\n\n  - **First-class data types**: It treats various data formats (like JSON, CSV,\n    TOML) as native data types, making it easier to work with them. Because of\n    this, Nushell aims to replace the need for external tools like `jq`, `awk`,\n    `sed`, `cut`, and even some uses of `grep` and `curl`.\n\n- **Variables are Immutable by Default**: Nushell's commands are based on a\n  functional-style of programming which requires immutability, sound familiar?\n\n- **Nushell's Environment is Scoped**: Nushell takes many design cues from\n  compiled languages, one is that languages should avoid global mutable state.\n  Shells have commonly used global mutation to update the environment, Nushell\n  attempts to steer clear of this increasing reproducability.\n\n- **Single-use Environment Variables**:\n\n```nu\nFOO=BAR $env.FOO\n# => BAR\n```\n\n- **Permanent Environment Variables**: In your `config.nu`\n\n```nu\n# config.nu\n$env.FOO = 'BAR'\n```\n\n- [Coming-From-Bash](https://www.nushell.sh/book/coming_from_bash.html)\n\n- These design principles make Nushell a powerful tool for scripting, but\n  they’re best understood through a hands-on example. Let’s see how Nushell’s\n  structured data capabilities shine in a common task: processing a JSON file.\n\n**Example**: I wanted to provide a practical example to illustrate some of these\n\"Good\" features in action. And break it down for better understanding.\n\n- Let's consider a common task: processing data from a JSON file. Imagine you\n  have a file containing a list of users with their names and ages. With\n  traditional shells, you'd likely need to rely on external tools like `jq` to\n  parse and filter this data. However, Nushell can handle this directly within\n  its own commands.\n\n- For this example you could create a `test` directory and move to it:\n\n```bash\nmkdir test ; cd test\n```\n\n- Create a `users.json` with the following contents:\n\n👇 users.json\n\n```json\n[\n  { \"name\": \"Alice\", \"age\": 25 },\n  { \"name\": \"Bob\", \"age\": 30 },\n  { \"name\": \"Charlie\", \"age\": 20 }\n]\n```\n\n- And create the following `filter.nu` that first converts `users.json` into its\n  own internal structured data format with the `open` command, then to filters\n  out people under `21` with the `where` control flow construct, then selects\n  the `name` and `age` columns, sorts them by age, and finally converts them\n  back to `json` and saves them to a file called `filtered_users.json`. A lot\n  happening in a 6 line script.\n\n```nu\n# filter.nu\nopen users.json           # Read JSON file into structured data\n| where age > 21         # Filter users older than 21\n| select name age        # Select only name and age columns\n| sort-by age            # Sort by age\n| to json                # Convert back to JSON\n| save filtered_users.json # Save result to a new file\n```\n\n- The `open` command takes data from a file (or even a URL in some cases) and\n  parses it and converts it into Nushells own internal structured data format.\n  So this command isn't just showing you the contents of `users.json` but doing\n  a conversion to Nu's special structured format.\n\n```nu\nopen users.json\n╭───┬─────────┬─────╮\n│ # │  name   │ age │\n├───┼─────────┼─────┤\n│ 0 │ Alice   │  25 │\n│ 1 │ Bob     │  30 │\n│ 2 │ Charlie │  20 │\n╰───┴─────────┴─────╯\n```\n\n- The `source` command in Nushell is used to execute the commands within a\n  script file (like `filter.nu`) in the current Nushell environment. It's\n  similar to running the script directly in the shell, but keeps the shell open\n  for further use. In this example, `source filter.nu` runs the commands inside\n  `filter.nu`, processing the `users.json` file and creating the\n  `filtered_users.json` file:\n\n```nu\nsource filter.nu\n# View the contents with bat\nbat filtered_users.json\n───────┬──────────────────────────────────────────────────────────────────────────────────────\n       │ File: filtered_users.json\n───────┼──────────────────────────────────────────────────────────────────────────────────────\n   1   │ [\n   2   │   {\n   3   │     \"name\": \"Alice\",\n   4   │     \"age\": 25\n   5   │   },\n   6   │   {\n   7   │     \"name\": \"Bob\",\n   8   │     \"age\": 30\n   9   │   }\n  10   │ ]\n───────┴───────────────────────────────────────────────────────────────────────────────────\n```\n\n- As you can see, without needing any external tools, Nushell was able to read,\n  filter, select, sort, and then re-serialize JSON data using a clear and\n  concise pipeline. This demonstrates its power in handling structured data\n  natively, making common data manipulation tasks within the shell significantly\n  more streamlined and readable compared to traditional approaches.\n\n**In the filter.nu example:**\n\n```nu\n# filter.nu\nopen users.json           # Read JSON file into structured data\n| where age > 21         # Filter users older than 21\n| select name age        # Select only name and age columns\n| sort-by age            # Sort by age\n| to json                # Convert back to JSON\n| save filtered_users.json # Save result to a new file\n```\n\n<details>\n<summary> ✔️ Summary of above Command (Click to Expand)</summary>\n\n1. `open users.json`: Produces a **Nushell table** representing the data.\n\n2. `| where age > 21`: Receives the table, filters rows based on the `age`\n   column, and outputs a new, filtered table.\n\n3. `| select name age`: Receives the filtered table, selects only the `name` and\n   `age` columns, and outputs a table with fewer columns.\n\n4. `| sort-by age`: Receives the table, sorts the rows based on the `age`\n   column, and outputs a sorted table.\n\n5. `| to json`: Receives the sorted table and converts it back into JSON text.\n\n6. `| save filtered_users.json`: Receives the JSON text and saves it to a file.\n\n- So, while the concept of piping is the same, the nature of the data flowing\n  through the Nushell pipeline is richer and more structured, enabling more\n  powerful and direct data manipulation.\n\n- While Nushell’s strengths, like its structured data pipelines, make it a\ngame-changer for many tasks, it’s not without its challenges, especially when\nintegrated with NixOS’s Bash-centric ecosystem. Let’s explore some of the\nlimitations you might encounter when adopting Nushell as your default shell.\n</details>\n\n### The Bad\n\n- While the project is still maturing, the active community and ongoing\n  improvements are promising. Don't get too discouraged by the following, there\n  would be a bad section for any shell imo.\n- There are many similarities so it can be easy to forget that some Bash (and\n  POSIX in general) style constructs just won't work in Nushell. Considering\n  that NixOS seems to have been designed for bash, even Zsh isn't fully\n  compatable you may want to think twice before you choose Nushell as your\n  default.\n\n- The documentation is incomplete and written by devs for devs imo, it is quite\n  a bit different from anything else I've seen so there is a bit of a learning\n  curve. Nushell is generally still considered to be in a stage where it might\n  not be the most seamless or trouble-free experience as a daily driver default\n  shell for most users, especially on a system like NixOS known for its unique\n  approach.\n\n- The [any-nix-shell](https://github.com/haslersn/any-nix-shell) project doesn't\n  include Nushell as with many others because of it's lack of maturity.\n\n- The following addition comes from Joey_McKur's sugggestion, on mentioning the\n  `job` command as one of the biggest criticisms against Nu because it doesn't\n  support background tasks. I should also note that Nushell's team is aware of\n  these criticisms and actively working on improving job control.\n\n**Limited Feature Set Compared to Traditional Job Control:**\n\n- **Lack of Full POSIX Job Control**: Nushell's job control doesn't yet fully\n  implement all the features and signals defined by POSIX job control (e.g.,\n  more nuanced signal handling, stopped jobs). While it covers the basics, users\n  accustomed to advanced Bash job control might find it lacking.\n\n- **Foregrounding Behavior**: There have been criticisms about how foregrounding\n  jobs interacts with the terminal and potential issues with signal propagation.\n\n**Output Handling Challenges**:\n\n- **Interleaved Output**: Managing the output of multiple backgrounded jobs can\n  sometimes be messy, with output from different jobs potentially interleaving\n  in the terminal. While Nushell tries to handle this, it's not always as clean\n  as desired.\n\n- **Redirection Complexity**: Redirecting the input and output of backgrounded\n  jobs can be less straightforward than in Bash, sometimes requiring more\n  explicit handling.\n\n**Integration with Pipelines:**\n\n- **Backgrounding Pipelines**: Backgrounding complex pipelines with multiple\n  stages can sometimes lead to unexpected behavior or difficulties in managing\n  the entire pipeline as a single job.\n\n**Error Reporting:**\n\n- **Difficult to Track Errors in Background Jobs**: Identifying and debugging\n  errors in backgrounded jobs can be less direct than with foreground processes,\n  and the job command's output might not always provide sufficient information\n  for troubleshooting.\n\n- Many of Nushell’s challenges stem from its departure from traditional shell\n  conventions, particularly those of Bash, which NixOS heavily relies on. To\n  better understand these differences and how they impact your workflow, let’s\n  compare Nushell’s static, structured approach to Bash’s dynamic, text-based\n  model.\n\n### Key Differences Between Nushell & Bash\n\n| **Feature**        | **Bash (Dynamic)**        | **Nushell (Static)**                          |\n| ------------------ | ------------------------- | --------------------------------------------- |\n| Code Execution     | Line-by-line              | Whole script parsed first                     |\n| Error Detection    | Runtime errors only       | Catches errors before running                 |\n| Support for `eval` | ✅ Allowed                | ❌ Not supported                              |\n| Custom Parsing     | Limited                   | Built-in semantic analysis                    |\n| IDE Features       | Basic syntax highlighting | Advanced integration, linting, and formatting |\n\n- `&&` doesn't work use `;` instead.\n\n- `>` is used as the greater-than operator for comparisons:\n\n```nu\n\"hello\" | save output.txt\n```\n\nis equivalent to the following in bash:\n\n```bash\necho \"hello\" > output.txt\n```\n\n- If you notice above the nushell command doesn't require an `echo` prefix, this\n  is because Nushell has **Implicit Return**:\n\n```nu\n\"Hello, World\" == (echo \"Hello, World\")\n# => true\n```\n\n- The above example shows that the string, `\"Hello, World\"` is equivalent to the\n  output value from `echo \"Hello, World\"`\n\n- **Every Command Returns a Value**:\n\n```nu\nlet p = 7\nprint $p  # 7\n$p * 6    # 42\n```\n\n- Understanding these differences highlights why Nushell feels so distinct from\n  Bash, but it’s the shell’s advanced features and integrations that truly make\n  it shine. Let’s dive into some of the beautiful and powerful tools and custom\n  commands that elevate Nushell for NixOS users.\n\n### The Beautiful and Powerful\n\n- `Ctrl+t` List Commands with carapace and fzf:\n\n  ![nu4](images/nu4.png)\n\n- `Carapace`\n  [Carapace-Bin Install](https://carapace-sh.github.io/carapace-bin/install.html):\n\nThe folling is showing tab completion, I typed `hx fl<TAB>`:\n\n![nu9](images/nu9.png)\n\n- `Carapace` man example:\n\n  ![nu7](images/nu7.png)\n\n**Custom Nushell Commands**\n\nMost of the following scripts come from the\n[nu_scripts repo](https://github.com/nushell/nu_scripts#)\n\n- The following command allows you to choose which input to update interactively\n  with fzf.\n\n<details>\n<summary> ✔️ Click to See Command</summary>\n\n```nu\n# nix.nu\n# upgrade system packages\n# `nix-upgrade` or `nix-upgrade -i`\ndef nix-upgrade [\n  flake_path: string = \"/home/jr/flake\", # path that contains a flake.nix\n  --interactive (-i) # select packages to upgrade interactively\n]: nothing -> nothing {\n  let working_path = $flake_path | path expand\n  if not ($working_path | path exists) {\n    echo \"path does not exist: $working_path\"\n    exit 1\n  }\n  let pwd = $env.PWD\n  cd $working_path\n  if $interactive {\n    let selections = nix flake metadata . --json\n    | from json\n    | get locks.nodes\n    | columns\n    | str join \"\\n\"\n    | fzf --multi --tmux center,20%\n    | lines\n    # Debug: Print selections to verify\n    print $\"Selections: ($selections)\"\n    # Check if selections is empty\n    if ($selections | is-empty) {\n      print \"No selections made.\"\n      cd $pwd\n      return\n    }\n    # Use spread operator to pass list items as separate arguments\n    nix flake update ...$selections\n  } else {\n    nix flake update\n  }\n  cd $pwd\n  nh os switch $working_path\n}\n```\n\n</details>\n\n**Usage**:\n\n```nu\nnix-upgrade\n# or for individual packages\nnix-upgrade -i\n```\n\n![nu5](images/nu5.png)\n\n- The `ns` command is designed to search for Nix packages using `nix search` and\n  present the results in a cleaner format, specifically removing the\n  architecture and operating system prefix that nix search often includes.\n\n<details>\n<summary> ✔️ Click To Expand</summary>\n\n```nu\ndef ns [\n    term: string # Search target.\n] {\n\n    let info = (\n        sysctl -n kernel.arch kernel.ostype\n        | lines\n        | {arch: ($in.0|str downcase), ostype: ($in.1|str downcase)}\n    )\n\n    nix search --json nixpkgs $term\n        | from json\n        | transpose package description\n        | flatten\n        | select package description version\n        | update package {|row| $row.package | str replace $\"legacyPackages.($info.arch)-($info.ostype).\" \"\"}\n}\n```\n\n</details>\n\n**Usage**:\n\n```nu\nns fzf<ENTER>\n```\n\n![nu10](images/nu10.png)\n\n- `nufetch` command:\n\n<details>\n<summary> ✔️ Click To Expand</summary>\n\n```nu\n# `nufetch` `(nufetch).packages`\ndef nufetch [] {\n{\n\"kernel\": $nu.os-info.kernel_version,\n\"nu\": $env.NU_VERSION,\n\"packages\": (ls /etc/profiles/per-user | select name | prepend [[name];\n[\"/run/current-system/sw\"]] | each { insert \"number\" (nix path-info --recursive\n ($in | get name) | lines | length) | insert \"size\" ( nix path-info -S\n ($in | get name) | parse -r '\\s(.*)' | get capture0.0 | into filesize) | update\n \"name\" ($in | get name | parse -r '.*/(.*)' | get capture0.0 | if $in == \"sw\"\n {\"system\"} else {$in}) | rename \"environment\"}),\n\"uptime\": (sys host).uptime\n}\n}\n```\n\n</details>\n\n![nu1](images/nu1.png)\n\n- `duf` command, I have mine aliased to `df`:\n\n![nu8](images/nu8.png)\n\n- `ps` command:\n\n![ps](images/ps.png)\n\n- `nix-list-system` command lists all installed packages:\n\n```nu\n# list all installed packages\ndef nix-list-system []: nothing -> list<string> {\n  ^nix-store -q --references /run/current-system/sw\n  | lines\n  | filter { not ($in | str ends-with 'man') }\n  | each { $in | str replace -r '^[^-]*-' '' }\n  | sort\n}\n```\n\n**Usage**:\n\n```bash\nnix-list-system\n```\n\n![nu6](images/nu6.png)\n\n- These custom Nushell commands showcase its flexibility, but sometimes you need\n  to work around Nushell’s limitations, like compatability with certain NixOS\n  tools. This is where `just` and `justfiles` come in, simplifying complex\n  workflows and bridging gaps in Nushell’s functionality.\n\n## Using Just and Justfiles\n\n- The following is my `justfile` that I keep right next to my `flake.nix` it\n  simplifies some commands and makes things work that weren't working with\n  nushell for my case, you'll have to change it to match your configuration.\n  It's not perfect but works for my use case, take whats useful and leave the\n  rest.\n\n- You'll first need to install [just](https://github.com/casey/just) to make use\n  of `justfiles`.\n\n```bash\n# nix shell nixpkgs#just nixpkgs#nushell\nset shell := [\"nu\", \"-c\"]\nflake_path := \"/home/jr/flake\"\nhostname := \"magic\"\nhome_manager_output := \"jr@magic\"\n\nutils_nu := absolute_path(\"utils.nu\")\n\ndefault:\n    @just --list\n# Rebuild\n[group('nix')]\nfr:\n    nh os switch --hostname {{hostname}} {{flake_path}}\n\n# Flake Update\n[group('nix')]\nfu:\n    nh os switch  --hostname {{hostname}} --update {{flake_path}}\n\n# Update specific input\n# Usage: just upp nixpkgs\n[group('nix')]\nupp input:\n    nix flake update {{input}}\n# Test\n[group('nix')]\nft:\n    nh os test --hostname {{hostname}} {{flake_path}}\n# Collect Garbage\n[group('nix')]\nncg:\n    nix-collect-garbage --delete-old ; sudo nix-collect-garbage -d ; sudo /run/current-system/bin/switch-to-configuration boot\n\n[group('nix')]\ncleanup:\n    nh clean all\n\n```\n\n- To list available commands type, (you must be in the same directory as the\n  justfile): `just`\n\n![just](images/just2.png)\n\n- So `just fmt` will run `nix fmt`.\n\n- A lot of the `.nu` files came from this repo by BlindFS:\n  - [modern-dot-files](https://github.com/blindFS/modern-dot-files/tree/main) he\n    uses Nix Darwin so there are a few changes for NixOS. I found this through\n    [this_week_in_nu](https://github.com/nushell/this_week_in_nu).\n\n  - [my-nu-config](https://github.com/TSawyer87/flakes/tree/main/homeManagerModules/shells/nushell)\n    If you use this, you'll need to change the first line of `fzf.nu` to the\n    location of your config. You'll also need to change the constants at the top\n    of `config.nu`. These are my old dotfiles, I have recently updated and made\n    sure this config is up to date with recent nushell changes. Also, change the\n    `let flake_path = ($env.HOME | path join \"flake\")` to your flake path.\n\n  - The examples use this starship\n    config[Aylur-dotfiles](https://github.com/Aylur/dotfiles/blob/main/home/starship.nix)\n    The logic on the bottom enables starship for Nushell, Zsh, and Bash!\n\n  - If you wan't to use my config you'll have to enable the experimental-feature\n    `pipe-operators` in the same place you enable flakes and nix-command.\n\n- There are still situations where I need to switch to zsh or bash to get\n  something to work i.e. `nix-shell` and a few others.\n\n- From custom commands to `justfile` integrations, Nushell offers a wealth of\n  tools to enhance your NixOS experience, even if occasional workarounds are\n  needed. To dive deeper into Nushell and tailor it to your needs, here are some\n  valuable resources to explore, from official documentation to community-driven\n  configurations.\n\n#### Resources\n\n<details>\n<summary> ✔️ Click to Expand Resources </summary>\n\n- [Nushell-Book](https://www.nushell.sh/book/)\n\n- [Nushell-Cookbook](https://www.nushell.sh/cookbook/)\n\n- [nu_scripts](https://github.com/nushell/nu_scripts) some of the custom\n  commands came from here.\n\n- [nushell sample-config](https://github.com/nushell/nushell/tree/main/crates/nu-utils/src/default_files)\n\n- [awesome-nu repo](https://github.com/nushell/awesome-nu#plugins)\n\n- [nu showcase-repo](https://github.com/nushell/showcase)\n\n- [discord](https://discord.com/invite/NtAbbGn) You can find custom commands,\n  configurations, etc here.\n\n</details>\n","number":[14],"sub_items":[],"path":"intro_to_nushell_on_NixOS.md","source_path":"intro_to_nushell_on_NixOS.md","parent_names":[]}},{"Chapter":{"name":"NixOS Containers","content":"# NixOS Containers\n\n<details>\n<summary> ✔️ Click to Expand Table of Contents</summary>\n\n<!-- toc -->\n\n</details>\n\n![boxes](images/boxes.cleaned.png)\n\nNixOS containers are lightweight `systemd-nspawn` containers managed\ndeclaratively through your NixOS configuration. They allow you to run separate,\nminimal NixOS instances on the same machine, each with its own services,\npackages, and (optionally) network stack.\n\n> ❗ NixOS’ containers do not provide full security out of the box (just like\n> docker). They do give you a separate chroot, but a privileged user (root) in a\n> container can escape the container and become root on the host system.\n> --[beardhatcode Declarative-Nixos-Containers](https://blog.beardhatcode.be/2020/12/Declarative-Nixos-Containers.html)\n\n**Common Use Cases**\n\n- **Isolating services**: Run a web server, database, or any service in its own\n  container, so it can’t interfere with the main system or other services\n\n- **Testing and development**: Try out new configurations, packages, or services\n  in a sandboxed environment.\n\n- **Reproducible deployments**: Because containers are defined declaratively,\n  you can reproduce the exact same environment anywhere.\n\n- **Running multiple versions of a service**: For example, testing different\n  versions of Git or HTTP servers side by side.\n\n## Hosting mdbook\n\nLet’s say you want to host your mdBook. You can define a NixOS container that\nruns only the necessary service, isolated from your main system:\n\n```nix\n{\n  config,\n  lib,\n  ...\n}: {\n  containers.mdbook-host = {\n    autoStart = true;\n    ephemeral = true;\n    privateNetwork = false;  # Use the hosts network\n\n    bindMounts.\"/var/www/mdbook\" = {\n      hostPath = \"/home/jr/nix-book/book\";\n      isReadOnly = true;\n    };\n\n    config = {containerPkgs, ...}: {\n      networking.useDHCP = lib.mkDefault true;\n\n      services.httpd = {\n        enable = true;\n        adminAddr = \"yourEmail.com\";\n        virtualHosts.\"localhost\" = {\n          documentRoot = \"/var/www/mdbook\";\n          serverAliases = [];\n        };\n      };\n\n      networking.firewall.allowedTCPPorts = [80];\n      environment.systemPackages = with containerPkgs; [];\n      system.stateVersion = \"25.05\";\n    };\n  };\n}\n```\n\n- `ephemeral`: if true, the container resets on each restart.\n\n- `autoStart`: Ensures the container starts automatically at boot.\n\n- `config`: Defines the containers NixOS configuration, just like a regular\n  NixOS system.\n\n**Mounts**\n\n```nix\n    bindMounts.\"/var/www/mdbook\" = {\n      hostPath = \"/home/jr/nix-book/book\";\n      isReadOnly = true;\n    };\n```\n\nThe `bindMount` settings above specify that `/var/www/mdbook` in the container\nshould be linked to `/home/jr/nix-book/book` on the host.\n\n`hostPath` must exist, and `/var/www/mdbook` must not exist for this to work.\n\nThe above container is fairly simple because its `ReadOnly`, things get more\ncomplicated when you need HTTPD to have write privileges.\n\nWhen you create and run a NixOS container like `mdbook-host`. NixOS stores the\ncontainer's root filesystem and related container state data under:\n\n```bash\nls /var/lib/nixos-containers/\n╭────────────╮\n│ empty list │  # It's empty because we set ephemeral to true\n╰────────────╯\n```\n\nThis directory holds the container's own filesystem image, including system\nfiles, installed packages, configuration, and any data internal to the\ncontainer.\n\n## Check Container Status\n\n```bash\nnixos-container list\nmdbook-host\n```\n\n```bash\nsudo systemctl status container@mdbook-host\n Main PID: 32938 (systemd-nspawn)\n     Status: \"Container running: Ready.\"\n```\n\n**Test HTTP server inside the container**\n\nWe configured Apache (`httpd`) to serve `/var/www/mdbook` at `localhost`\n\nLet's check if Apache is running:\n\n```bash\nsudo nixos-container run mdbook-host -- systemctl status httpd\n● httpd.service - Apache HTTPD\n     Loaded: loaded (/etc/systemd/system/httpd.service; enabled; preset: ignored)\n     Active: active (running) since Fri 2025-08-15 10:14:39 EDT; 2min 18s ago\n```\n\nCheck the Bind Mount:\n\n```bash\nsudo nixos-container run mdbook-host -- ls -l /var/www/mdbook\n```\n\n- You should see an `index.html` and any other files from `~/nix-book/book`\n\nTest the Web Server:\n\n```bash\ncurl http://localhost\n```\n\n- You should see your book in HTTP format as raw HTML.\n\nTest on the web, in your browser visit:\n\n```text\nhttp://localhost/\n```\n\n- You should see your book fully served\n\n### Troubleshooting\n\nMake sure your book has the correct permissions to allow `hostPath` to read it:\n\n```bash\nsudo chmod -R o+rX ~/nix-book/book\n```\n\nIf needed restart the container:\n\n```bash\nsudo nixos-container stop mdbook-host\nsudo nixos-container start mdbook-host\n```\n\nEnsure that `/var/www/mdbook` is being populated:\n\n```bash\nsudo nixos-container run mdbook-host -- ls -l /var/www/mdbook\n```\n\nYou should see an `index.html` and more\n\n```bash\nsudo nixos-container run mdbook-host -- systemctl status httpd\n```\n\n- You should see `enabled` & `active (running)`\n\nCheck the containers status:\n\n```bash\nsudo nixos-container status mdbook-host\nup\n```\n\n## Why Bother Serving your book to localhost?\n\n1. Real-time updates without rebuilding the container\n\n- Files added, changed, or removed from `~/nix-book/book` on the host are\n  immediately reflected inside the container. This allows for:\n  - Rapid iteration and testing of your books content without rebuilding\n\n  - Easier debugging and fixing content or config issues on the fly.\n\n2. Keeps container images small and immutable\n\n- Instead of baking book files into the container image (which requires\n  rebuilding every change), the container image remains clean and generic.\n\n3. Separation of concerns\n\n- The container focuses on running the service, while the content is managed\n  independently on the host. This separation improves maintainability and more.\n\n4. Data persistence\n\n- Since the files live on the host, they persist independently of the containers\n  lifecycle: restarting, recreating, or destroying the container won't lose your\n  content.\n\n5. Security Control\n\n- You can carefully set permissions on the host directory, control read/write\n  access, and isolate the container runtime from sensitive data.\n\n## Removing the State\n\nTo remove `/var/lib/nixos-containers/mdbook-host`, you need to remove the\ncontainer configuration, rebuild, and then run the following commands to remove\nthe immutable sticky bits that prevent deletion.\n\n```bash\n# Forcibly remove all attributes\nsudo chattr -R -i mdbook-host/\nsudo rm -rf mdbook-host/\n```\n","number":[15],"sub_items":[],"path":"nixos_containers.md","source_path":"nixos_containers.md","parent_names":[]}}]}]
